import{_ as e,o as d,c as l,U as o}from"./chunks/framework.afdf1834.js";const E=JSON.parse('{"title":"diff","description":"","frontmatter":{},"headers":[],"relativePath":"audition/react/diff.md","filePath":"audition/react/diff.md","lastUpdated":null}'),i={name:"audition/react/diff.md"},t=o('<h1 id="diff" tabindex="-1">diff <a class="header-anchor" href="#diff" aria-label="Permalink to &quot;diff&quot;">​</a></h1><h2 id="react" tabindex="-1">react <a class="header-anchor" href="#react" aria-label="Permalink to &quot;react&quot;">​</a></h2><ul><li>策略一，树的diff：tree diff————层级控制，对dom节点的跨层级操作不做优化，只对两棵树同一层级进行比较。即同一个父节点下的所有子节点。当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会进一步的比较。</li><li>策略二，组件diff：component diff——dom节点组件的比较。 <ul><li>如果是同一个类的组件，则会继续往下diff运算，更新节点属性；</li><li>如果不是同一个类的组件，那么直接删除这个组件的所有子节点，创建新的组件。（即使是类似的组件，但只要组件不同，就会被销毁重新创建）</li></ul></li></ul><p>策略三，元素diff：element diff——dom同层级单个节点的比较。</p><ul><li>比较策略：先将所有列表遍历一遍，确定需要新增和删除的节点，再确定需要移动的节点。同一层级的节点，每个节点在对应的层级用唯一的key作为标识，diff算法有3种节点的操作：</li><li>（1）、插入（INSERT_MARKUP）：新的节点不在旧集合中，对新节点进行插入操作。</li><li>（2）、移动（MOVE_EXISTING）：该节点存在于旧集合中且是可更新的类型，此时可复用之前的node节点，更新属性，执行移动操作。</li><li>（3）、删除（REMOVE_NODE）：原节点不在新的集合中，或者在新的集合中不能直接复用或更新，对原节点执行删除操作。</li></ul><p>移动（MOVE_EXISTING）规则说明：若当前访问的节点在旧集合中的位置比lastIndex大，即节点在原集合中比在新集合中靠右，说明该元素不会影响到其他元素的位置，因此不会被添加到差异队列中，不执行移动操作，反之，进行移动操作。</p><p>也就是说旧集合的节点的index在新集合节点的index的右边<code>（oldIndex &gt;= newIndex）</code>那这个节点不移动，当旧集合的节点的index在对应新集合节点的index的左边<code>（oldIndex &lt; newIndex）</code>，移动这个节点，所以只会往右移不会往左移，如果在一长串集合中，如果最后一个元素移动到第一个，前面的所有元素都会移动，性能不佳要尽量避免，应该用元素的唯一标识id作为key值</p><h2 id="vue2、双端比较" tabindex="-1">vue2、双端比较 <a class="header-anchor" href="#vue2、双端比较" aria-label="Permalink to &quot;vue2、双端比较&quot;">​</a></h2><ol><li><strong>生成新的虚拟DOM树</strong>：在每次数据更新时，Vue.js会重新构建一棵新的虚拟DOM树，表示新的UI结构。</li><li><strong>比较新旧虚拟DOM树的根节点</strong>：Vue.js会比较新旧虚拟DOM树的根节点，判断它们是否相同类型的节点。 <ol><li>如果根节点相同，进入下一步，比较其子节点。</li><li>如果根节点不同，Vue.js会销毁旧的虚拟DOM树及其对应的真实DOM，并将新的虚拟DOM树转换为真实DOM，插入到DOM树中。</li></ol></li><li><strong>比较子节点</strong>： <ol><li>对于每对相同位置的子节点，递归地应用Diff算法，比较它们的差异。</li><li>Vue.js会使用一种叫做&quot;<strong>双端比较</strong>&quot;的策略，同时从新旧虚拟DOM树的头部和尾部开始比较子节点，以尽可能地复用已有的DOM节点。</li></ol></li><li>递归处理子节点： <ol><li>继续递归地应用Diff算法，比较每对相同位置的子节点的差异。</li><li>在比较子节点的过程中，Vue.js会使用一些优化策略，例如为每个子节点添加唯一的key属性，以便更精确地定位和复用已有的DOM节点。</li></ol></li><li>完成Diff过程：当所有子节点都比较完成后，Diff算法就完成了。</li></ol><h2 id="双端比较" tabindex="-1">双端比较： <a class="header-anchor" href="#双端比较" aria-label="Permalink to &quot;双端比较：&quot;">​</a></h2><p>四个指针：</p><ul><li>使用旧列表的头一个节点oldStartNode与新列表的头一个节点newStartNode对比</li><li>使用旧列表的最后一个节点oldEndNode与新列表的最后一个节点newEndNode对比</li><li>使用旧列表的头一个节点oldStartNode与新列表的最后一个节点newEndNode对比</li><li>使用旧列表的最后一个节点oldEndNode与新列表的头一个节点newStartNode对比</li></ul><p>移动：对比一致则<code>指针向后或者向前移动</code>，<code>如果头头比较一致则节点不移动，如果头尾比较一致则节点移动</code></p><ul><li>当旧列表的头一个节点oldStartNode与新列表的头一个节点newStartNode对比时key相同。那么旧列表的头指针oldStartIndex与新列表的头指针newStartIndex同时向后移动一位。</li><li>当旧列表的最后一个节点oldEndNode与新列表的最后一个节点newEndNode对比时key相同。那么旧列表的尾指针oldEndIndex与新列表的尾指针newEndIndex同时向前移动一位。</li><li>当旧列表的头一个节点oldStartNode与新列表的最后一个节点newEndNode对比时key相同。那么旧列表的头指针oldStartIndex向后移动一位；新列表的尾指针newEndIndex向前移动一位。</li><li>当旧列表的最后一个节点oldEndNode与新列表的头一个节点newStartNode对比时key相同。那么旧列表的尾指针oldEndIndex向前移动一位；新列表的头指针newStartIndex向后移动一位。</li></ul><p>如果一开始没有找到相同的节点，则：</p><ul><li>在旧列表中找与新列表头一个节点相同的节点，找到则移到头部</li><li>如果找不到，则新增到头部</li></ul><h2 id="vue3-diff-——-最长递增子序列" tabindex="-1">Vue3 Diff —— 最长递增子序列 <a class="header-anchor" href="#vue3-diff-——-最长递增子序列" aria-label="Permalink to &quot;Vue3 Diff —— 最长递增子序列&quot;">​</a></h2><ol><li><p>前置与后置的预处理</p><ol><li>前置节点的处理是定义了一个<code>j</code>变量,分别指向新，老两个组子节点，比较指向的新，老节点是否相同，如果相同指针 +1,<code>直到两个节点不同时结束前置节点的处理</code></li><li>后置节点的处理是定义了索引<code>oldEnd</code>指向旧的一组子节点的最后一个节点和索引<code>newEnd</code>指向新的一组子节点的最后一个节点。然后比较两个指向的新旧节点，如果相同指向 -1，直到两个节点不同时结束后置节点的处理 处理新旧两个组子节点中相同的前置节点和后置节点。处理完后，如果剩余节点无法简单的通过挂载新节点或者卸载已经不存在的节点来完成更新，则需要根据节点的索引关系，构建出一个最长递增子序列。最长递增子序列所指向的节点即为不需要移动的节点。</li></ol></li><li><p>剩余节点的处理 当我们处理完相同的前置节点和后置节点后，如果还有剩余节点，就要对剩余节点进行处理，剩余节点分为3中情况，分别是：</p></li><li><p>只有新的一组的子节点有剩余</p><ol><li>当<code>oldEnd</code>遍历到头时，<code>newEnd</code>还没到头</li><li>当条件满足<code>j &gt; oldEnd</code> 且<code> j &lt;= newEnd</code>时，表示只有新的一组的子节点还有未处理的节点，我们需要循环 <code>j -&gt; newEnd</code>中的节点进行插入</li></ol></li><li><p>只有老的一组的子节点有剩余</p><ol><li>当<code>newEnd</code>遍历到头时，<code>oldEnd</code>还没到头</li><li>当条件满足<code>j &gt; newEnd</code> 且<code> j &lt;= oldEnd</code>时，表示只有旧的一组的子节点还有未处理的节点，我们需要循环 <code>j &gt; oldEnd </code>中的节点进行删除</li></ol></li><li><p>新老两组的子节点都有剩余</p></li></ol><h2 id="快速diff" tabindex="-1">快速diff <a class="header-anchor" href="#快速diff" aria-label="Permalink to &quot;快速diff&quot;">​</a></h2><p>新老两组的子节点都有剩余，该状态下主要核心为3个部分：</p><ol><li>构建source数组用于<code>存放新的一组子节点每个节点在老的一组中存在的原来位置</code>(索引) <ol><li>首先是定义一个长度为剩余新的一组子节点的长度的数组source，初始值都为-1，还定义了一个变量patched用于记录</li><li>然后遍历新的一组子节点，构建key与index的映射表，最后遍历老的一组节点，去映射表中寻找，k = keyIndex[oldVnode.key];，如果找到就把对应的索引存入到source对应的位置中，没有找到说明该节点多余，直接删除。</li><li>观察这个重新赋值后的source，我们可以看出，如果是全新的节点的话，其在source数组中对应的值就是初始的-1，通过这一步我们可以区分出来哪个为全新的节点，哪个是可复用的。</li></ol></li><li><code>判断是否需要移动节点</code>,如果是升序的则不需要移动</li><li><code>利用最长递增子序列来优化移动逻辑</code>，通过最长递增子序列获取到升序列表存放的是索引，然后从后遍历新的一组节点,节点的索引与升序列表对比，如果对比上了说明不需要移动，否则需要移动。</li></ol><h2 id="说说react-jsx转换成真实dom过程" tabindex="-1">说说React Jsx转换成真实DOM过程？ <a class="header-anchor" href="#说说react-jsx转换成真实dom过程" aria-label="Permalink to &quot;说说React Jsx转换成真实DOM过程？&quot;">​</a></h2><ul><li>所有的 JSX 代码最后都会<code>转换成React.createElement</code>(...) ，Babel帮助我们完成了这个转换的过程。</li><li>createElement函数对props进行处理，对默认props进行赋值，并且对传入的子节点进行处理，<code>最终构造成一个虚拟DOM对象</code></li><li><code>ReactDOM.render</code>将生成好的虚拟DOM渲染到指定容器上,<code>最终转换为真实DOM</code></li></ul>',23),a=[t];function n(c,r,f,s,u,h){return d(),l("div",null,a)}const x=e(i,[["render",n]]);export{E as __pageData,x as default};
