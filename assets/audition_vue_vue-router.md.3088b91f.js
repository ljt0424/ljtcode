import{_ as e,o as a,c as s,U as o}from"./chunks/framework.afdf1834.js";const D=JSON.parse('{"title":"vue-router","description":"","frontmatter":{},"headers":[],"relativePath":"audition/vue/vue-router.md","filePath":"audition/vue/vue-router.md","lastUpdated":null}'),l={name:"audition/vue/vue-router.md"},r=o(`<h1 id="vue-router" tabindex="-1">vue-router <a class="header-anchor" href="#vue-router" aria-label="Permalink to &quot;vue-router&quot;">​</a></h1><p><a href="https://router.vuejs.org/zh/introduction.html" target="_blank" rel="noreferrer">官方文档</a></p><h2 id="vue-router-1" tabindex="-1">vue-router <a class="header-anchor" href="#vue-router-1" aria-label="Permalink to &quot;vue-router&quot;">​</a></h2><h3 id="vue-router是什么-描述一下它的原理" tabindex="-1">vue-router是什么，描述一下它的原理？ <a class="header-anchor" href="#vue-router是什么-描述一下它的原理" aria-label="Permalink to &quot;vue-router是什么，描述一下它的原理？&quot;">​</a></h3><p>Vue Router是Vue官方的路由管理器，有hash和history两种模式</p><ol><li>hash模式是通过监听hashchange事件来实现更新页面部分内容的操作，url后面会带有#号</li><li>history模式则是通过监听popstate事件来实现更新页面部分内容的操作原理和hash模式差不多，只不过url后面不会出现#会显得更加美观。同时会带来一个问题，因为没有#号，所以当用户刷新页面时会向服务器发请求导致请求资源为404，因此需要对nginx进行一个配置，需要把所有路由都重定向到根页面。nginx.config的对应location里配置一行代码 try_files $uri $uri/ /index.html; 告诉nginx如果按顺序检查文件是否存在，若不存在则重定向到index.html文件</li></ol><h3 id="如何实现" tabindex="-1">如何实现 <a class="header-anchor" href="#如何实现" aria-label="Permalink to &quot;如何实现&quot;">​</a></h3><p>vue-router中有个监听器，用来监听History的变化（浏览器地址改变、点击前进后退按钮）。当监听到History变化之后，vue-router就会依据路由表当中声明了的路由对应匹配的组件，然后使用RouterView组件来对Vue Page的一个渲染（render）</p><h3 id="hash模式" tabindex="-1">hash模式 <a class="header-anchor" href="#hash模式" aria-label="Permalink to &quot;hash模式&quot;">​</a></h3><p>即url中的#以及后面部分，#相当于一个锚点，#后面的内容就是锚点值，当监听锚点值的变化就会改变局部的页面数据。当浏览器向服务器发送请求时，只会把#前面部分发送给服务器，一般前面部分的是不变的，所以hash 值变化不会导致浏览器向服务器发出请求。</p><ul><li>hash 模式是用 createWebHashHistory() 创建的</li><li>hash 改变会触发 onhashchange 事件。</li></ul><h3 id="history模式" tabindex="-1">history模式 <a class="header-anchor" href="#history模式" aria-label="Permalink to &quot;history模式&quot;">​</a></h3><p>HTML5 Mode是html5新增 history模式，所以也称为history 模式。history 模式改变 url 的方式会导致浏览器向服务器发送请求，但是history 模式可以传输复杂一些的数据，而且比hash模式美观（因为没有#）。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">window</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">addEventListener</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">popstate</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">()</span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">window</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">location</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">pathname</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span></code></pre></div><p>在你的服务器上添加一个简单的回退路由。如果 URL 不匹配任何静态资源，它应提供与你的应用程序中的 index.html 相同的页面。漂亮依旧!</p><h2 id="路由跳转方式有哪些" tabindex="-1">路由跳转方式有哪些？ <a class="header-anchor" href="#路由跳转方式有哪些" aria-label="Permalink to &quot;路由跳转方式有哪些？&quot;">​</a></h2><ol><li>内置组件跳转</li><li>router.push({ path: &#39;/home&#39; }),</li><li>router.replace({ path: &#39;/home&#39; })</li><li>router.go()</li><li>redirect() 在路由配置中使用</li></ol><h2 id="说一下路由守卫" tabindex="-1">说一下路由守卫？ <a class="header-anchor" href="#说一下路由守卫" aria-label="Permalink to &quot;说一下路由守卫？&quot;">​</a></h2><ul><li>为什么：如果需要用户登陆，我们来守卫页面，强制用户跳转到登录页面</li></ul><p>路由守卫分为全局路由守卫，路由独享守卫，组件路由守卫</p><ul><li>全局路由守卫 <ol><li>全局前置守卫beforeEach,接收to、from、next三个参数，每个<strong>路由跳转前都会触发</strong>，登录验证时用的比较多，当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫 resolve 完之前一直处于等待中。 <ol><li>to目标路由对象</li><li>from当前导航正要离开的路由对象</li><li>next函数</li></ol></li><li>全局解析守卫beforeResolve，和beforeEach类似，区别是在导航被确认之前，同时在所有组件内守卫和异步路由<strong>组件被解析之后调用</strong>，**守卫会在导航被确认之前被调用，**该守卫是在异步操作执行前执行，可以在异步操作执行完毕后，再跳转到目标路由。</li><li>全局后置钩子afterEach，在路由跳转完成后调用，接收to、from两个参数，不会接受 next 函数也不会改变导航本身，<strong>在每次路由跳转后执行</strong>，用于执行一些异步操作，比如向服务器发送数据、埋点等。</li></ol></li><li>路由独享守卫 <ol><li>beforeEnter,一般配置在路由配置文件中（router/index.js），对进入某个路由之前进行相关操作</li></ol></li><li>组件路由守卫 <ul><li>接收to、from、next三个参数</li></ul><ol><li>beforeRouteEnter,进入该组件之前调用，无法获取到vue实例。因为没有this，<code>所以支持给 next 传递回调,在导航确认后被调用</code>，通常用于在组件实例化之<strong>前获取数据或执行其他异步操作</strong>，当异步操作完成后，通过调用next函数来确认导航。</li><li>beforeRouteUpdate，在当前路由改变，但是该组件被复用时调用,因为在这种情况发生的时候，组件已经挂载好了，导航守卫可以访问组件实例 <code>this</code>,所以它不会在组件的初始加载时被触发。</li><li>beforeRouteLeave, 在离开当前组件时调用,与 <code>beforeRouteUpdate</code> 一样，它可以访问组件实例 <code>this</code></li></ol></li></ul><h2 id="完整的导航解析流程" tabindex="-1">完整的导航解析流程 <a class="header-anchor" href="#完整的导航解析流程" aria-label="Permalink to &quot;完整的导航解析流程&quot;">​</a></h2><ol><li>导航被触发。</li><li>在失活的组件里调用 beforeRouteLeave 守卫。</li><li>调用全局的 beforeEach 守卫。</li><li>在渲染该组件的路由被确认前访问组件实例 beforeRouteEnter。</li><li>在路由配置里调用 beforeEnter。</li><li>解析异步路由组件。</li><li>在重用的组件里调用 beforeRouteUpdate 守卫(2.2+)。</li><li>调用全局的 beforeResolve 守卫(2.5+)。</li><li>导航被确认。</li><li>调用全局的 afterEach 钩子。</li><li>触发 DOM 更新。</li><li>调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。</li></ol><ul><li>导航被触发 --&gt; 失活的组件beforeRouteLeave --&gt; beforeEach --&gt;beforeroutEenter --&gt;beforeEnter --&gt; 解析异步路由组件 --&gt; 复用的组件beforeRouteUpdate(不会在组件的初始加载时被触发) --&gt; 组件解析后beforeResolve --&gt; 导航确认 --&gt;afterEach --&gt; DOM更新 --&gt; beforeRouteEnter 守卫中传给 next 的回调函数</li></ul><h2 id="懒加载" tabindex="-1">懒加载 <a class="header-anchor" href="#懒加载" aria-label="Permalink to &quot;懒加载&quot;">​</a></h2><p>为给客户更好的客户体验，首屏组件加载速度更快一些，解决白屏问题，懒加载简单来说就是延迟加载或按需加载，即在需要的时候的时候进行加载。 也就是，组件现在路由里注册但不进行组件的加载与执行，等到需要访问组件的时候才进行真正的加载。</p><h3 id="懒加载实现" tabindex="-1">懒加载实现 <a class="header-anchor" href="#懒加载实现" aria-label="Permalink to &quot;懒加载实现&quot;">​</a></h3><ol><li>懒加载实现的前提：ES6的动态加载模块 - import（），调用import（）之处，被作为分离的模块起点，意思是，被请求的模块和它引用的所有子模块，会分离到一个单独的 chunk 中。</li></ol><h3 id="vue-router路由懒加载的方式" tabindex="-1">Vue-router路由懒加载的方式 <a class="header-anchor" href="#vue-router路由懒加载的方式" aria-label="Permalink to &quot;Vue-router路由懒加载的方式&quot;">​</a></h3><ol><li>vue-router配置路由，使用vue的异步组件技术，可以实现懒加载，此时一个组件会生成一个js文件。</li><li><code>component: resolve =&gt; require([&#39;放入需要加载的路由地址&#39;], resolve)</code></li></ol><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// vuerouterconfig,webpack写法</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 将import UserDetails from &#39;./views/UserDetails.vue&#39;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 替换成</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> UserDetails </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">import</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./views/UserDetails.vue</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> router </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">createRouter</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// ...</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">routes</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> [</span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">path</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">/users/:id</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">component</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> UserDetails </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">]</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span></code></pre></div><h2 id="路由元信息" tabindex="-1">路由元信息 <a class="header-anchor" href="#路由元信息" aria-label="Permalink to &quot;路由元信息&quot;">​</a></h2><p>将任意信息附加到路由上，如过渡名称、谁可以访问路由等。这些事情可以通过接收属性对象的meta属性来实现，并且它可以在路由地址和导航守卫上都被访问到。</p><h2 id="数据获取" tabindex="-1">数据获取 <a class="header-anchor" href="#数据获取" aria-label="Permalink to &quot;数据获取&quot;">​</a></h2><p>有时候，进入某个路由后，需要从服务器获取数据。例如，在渲染用户信息时，你需要从服务器获取用户的数据。我们可以通过两种方式来实现：</p><ol><li><strong>导航完成之后获取</strong>：先完成导航，然后在接下来的<strong>组件生命周期钩子中获取数据</strong>。在数据获取期间显示“加载中”之类的指示。</li><li><strong>导航完成之前获取</strong>：导航完成前，<strong>在路由进入的守卫中获取数据</strong>，在数据获取成功后执行导航。</li></ol><h2 id="vue路由的传参方式" tabindex="-1">vue路由的传参方式 <a class="header-anchor" href="#vue路由的传参方式" aria-label="Permalink to &quot;vue路由的传参方式&quot;">​</a></h2><ol><li>动态路由参数：可以在路由定义中使用冒号（:）来定义动态的路由参数。</li><li>查询参数：查询参数是通过 URL 的查询字符串传递的键值对</li><li>路由对象参数：可以通过在编程式导航中传递query一个包含参数的路由对象来传递参数。</li><li>命名路由参数：可以在路由定义中使用命名的路由参数。例如</li></ol><h2 id="params和query" tabindex="-1">params和query <a class="header-anchor" href="#params和query" aria-label="Permalink to &quot;params和query&quot;">​</a></h2><p>params：</p><p>动态路由参数,<strong>传递方式</strong>：params 是通过路由的路径进行传递的，参数直接嵌入在路由路径中。在路由组件中可以通过 $route.params 来获取传递的参数。</p><p>query：</p><p>查询参数,传递方式：query 是通过 URL 的查询字符串进行传递的，参数以键值对的形式出现在 URL 中的查询字符串中。在路由组件中可以通过 $route.query 来获取传递的参数。</p><ul><li>params 是通过路由的路径进行传递，query 是通过 URL 的查询字符串进行传递。</li><li>params 适用于标识资源的唯一性，query 适用于传递可选参数。</li><li>params 的参数在路径中可见，对于敏感信息或较长的参数可能不太适合，而 query 的参数不会在路径中显示</li></ul>`,44),t=[r];function n(i,p,c,u,h,y){return a(),s("div",null,t)}const F=e(l,[["render",n]]);export{D as __pageData,F as default};
