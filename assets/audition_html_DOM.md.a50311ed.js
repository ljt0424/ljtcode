import{_ as e,o as l,c as i,U as a}from"./chunks/framework.afdf1834.js";const t="/ljtui2/dom树.webp",D=JSON.parse('{"title":"DOM","description":"","frontmatter":{},"headers":[],"relativePath":"audition/html/DOM.md","filePath":"audition/html/DOM.md","lastUpdated":null}'),o={name:"audition/html/DOM.md"},r=a('<h1 id="dom" tabindex="-1">DOM <a class="header-anchor" href="#dom" aria-label="Permalink to &quot;DOM&quot;">​</a></h1><h2 id="什么是dom-文档对象模型" tabindex="-1">什么是DOM，文档对象模型 <a class="header-anchor" href="#什么是dom-文档对象模型" aria-label="Permalink to &quot;什么是DOM，文档对象模型&quot;">​</a></h2><p>从网络传给渲染引擎的 HTML 文件字节流是无法直接被渲染引擎理解的，所以要将其转化 为渲染引擎能够理解的内部结构，这个结构就是 DOM。DOM 提供了对 HTML 文档结构 化的表述。 <img src="'+t+'" alt="dom树"> DOM 是表述 HTML 的内部数据结构，它会将Web页面和JavaScript脚本连接起来</p><h2 id="dom-树如何生成" tabindex="-1">DOM 树如何生成 <a class="header-anchor" href="#dom-树如何生成" aria-label="Permalink to &quot;DOM 树如何生成&quot;">​</a></h2><p>渲染引擎内部，有一个叫HTML 解析器（HTMLParser）的模块，它的职责就是负责将HTML 字节流转换为 DOM 结构。HTML 解析器并不是等整个文档加载完成之后再解析的，而是网络进程加载了多少数据，HTML 解析器便解析多少数据。</p><p>网络进程接收到响应头之后，会根据请求头中的 content-type字段来判断文件的类型，比如 content-type 的值是“text/html”，那么浏览器就会判断这是一个 HTML 类型的文件，然后为该请求选择或者创建一个渲染进程。渲染进程准备好之后，网络进程和渲染进程之间会建立一个共享数据的管道，网络进程接收到数据后就往这个管道里面放，而渲染进程则从管道的另外一端不断地读取数据，并同时将读取的数据“喂”给 HTML 解析器。你可以把这个管道想象成一个“水管”，网络进程接收到的字节流像水一样倒进这个“水管”，而“水管”的另外一端是渲染进程的 HTML 解析器，它会动态接收字节流，并将其解析为 DOM。</p><p>字节流转换为 DOM 需要三个阶段</p><ol><li><p>通过分词器将字节流转换为 Token</p><ul><li>V8 编译 JavaScript 过程中的第一步是做词法分析，将 JavaScript 先分解为一个个 Token。解析 HTML 也是一样的，需要通过分词器先将字节流转换为一个个 Token，分为 <strong>Tag Token 和文本 Token</strong>。上述 HTML 代码通过词法分析生成的 Token 如下所示：</li><li><strong>HTML 解析器(HTMLParser)维护了一个Token 栈结构</strong>，该 Token 栈主要用来计算节点之间的父子关系，在第一个阶段中生成的 Token 会被按照顺序压到这个栈中。</li><li>通过分词器产生的新 Token 就这样不停地压栈和出栈，整个解析过程就这样一直持续下去，直到分词器将所有字节流分词完成。</li></ul></li><li><p>Token 解析为 DOM 节点</p></li><li><p>并将DOM 节点添加到 DOM 树中。</p></li></ol><ul><li>HTML 解析器开始工作时，<strong>会默认创建了一个根为 document 的空 DOM 结构</strong>，同时会将一个 StartTag document 的 Token 压入栈底。然后经过分词器解析出来的第一个 StartTag html Token 会被压入到栈中，并创建一个 html 的 DOM 节点，添加到 document 上</li></ul><h2 id="javascript和css会不会影响dom树构建和渲染" tabindex="-1">JavaScript和css会不会影响DOM树构建和渲染 <a class="header-anchor" href="#javascript和css会不会影响dom树构建和渲染" aria-label="Permalink to &quot;JavaScript和css会不会影响DOM树构建和渲染&quot;">​</a></h2><ol><li><code>CSS不会阻塞DOM树的解析，但是会阻塞DOM树的渲染，阻塞后面js语句的执行</code></li><li>JavaScript 会阻止DOM树的解析</li><li>最终CSS（CSSOM）会影响DOM树的渲染，也可以说最终会影响渲染树的生成</li></ol><h2 id="javascript对dom树构建和渲染的影响" tabindex="-1">JavaScript对DOM树构建和渲染的影响 <a class="header-anchor" href="#javascript对dom树构建和渲染的影响" aria-label="Permalink to &quot;JavaScript对DOM树构建和渲染的影响&quot;">​</a></h2><ol><li>执行到 JavaScript 标签时，暂停整个 DOM 的解析，执行 JavaScript 代码，如果要下载JavaScript代码，下载过程会阻塞DOM 解析</li><li>Chrome 浏览器预解析操作，当渲染引擎收到字节流之后，会开启一个预解析线程，用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，解析到相关文件之后，预解析线程会提前下载这些文件。</li></ol><h2 id="规避javascript线程阻塞dom现象" tabindex="-1">规避JavaScript线程阻塞DOM现象 <a class="header-anchor" href="#规避javascript线程阻塞dom现象" aria-label="Permalink to &quot;规避JavaScript线程阻塞DOM现象&quot;">​</a></h2><p>JavaScript 脚本设置为异步加载，通过 async 或 defer 来标记代码</p><h2 id="domcontentloaded" tabindex="-1">DOMContentLoaded <a class="header-anchor" href="#domcontentloaded" aria-label="Permalink to &quot;DOMContentLoaded&quot;">​</a></h2><ol><li>文档解析完毕DOM树构建完成，触发 DOMContentLoaded 事件。</li><li>html所有资源都加载完毕之后，load 事件触发。</li></ol><h2 id="dom文档加载的步骤为" tabindex="-1">DOM文档加载的步骤为： <a class="header-anchor" href="#dom文档加载的步骤为" aria-label="Permalink to &quot;DOM文档加载的步骤为：&quot;">​</a></h2><ol><li>解析HTML结构。</li><li>加载外部脚本和样式表文件。</li><li>解析并执行脚本代码。</li><li>DOM树构建完成。//DOMContentLoaded</li><li>加载图片等外部文件。</li><li>页面加载完毕。//load</li></ol><h2 id="网页的渲染" tabindex="-1">网页的渲染 <a class="header-anchor" href="#网页的渲染" aria-label="Permalink to &quot;网页的渲染&quot;">​</a></h2><p>DOM文档的加载顺序是由上而下的顺序加载：</p><ol><li>下载html，内联css使浏览器在下载完html后就能立刻渲染</li><li>在解析html到link标签（css）外部 CSS 文件的下载是<code>异步的</code>，即浏览器会继续加载后续内容而不必等待 CSS 文件加载完成，下载完成，浏览器会开始解析CSS文件</li><li>DOM加载到script标签(js) js文件不会与DOM并行加载，因此需要等待js整个文件加载完之后（如果script标签引用了外部脚本，就下载该脚本，否则就直接执行）才能继续DOM的加载 <ol><li>外链的js如果含有defer=&quot;true&quot;属性，将会并行加载js，到页面全部加载完成后才会执行，会按顺序执行。</li><li>外链的js如果含有async=&quot;true&quot;属性，将不会依赖于任何js和css的执行，此js下载完成后立刻执行，不会修改dom和样式的js，故不必依赖其它的js和css。</li></ol></li><li>html转换为dom，css转换为cssom</li><li>将DOM和CSSOM合并成一棵渲染render树</li><li>对渲染树进行reflow(回流，重排)，计算元素位置</li><li>绘制网页repaint(重绘)</li><li>根据浏览器提供各层的信息<a href="/ljtui2/audition/html/html.html#_12-合成层">合成图层</a>，显示到屏幕上</li></ol><h3 id="dom树的构建是文档加载完成开始的" tabindex="-1">DOM树的构建是文档加载完成开始的？ <a class="header-anchor" href="#dom树的构建是文档加载完成开始的" aria-label="Permalink to &quot;DOM树的构建是文档加载完成开始的？&quot;">​</a></h3><p>构建 DOM 树是一个渐进过程，为达到更好的用户体验，渲染引擎会尽快将内容显示在屏幕上，它不必等到整个 HTML 文档解析完成之后才开始构建 render 树和布局。</p><h3 id="render-树是-dom-树和-css-样式表构建完毕后才开始构建的" tabindex="-1">Render 树是 DOM 树和 CSS 样式表构建完毕后才开始构建的？ <a class="header-anchor" href="#render-树是-dom-树和-css-样式表构建完毕后才开始构建的" aria-label="Permalink to &quot;Render 树是 DOM 树和 CSS 样式表构建完毕后才开始构建的？&quot;">​</a></h3><p>这三个过程在实际进行的时候并不是完全独立的，而是会有交叉，会一边加载，一边解析，以及一边渲染。</p><h3 id="css-的解析注意点" tabindex="-1">CSS 的解析注意点？ <a class="header-anchor" href="#css-的解析注意点" aria-label="Permalink to &quot;CSS 的解析注意点？&quot;">​</a></h3><p>CSS 的解析是从右往左逆向解析的，嵌套标签越多，解析越慢。</p><h3 id="js-操作真实-dom-的代价" tabindex="-1">JS 操作真实 DOM 的代价？ <a class="header-anchor" href="#js-操作真实-dom-的代价" aria-label="Permalink to &quot;JS 操作真实 DOM 的代价？&quot;">​</a></h3><p>原生 JS 或 JQ 操作 DOM 时，浏览器会从构建 DOM 树开始从头到尾执行一遍流程，需要更新 10 个 DOM 节点就要从头到尾执行10遍</p><h2 id="virtual-dom-就是一个js对象模拟的dom树" tabindex="-1">Virtual-DOM 就是一个JS对象模拟的DOM树 <a class="header-anchor" href="#virtual-dom-就是一个js对象模拟的dom树" aria-label="Permalink to &quot;Virtual-DOM 就是一个JS对象模拟的DOM树&quot;">​</a></h2><p><a href="https://juejin.cn/post/6844903895467032589" target="_blank" rel="noreferrer">参考这篇</a></p><p>虚拟 DOM 就是为了解决浏览器性能问题而被设计出来的。如前，若一次操作中有 10 次更新 DOM 的动作，虚拟 DOM 不会立即操作 DOM，而是将这 10 次更新的 diff 内容保存到本地一个 JS 对象中，最终将这个 JS 对象一次性 attch 到 DOM 树上，再进行后续操作，避免大量无谓的计算量。所以，用 JS 对象模拟 DOM 节点的好处是，页面的更新可以先全部反映在 JS 对象(虚拟 DOM )上，操作内存中的 JS 对象的速度显然要更快，等更新完成后，再将最终的 JS 对象映射成真实的 DOM，交由浏览器去绘制。</p><h3 id="virtual-dom的实现" tabindex="-1">Virtual-DOM的实现 <a class="header-anchor" href="#virtual-dom的实现" aria-label="Permalink to &quot;Virtual-DOM的实现&quot;">​</a></h3><ol><li>用 JS 对象模拟 DOM 树</li><li>diff算法比较两棵虚拟 DOM 树的差异</li><li>将两个虚拟 DOM 对象的差异应用到真正的 DOM 树</li></ol><h2 id="vue的virtual-dom" tabindex="-1">vue的Virtual-DOM <a class="header-anchor" href="#vue的virtual-dom" aria-label="Permalink to &quot;vue的Virtual-DOM&quot;">​</a></h2><h3 id="vnode-模拟-dom-树" tabindex="-1">VNode 模拟 DOM 树 <a class="header-anchor" href="#vnode-模拟-dom-树" aria-label="Permalink to &quot;VNode 模拟 DOM 树&quot;">​</a></h3><p>利用 _createElement 方法创建 VNode，它定义在 src/core/vdom/create-elemenet.js 中</p><h2 id="dom常用接口" tabindex="-1">DOM常用接口 <a class="header-anchor" href="#dom常用接口" aria-label="Permalink to &quot;DOM常用接口&quot;">​</a></h2><ol><li>Document: 表示整个文档，提供了操作和访问文档的方法和属性。</li><li>Element: 表示一个元素节点，提供了操作和访问元素的方法和属性。</li><li>Node: 表示文档中的一个节点，可以是元素节点、文本节点、注释节点等，提供了节点的基本方法和属性。</li><li>Event: 表示事件对象，包含了与事件相关的信息和方法。</li><li>Window: 表示浏览器窗口，提供了操作和访问浏览器窗口的方法和属性。</li><li>Location: 表示当前页面的 URL 信息，提供了操作和访问 URL 的方法和属性。</li><li>XMLHttpRequest: 表示 AJAX 请求对象，用于发送异步 HTTP 请求。</li></ol><h2 id="document" tabindex="-1">Document <a class="header-anchor" href="#document" aria-label="Permalink to &quot;Document&quot;">​</a></h2><ul><li>getElementById(id): 根据元素的 id 属性获取对应的元素节点。</li><li>querySelector(selector): 根据 CSS 选择器选择匹配的第一个元素节点。</li><li>querySelectorAll(selector): 根据 CSS 选择器选择匹配的所有元素节点。</li><li>createElement(tagName): 创建一个指定标签名的元素节点。</li><li>createTextNode(text): 创建一个包含指定文本内容的文本节点。</li><li>appendChild(child): 将一个节点添加为当前节点的子节点。</li><li>removeChild(child): 从当前节点中移除指定的子节点。</li><li>addEventListener(type, listener): 注册事件监听器，当指定类型的事件触发时执行相应的回调函数。</li><li>removeEventListener(type, listener): 移除事件监听器。</li><li>open(): 打开一个新的空白文档。</li><li>close(): 关闭当前文档。</li></ul><h3 id="常用属性" tabindex="-1">常用属性： <a class="header-anchor" href="#常用属性" aria-label="Permalink to &quot;常用属性：&quot;">​</a></h3><ul><li>documentElement: 返回文档的根元素节点（通常是 <code>&lt;html&gt;</code>）。</li><li>head: 返回文档的头部元素节点（通常是 <code>&lt;head&gt;</code>）。</li><li>body: 返回文档的主体元素节点（通常是 <code>&lt;body&gt;</code>）。</li><li>title: 获取或设置文档的标题。</li><li>URL: 返回当前文档的完整 URL。</li><li>cookie: 获取或设置文档的 cookie。</li></ul><h2 id="element" tabindex="-1">Element <a class="header-anchor" href="#element" aria-label="Permalink to &quot;Element&quot;">​</a></h2><ul><li>getAttribute(name): 获取指定属性名对应的属性值。</li><li>setAttribute(name, value): 设置指定属性名的属性值。</li><li>hasAttribute(name): 检查是否存在指定属性名的属性。</li><li>removeAttribute(name): 移除指定属性名的属性。</li></ul><h2 id="dom元素对象属性" tabindex="-1">DOM元素对象属性 <a class="header-anchor" href="#dom元素对象属性" aria-label="Permalink to &quot;DOM元素对象属性&quot;">​</a></h2><p>DOM元素对象（Element）具有许多属性，用于访问和操作元素的不同方面。下面列举一些常见的属性：</p><ul><li>classList：返回一个DOMTokenList对象，包含了元素的类名（class）列表，可以用于添加、删除和切换类名。</li><li>id：获取或设置元素的唯一标识符（ID）。</li><li>tagName：获取元素的标签名，以大写形式表示。</li><li><strong>innerHTML</strong>：获取或设置元素的HTML内容。</li><li>textContent：获取或设置元素的纯文本内容。</li><li>value：用于表单元素，获取或设置输入框、文本区域等的值。</li><li>style：返回一个CSSStyleDeclaration对象，用于访问和修改元素的样式属性。</li><li>dataset：返回一个DOMStringMap对象，包含了元素的自定义数据属性（data-*）。</li><li><strong>offsetParent</strong>：获取元素的最近的定位（positioned）祖先元素。</li><li>offsetTop：获取元素相对于offsetParent元素的上边距的距离。</li><li>offsetLeft：获取元素相对于offsetParent元素的左边距的距离。</li><li><strong>offsetWidth</strong>：获取元素的可见宽度，包括内容区域、内边距和边框。</li><li>offsetHeight：获取元素的可见高度，包括内容区域、内边距和边框。</li><li><strong>clientWidth</strong>：获取元素的内部宽度，包括内容区域和内边距，不包括滚动条、边框和外边距。</li><li>clientHeight：获取元素的内部高度，包括内容区域和内边距，不包括滚动条、边框和外边距。</li><li><strong>scrollWidth</strong>：获取元素内容的总宽度，包括被隐藏的部分（如果有）。</li><li>scrollHeight：获取元素内容的总高度，包括被隐藏的部分（如果有）。</li><li><strong>scrollLeft</strong>：获取或设置元素内容在水平方向上滚动的像素数。</li><li>scrollTop：获取或设置元素内容在垂直方向上滚动的像素数。</li><li><strong>parentElement</strong>：获取元素的父元素。</li><li>children：返回一个HTMLCollection对象，包含了元素的子元素。</li><li><strong>previousElementSibling</strong>：获取元素的前一个兄弟元素。</li><li><strong>nextElementSibling</strong>：获取元素的后一个兄弟元素。</li></ul><h2 id="dom常见的操作有哪些" tabindex="-1">DOM常见的操作有哪些 <a class="header-anchor" href="#dom常见的操作有哪些" aria-label="Permalink to &quot;DOM常见的操作有哪些&quot;">​</a></h2><ul><li>createElement，创建新元素</li><li>createTextNode，创建一个文本节点</li><li>createAttribute，创建属性节点，可以是自定义属性，setAttribute</li><li>querySelector，querySelectorAll</li><li>innerHTML，innerText、textContent</li><li>appendChild，removeChild</li></ul><h2 id="window" tabindex="-1">window <a class="header-anchor" href="#window" aria-label="Permalink to &quot;window&quot;">​</a></h2><p>Window 对象是浏览器中的顶级对象，提供了许多常用的方法和属性。以下是一些常见的 Window 方法和属性：</p><h3 id="常用方法" tabindex="-1">常用方法： <a class="header-anchor" href="#常用方法" aria-label="Permalink to &quot;常用方法：&quot;">​</a></h3><ul><li><strong>alert</strong>(message): 显示一个带有消息和确定按钮的对话框。</li><li><strong>confirm</strong>(message): 显示一个带有消息、确定和取消按钮的对话框，并返回用户的选择结果。</li><li><strong>prompt</strong>(message, defaultValue): 显示一个带有消息、文本输入框、确定和取消按钮的对话框，并返回用户输入的值。</li><li>setTimeout(function, delay): 在指定的延迟时间后执行一次指定的函数。</li><li>setInterval(function, delay): 每隔指定的时间间隔执行一次指定的函数。</li><li>clearTimeout(timeoutID): 取消由 setTimeout 方法设置的定时器。</li><li>clearInterval(intervalID): 取消由 setInterval 方法设置的定时器。</li><li>open(url, target): 打开一个新窗口或标签页，并加载指定的 URL。</li><li>close(): 关闭当前窗口或标签页。</li></ul><h3 id="常用属性-1" tabindex="-1">常用属性： <a class="header-anchor" href="#常用属性-1" aria-label="Permalink to &quot;常用属性：&quot;">​</a></h3><ul><li>document: 获取当前窗口的 Document 对象，用于访问和操作文档的内容。</li><li>location: 获取或设置当前窗口的 URL 地址信息。</li><li>navigator: 获取关于浏览器的信息，如浏览器名称、版本等。</li><li>innerWidth: 获取当前窗口的视口宽度。</li><li>innerHeight: 获取当前窗口的视口高度。</li><li>screen: 获取关于用户屏幕的信息，如屏幕宽度、高度等。</li><li>localStorage: 提供了对本地存储的访问，可以存储和读取数据。</li><li>sessionStorage: 提供了对会话存储的访问，可以在会话期间存储和读取数据。</li></ul><h2 id="event" tabindex="-1">Event <a class="header-anchor" href="#event" aria-label="Permalink to &quot;Event&quot;">​</a></h2><p>Event 是 JavaScript 中处理事件的基本对象。它代表了在 DOM 中发生的特定事件，可以包含有关事件的信息和方法。Event 对象的属性和方法可以用于事件处理、事件传播和事件信息的获取。</p><h3 id="常用属性-2" tabindex="-1">常用属性： <a class="header-anchor" href="#常用属性-2" aria-label="Permalink to &quot;常用属性：&quot;">​</a></h3><ul><li>type：事件的类型，如 &quot;click&quot;、&quot;keydown&quot; 等。</li><li>target：触发事件的元素。</li><li>currentTarget：当前正在处理事件的元素。</li><li>eventPhase：事件的当前阶段，可以是捕获阶段 (Event.CAPTURING_PHASE)、目标阶段 (Event.AT_TARGET) 或冒泡阶段 (Event.BUBBLING_PHASE)。</li><li>bubbles：指示事件是否会冒泡的布尔值。</li><li>cancelable：指示事件是否可以取消的布尔值。</li><li>defaultPrevented：指示事件的默认行为是否被取消的布尔值。</li><li>timeStamp：事件触发的时间戳。</li></ul><h3 id="常用方法-1" tabindex="-1">常用方法： <a class="header-anchor" href="#常用方法-1" aria-label="Permalink to &quot;常用方法：&quot;">​</a></h3><ul><li>preventDefault()：取消事件的默认行为。</li><li>stopPropagation()：停止事件的传播，阻止事件进一步冒泡或捕获。</li><li>stopImmediatePropagation()：立即停止事件的传播，并阻止事件进一步冒泡或捕获，同时阻止调用其他的事件处理函数。</li><li>initEvent(type, bubbles, cancelable)：初始化事件对象，设置事件的类型、冒泡和取消属性。</li></ul>',63),n=[r];function d(s,c,h,u,m,M){return l(),i("div",null,n)}const O=e(o,[["render",d]]);export{D as __pageData,O as default};
