import{_ as e,o,c as t,k as s,a,t as p,U as l}from"./chunks/framework.afdf1834.js";const c="/ljtui2/渲染.png",r="/ljtui2/更新.png",i="/ljtui2/销毁.png",b=JSON.parse('{"title":"vue","description":"","frontmatter":{},"headers":[],"relativePath":"audition/vue/vue.md","filePath":"audition/vue/vue.md","lastUpdated":null}'),D={name:"audition/vue/vue.md"},y=l('<h1 id="vue" tabindex="-1">vue <a class="header-anchor" href="#vue" aria-label="Permalink to &quot;vue&quot;">​</a></h1><h2 id="对vue的理解" tabindex="-1">对vue的理解 <a class="header-anchor" href="#对vue的理解" aria-label="Permalink to &quot;对vue的理解&quot;">​</a></h2><ol><li>他是一个流行的前端框架</li><li>提供组件化开发</li><li>响应式数据绑定</li><li>指令和插值表达式</li><li>路由</li><li>状态管理</li><li>过渡和动画：Vue支持在组件间添加过渡效果和动画</li></ol><h2 id="单页面应用" tabindex="-1">单页面应用 <a class="header-anchor" href="#单页面应用" aria-label="Permalink to &quot;单页面应用&quot;">​</a></h2><p>单页应用(SPA - single page application)</p><ul><li>只在第一次加载页面时，返回唯一的html页面和它的公共静态资源，后续的页面跳转都不会从服务端拿html文件。（hash和history路由实现浏览器url变化而不刷新页面）</li></ul><h2 id="vue生命周期" tabindex="-1">vue生命周期 <a class="header-anchor" href="#vue生命周期" aria-label="Permalink to &quot;vue生命周期&quot;">​</a></h2><table><thead><tr><th style="text-align:left;">Vue2(选项式API)</th><th style="text-align:center;">Vue3(setup)</th><th style="text-align:center;">描述</th></tr></thead><tbody><tr><td style="text-align:left;">beforeCreate</td><td style="text-align:center;">setup</td><td style="text-align:center;">实例创建前</td></tr><tr><td style="text-align:left;">created</td><td style="text-align:center;">setup</td><td style="text-align:center;">实例创建后</td></tr><tr><td style="text-align:left;">beforeMount</td><td style="text-align:center;">onBeforeMount</td><td style="text-align:center;">DOM挂载前调用</td></tr><tr><td style="text-align:left;">mounted</td><td style="text-align:center;">onMounted</td><td style="text-align:center;">DOM挂载完成调用</td></tr><tr><td style="text-align:left;">beforeUpdate</td><td style="text-align:center;">onBeforeUpdate</td><td style="text-align:center;">数据更新之前被调用</td></tr><tr><td style="text-align:left;">updated</td><td style="text-align:center;">onUpdated</td><td style="text-align:center;">数据更新之后被调用</td></tr><tr><td style="text-align:left;">beforeDestroy</td><td style="text-align:center;">onBeforeUnmount</td><td style="text-align:center;">组件销毁前调用</td></tr><tr><td style="text-align:left;">destroyed</td><td style="text-align:center;">onUnmounted</td><td style="text-align:center;">组件销毁完成调用</td></tr></tbody></table><p>vue3也兼容vue2的选项式api，vue3使用选项式api生命周期和vue2一样。vue3的组合式api生命周期有所变化</p><h2 id="setup" tabindex="-1">setup <a class="header-anchor" href="#setup" aria-label="Permalink to &quot;setup&quot;">​</a></h2><p>setup函数是组件中的一个特殊函数，用于在组件实例创建之前进行一些初始化操作。你可以使用onBeforeMount和onMounted这两个函数来模拟beforeCreate和created的行为。 组合式api一般在setup中请求数据，setup执行时机在组件实例创建之前</p><h2 id="各自生命周期的事情" tabindex="-1">各自生命周期的事情 <a class="header-anchor" href="#各自生命周期的事情" aria-label="Permalink to &quot;各自生命周期的事情&quot;">​</a></h2><p>beforeCreate setup<br> created setup 常用于<code>数据请求、事件监听、定时器</code>开启等 beforeMount onBeforeMount 阶段准备数据或执行一些初始化操作，以确保在组件挂载到DOM之前，数据和组件状态已经准备就绪。<br> mounted onMounted dom挂载完成，可以<code>访问 dom 节点</code>进行<code>数据交互</code>。 beforeUpdate onBeforeUpdate 内存中的数据已经改变，页面上的还没更新。对组件的编辑次数，甚至跟踪创建撤销功能的操作很有用。 updated onUpdated 页面上数据和内存中的一致 beforeDestroy onBeforeUnmount 移除 <code>dom 事件监听</code>、<code>定时器</code>等。还没开始销毁，此时刚刚脱离运行阶段。data，methods，指令之类的都在正常运行。 destroyed onUnmounted 组件销毁完毕</p><h2 id="vue父子组件生命周期" tabindex="-1">vue父子组件生命周期 <a class="header-anchor" href="#vue父子组件生命周期" aria-label="Permalink to &quot;vue父子组件生命周期&quot;">​</a></h2><ol><li>渲染过程 父beforeCreate -&gt; 父created -&gt; 父beforeMount -&gt; 子beforeCreate -&gt; 子created -&gt; 子beforeMount -&gt; 子mounted -&gt; 父mounted <img src="'+c+'" alt="渲染"></li><li>更新过程 父beforeUpdate -&gt; 子beforeUpdate -&gt; 子updated -&gt; 父updated <img src="'+r+'" alt="更新"></li><li>销毁过程 父beforeDestroy -&gt; 子beforeDestroy -&gt; 子destroyed -&gt; 父destroyed <img src="'+i+`" alt="销毁"></li></ol><h3 id="注意" tabindex="-1">注意 <a class="header-anchor" href="#注意" aria-label="Permalink to &quot;注意&quot;">​</a></h3><p>如果子组件是异步组件的话它们的执行顺序会发生改变，会先执行完父组件的生命周期然后再执行子组件的生命周期</p><h2 id="v-if和v-show" tabindex="-1">v-if和v-show <a class="header-anchor" href="#v-if和v-show" aria-label="Permalink to &quot;v-if和v-show&quot;">​</a></h2><ol><li>v-if表示一个dom元素是否被创建，而v-show则是控制这个dom元素的display属性是否为none</li><li>一般在频繁切换状态的地方使用v-show,v-if则更适合条件不经常改变的场景，因为它切换开销相对较大</li></ol><h2 id="v-for和v-if优先级" tabindex="-1">v-for和v-if优先级 <a class="header-anchor" href="#v-for和v-if优先级" aria-label="Permalink to &quot;v-for和v-if优先级&quot;">​</a></h2><ol><li>开发过程中一般不建议同时将v-for和v-if放在一个标签中使用</li><li>Vue2中v-for的优先级会更高，所以会先执行循环，再进行v-if判断，所以这样就会导致无论需不需展示这个元素，都会先遍历整个列表</li><li>在Vue3中v-if的优先级会更高，但是当我们遍历一个数组的时候，根据数组中的某个元素进行v-if判断的时候就会报错，因为v-if会先执行此时还没有拿到这个数组。所以Vue3中依然不建议这样使用</li></ol><h2 id="说一下computed和watch" tabindex="-1">说一下computed和watch <a class="header-anchor" href="#说一下computed和watch" aria-label="Permalink to &quot;说一下computed和watch&quot;">​</a></h2><ol><li>computed是计算属性,当一个属性受一个或者多个属性影响的时候可以使用.watch是侦听器,当我们需要根据一个属性的变化而做出一些处理的时候,可以使用watch来对这个属性进行监听</li><li><strong>computed具有缓存的特点</strong>,即当它所依赖的属性发生改变的时候它才会重新执行内部逻辑.如下代码</li></ol><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;{{</span><span style="color:#A6ACCD;"> addSum </span><span style="color:#89DDFF;">}}&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;{{</span><span style="color:#A6ACCD;"> addSum </span><span style="color:#89DDFF;">}}&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;{{</span><span style="color:#A6ACCD;"> addSum </span><span style="color:#89DDFF;">}}&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">setup</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">import </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> computed</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> ref</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> watch </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> from &quot;vue&quot;;</span></span>
<span class="line"><span style="color:#A6ACCD;">const a = ref(1)</span></span>
<span class="line"><span style="color:#A6ACCD;">const b = ref(2)</span></span>
<span class="line"><span style="color:#A6ACCD;">let addSum = computed(() =&gt; </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">内部逻辑执行</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">    return a</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> b</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div><p>页面多次使用addSum,但是只会打印一次&quot;内部逻辑执行&quot;</p><ol start="3"><li>侦听器可以检测某个响应式数据的变化并执行副作用，常见用法是传递一个函数，执行副作用，watch没有返回值，但可以执行异步操作等复杂逻辑。（一般用来请求接口）</li><li>watch在页面首次加载的时候默认不会执行,需要设置immediate:true首次才会执行监听</li><li>watch默认只监听一层数据,不监听多层数据里属性的变化,需要设置deep:true才会进行深度监听</li></ol><h3 id="computed和methods的区别" tabindex="-1">computed和methods的区别？ <a class="header-anchor" href="#computed和methods的区别" aria-label="Permalink to &quot;computed和methods的区别？&quot;">​</a></h3><p>computed和methods的差异是它具备缓存性，如果依赖项不变时不会重新计算。</p><h3 id="computed为什么是同步的" tabindex="-1">computed为什么是同步的 <a class="header-anchor" href="#computed为什么是同步的" aria-label="Permalink to &quot;computed为什么是同步的&quot;">​</a></h3><p>computed属性可以<strong>依赖于其他响应式数据</strong>（例如data属性或其他computed属性）。Vue.js会自动追踪这些依赖关系，并在依赖发生变化时重新计算computed属性的值。由于<strong>依赖关系是同步跟踪的</strong>，所以computed属性的计算也是同步进行的，以确保数据的一致性。</p><h3 id="computed和watch的区别" tabindex="-1">computed和watch的区别？ <a class="header-anchor" href="#computed和watch的区别" aria-label="Permalink to &quot;computed和watch的区别？&quot;">​</a></h3><ol><li>computed计算属性不支持异步，watch用来进行异步操作 <ol><li>在计算属性中进行异步操作可能会导致<strong>无法正确地追踪依赖关系和触发更新</strong>。如果计算属性中使用异步操作，将<strong>无法准确确定何时重新计算属性的值</strong>。</li><li>watch选项是基于观察者模式实现的，它可以监听特定数据的变化，并在变化发生时触发回调函数。这使得它能够处理异步操作，例如发送网络请求、操作定时器等。</li></ol></li><li>computed有返回值，你可以在模板中像访问普通属性一样访问计算属性</li><li>watch没有返回值</li></ol><h3 id="computed和watch使用场景" tabindex="-1">computed和watch使用场景 <a class="header-anchor" href="#computed和watch使用场景" aria-label="Permalink to &quot;computed和watch使用场景&quot;">​</a></h3><ol><li>计算属性computed常用场景是<strong>简化在template模板中的复杂表达式</strong>，模板中出现太多逻辑判断会造成模板不易维护。</li><li>computed不支持异步</li><li>都是以 Vue 的依赖追踪机制为基础，当某个依赖数据发生变化时，所有依赖这个数据的相关数据或函数都会自动发生变化或调用。</li><li>侦听器Watch常用场景是状态变化之后做一些异步操作。</li><li>有异步请求的用Wach，其他情况能用计算属性就首选计算属性。</li></ol><h3 id="computed的原理" tabindex="-1">computed的原理 <a class="header-anchor" href="#computed的原理" aria-label="Permalink to &quot;computed的原理&quot;">​</a></h3><p>computed 的实现是基于 Watcher 实例对象(被观察者)的</p><h3 id="computed的两种定义方式" tabindex="-1">computed的两种定义方式 <a class="header-anchor" href="#computed的两种定义方式" aria-label="Permalink to &quot;computed的两种定义方式&quot;">​</a></h3><p>一种是方法，另一种是 get，set 属性。而且，其内部监听的对象必须是已经定义响应式的属性，比如 data 的属性、vuex 的属性。</p><h4 id="computed属性的初始化" tabindex="-1">computed属性的初始化 <a class="header-anchor" href="#computed属性的初始化" aria-label="Permalink to &quot;computed属性的初始化&quot;">​</a></h4><ol><li>vue 在创建 computed 属性时候，遍历computed属性，为每个computed属性都创建一个watcher,对每个computed属性进行get劫持</li><li>get劫持是最关键的步骤 <ol><li>将computed-watcher添加到data属性值的订阅者队列。（<strong>在前）</strong></li><li>将render-watcher添加到data属性值的订阅者队列。<strong>（在后）</strong></li></ol></li><li>这样就能实现，当data属性值变化后： <ol><li>render函数执行</li><li>computed属性函数执行并返回新执行结果</li></ol></li></ol><h2 id="computed-属性" tabindex="-1">computed 属性 <a class="header-anchor" href="#computed-属性" aria-label="Permalink to &quot;computed 属性&quot;">​</a></h2><p>vue 在创建 computed 属性时候，会循环所有计算属性，每一个计算属性会创建一个 watcher，(并且在通过 defineProperty(vue2),proxy(vue3) 定义监听)，在 get 中，计算属性工作是做依赖收集，在 set 中，计算属性重要工作是重新执行计算方法，这里需要多补充一句，因为 computed 是懒执行，也就是说第一次初始化之后，便不会执行计算，下一次变更执行重新计算是在 set 中。</p><h3 id="依赖收集的时机" tabindex="-1">依赖收集的时机 <a class="header-anchor" href="#依赖收集的时机" aria-label="Permalink to &quot;依赖收集的时机&quot;">​</a></h3><p>computed 收集时机和 data 一样，是在组件挂载前，但是其收集对象是自己属性对应的 watch，而 data 本身所有数据对应一个 watch。</p><h2 id="watch和watcheffect区别和用法" tabindex="-1">watch和watchEffect区别和用法 <a class="header-anchor" href="#watch和watcheffect区别和用法" aria-label="Permalink to &quot;watch和watchEffect区别和用法&quot;">​</a></h2><ol><li>watch 那样接收一个明确的数据源,watchEffect 也是一个监听器,它只接收一个回调函数。而在这个回调函数当中，它会自动监听响应数据，当回调函数里面的响应数据发生变化，回调函数就会立即执行。watchEffect只能看到新值看不到旧值。</li><li>watch 在响应数据初始化时是不会执行回调函数的，watchEffect 在响应数据初始化时就会立即执行回调函数。</li></ol><h2 id="vue2和vue3区别" tabindex="-1">vue2和vue3区别 <a class="header-anchor" href="#vue2和vue3区别" aria-label="Permalink to &quot;vue2和vue3区别&quot;">​</a></h2><ol><li>写法上的区别:vue2使用的是options(选项)Api,vue3的是composition Api(当然vue3也兼容composition api)。options Api中methods，compute，data等api都是分散的。而composition api中的代码是根据逻辑功能来组织的,我们可以将一个功能所定义的methods，compute，data等api会放在一起,让我们可以更灵活地组合组件逻辑。</li><li>vue2将响应式数据放到data函数中,而vue3则是使用ref和reactive将数据声明为响应式</li><li><a href="./vue响应式原理.html">响应式实现方式</a>:vue2中是通过Object.defineProperty对数据劫持实现的,vue3中则是使用Proxy对数据代理实现的。</li><li>生命周期区别:vue3中将beforeCreate和created合并到了setup函数中</li><li>根节点: vue3组件允许多个根节点,而vue2只允许一个</li><li>内置组件: vue3新增了传送组件Teleport和异步依赖处理组件Suspense</li></ol><h2 id="vue初始化阶段" tabindex="-1">VUE初始化阶段 <a class="header-anchor" href="#vue初始化阶段" aria-label="Permalink to &quot;VUE初始化阶段&quot;">​</a></h2><ul><li><code>解析 Vue 模板</code>：Vue 应用程序的入口是一个 HTML 模板，其中包含 Vue 的标识符和指令。在初始化阶段，Vue 会解析模板，识别其中的指令和数据绑定。</li><li><code>创建 Vue 实例</code>：Vue 会根据解析后的模板创建一个 Vue 实例，该实例充当应用程序的根实例，并管理整个应用程序的状态和行为。</li><li><code>数据响应式处理</code>：在初始化阶段，Vue 会将 data 中的数据转换为响应式数据，这意味着当数据发生变化时，相关的视图将自动更新。Vue 使用 Object.defineProperty 或 ES6 Proxy（如果支持）来实现数据响应式。</li><li><code>编译模板</code>：Vue 在初始化阶段将模板编译成渲染函数。渲染函数用于创建 Virtual DOM，并最终渲染成实际的 DOM。</li><li><code>创建 Virtual DOM</code>：Vue 在初始化阶段会创建 Virtual DOM（虚拟 DOM），它是一个轻量级的内存中表示真实 DOM 结构的 JavaScript 对象树。</li><li><code>挂载 Vue 实例</code>：在创建 Vue 实例后，可以选择手动挂载到一个特定的 DOM 元素上，或者使用 Vue 提供的 el 选项来自动挂载。一旦挂载完成，Vue 将开始监视数据变化，并将模板渲染为真实 DOM。</li><li><code>生命周期钩子函数</code>：在初始化阶段，Vue 会依次调用 Vue 实例的生命周期钩子函数，例如 beforeCreate、created、beforeMount 和 mounted。这些钩子函数允许开发者在不同的生命周期阶段执行一些逻辑。</li><li>注册全局和局部组件：在初始化阶段，可以注册全局组件或在需要时在特定的组件内注册局部组件，这样它们就可以在模板中使用了。</li></ul><h2 id="vue2-实现响应式的核心是通过「数据劫持」和「观察者模式」来实现的。" tabindex="-1">Vue2 实现响应式的核心是通过「数据劫持」和「观察者模式」来实现的。 <a class="header-anchor" href="#vue2-实现响应式的核心是通过「数据劫持」和「观察者模式」来实现的。" aria-label="Permalink to &quot;Vue2 实现响应式的核心是通过「数据劫持」和「观察者模式」来实现的。&quot;">​</a></h2><ul><li>数据劫持：Vue 使用 Object.defineProperty() 方法来劫持对象的属性，为其添加 getter 和 setter。当访问或修改这些属性时，Vue 可以捕捉到，并执行相应的逻辑。</li><li>观察者模式：Vue 中有一个 Watcher 观察者对象，它会订阅<strong>被劫持的属性</strong>的变化。当属性发生变化时，观察者对象会接收到通知，并触发相应的更新操作。</li></ul><h2 id="数组的改进" tabindex="-1">数组的改进 <a class="header-anchor" href="#数组的改进" aria-label="Permalink to &quot;数组的改进&quot;">​</a></h2><ol><li>响应式数组，vue3数组可以直接使用</li><li>reactive和readonly</li><li>watchEffect的数组侦听</li><li>v-for的key属性</li><li>Array.prototype方法的修改：Vue 3对一些数组方法进行了修改，使其更符合规范并提供更好的类型推导。例如，push、pop、shift、unshift、splice等方法的返回类型和参数类型都得到了改进。</li></ol><h2 id="vue插件使用" tabindex="-1">vue插件使用 <a class="header-anchor" href="#vue插件使用" aria-label="Permalink to &quot;vue插件使用&quot;">​</a></h2><p>将组件实例挂载到全局， vue实例会有一个use函数,它接受的是一个带有install函数的对象和一个可选的选项对象,当我们使用 vue.use(plugin)或者app.use(plugin)会调用我们插件的install属性的函数,并且将当前组件的实例传进来.所以在插件中就可以对这个实例进行一些操作来实现我们插件的功能</p><h2 id="vue插槽" tabindex="-1">vue插槽 <a class="header-anchor" href="#vue插槽" aria-label="Permalink to &quot;vue插槽&quot;">​</a></h2><p>插槽slot可以理解为占坑，当使用一个组件的时候，在组件标签里的对应的<strong>内容就会替换</strong>掉这个组件中的<strong>slot标签</strong>。</p><ul><li>插槽分为默认插槽，具名插槽，作用域插槽。</li><li>默认插槽 子组件中用slot标签来确定渲染位置，父组件使用它时直接在子组件的标签内写入内容即可</li></ul><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">//子组件</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">slot</span><span style="color:#89DDFF;"> /&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//父组件</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Child</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">默认插槽</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#FFCB6B;">Child</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div><ul><li>具名插槽顾名思义就是具有名字的插槽，子组件中可以用name熟悉对slot命名，父组件在使用的时候<strong>一定要通过template</strong>中的<strong>v-slot:name或者#name</strong>来定义这个插槽中的内容</li></ul><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">//子组件</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">slot</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">name</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">content</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">slot</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//父组件</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Child</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">v-slot</span><span style="color:#89DDFF;">:</span><span style="color:#C792EA;">content</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">具名插槽内容</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#FFCB6B;">Child</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div><ul><li>作用域插槽 在slot标签绑定属性从而传递给父组件中的插槽内容。首先来看下默认插槽的传值方式</li></ul><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">//子组件</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">slot</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">personName</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">xiaoyue</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">age</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">18</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">slot</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//父组件</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Child</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">v-slot</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">slotProps</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">      My name is </span><span style="color:#89DDFF;">{{</span><span style="color:#A6ACCD;"> slotProps.personName </span><span style="color:#89DDFF;">}}</span><span style="color:#A6ACCD;"> and I am </span><span style="color:#89DDFF;">{{</span><span style="color:#A6ACCD;"> slotProps.age </span><span style="color:#89DDFF;">}}</span><span style="color:#A6ACCD;"> years old this year</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#FFCB6B;">Child</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">setup</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">import Child from &#39;./Child.vue&#39;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div><h2 id="组件通信" tabindex="-1">组件通信 <a class="header-anchor" href="#组件通信" aria-label="Permalink to &quot;组件通信&quot;">​</a></h2><table><thead><tr><th style="text-align:left;">方式</th><th style="text-align:center;">Vue2</th><th style="text-align:center;">Vue3</th></tr></thead><tbody><tr><td style="text-align:left;">父传子</td><td style="text-align:center;">props</td><td style="text-align:center;">props</td></tr><tr><td style="text-align:left;">父传子</td><td style="text-align:center;">$attrs</td><td style="text-align:center;">attrs</td></tr><tr><td style="text-align:left;">父传子孙</td><td style="text-align:center;">provide/inject</td><td style="text-align:center;">provide/inject</td></tr><tr><td style="text-align:left;">子传父</td><td style="text-align:center;">$emit</td><td style="text-align:center;">$emit</td></tr><tr><td style="text-align:left;">子传父</td><td style="text-align:center;">$listeners</td><td style="text-align:center;">无(合并到 attrs方式)</td></tr><tr><td style="text-align:left;">子传父</td><td style="text-align:center;">作用域slot-scope</td><td style="text-align:center;">v-slot(#)</td></tr><tr><td style="text-align:left;">子组件访问父组件</td><td style="text-align:center;">$parent</td><td style="text-align:center;">无</td></tr><tr><td style="text-align:left;">父组件访问子组件</td><td style="text-align:center;">$children</td><td style="text-align:center;">无</td></tr><tr><td style="text-align:left;">父组件访问子组件</td><td style="text-align:center;">$ref</td><td style="text-align:center;">expose&amp;ref</td></tr><tr><td style="text-align:left;">兄弟组件传值</td><td style="text-align:center;">EventBus</td><td style="text-align:center;">mitt</td></tr></tbody></table><p>除了上面的传参方式你也可以回答Vuex和Pinia，前提你了解这两个状态管理器，因为你说了大概率下个问题就会问你Vuex和Pinia</p><h2 id="prosps" tabindex="-1">prosps <a class="header-anchor" href="#prosps" aria-label="Permalink to &quot;prosps&quot;">​</a></h2><p>props定义在子组件里，父组件通过v-bind给子组件传值，子组件渲染出来</p><h2 id="emit" tabindex="-1">emit <a class="header-anchor" href="#emit" aria-label="Permalink to &quot;emit&quot;">​</a></h2><ul><li>子组件通过自定义事件往父组件里传值，父组件调用子组件通过v-on接收，</li><li>父组件里给子组件自定义事件@xxx=func，func是写在父组件中的函数，子组件通过某种方式比如@click=$emit(&#39;xxx&#39;),就可以使父组件的func执行</li><li><code>@click=$emit(&#39;xxx&#39;)</code>还可以传参$emit(&#39;xxx&#39;,参数1，...参数n)</li></ul><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;"> @click=func&gt;&lt;/div&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">emits</span><span style="color:#89DDFF;"> = defineEmits();</span></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#89DDFF;"> func(){</span></span>
<span class="line"><span style="color:#89DDFF;">   emits(&#39;getFilesList&#39;, filesList.value)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//父</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;child @getFilesList=&quot;xxx&quot;&gt;&lt;/child&gt;</span></span></code></pre></div><h2 id="attrs" tabindex="-1">attrs <a class="header-anchor" href="#attrs" aria-label="Permalink to &quot;attrs&quot;">​</a></h2><p><code>:=attrs</code></p><p><code>const attrs = useAttrs()</code></p><h2 id="ref" tabindex="-1">ref <a class="header-anchor" href="#ref" aria-label="Permalink to &quot;ref&quot;">​</a></h2><p>在Vue中，使用ref可以在组件中引用子组件或DOM元素</p><ol><li>子组件的ref：当在父组件中使用ref引用子组件时，<strong>ref会被赋值为子组件实例</strong>。这意味着通过ref可以直接访问子组件的<strong>属性和方法</strong>，并在父组件中与子组件进行交互。</li><li>DOM元素的ref：当在Vue模板中使用ref引用DOM元素时，<strong>ref会被赋值为对应的DOM元素</strong>。这允许我们通过ref来访问和操作DOM元素，例如修改样式、添加事件监听器或执行其他DOM操作。</li><li>vue2使用<code>this.$refs</code>使用，vue3直接用<code>属性.value</code>使用</li></ol><h2 id="slot" tabindex="-1">slot <a class="header-anchor" href="#slot" aria-label="Permalink to &quot;slot&quot;">​</a></h2><p><strong>作用域插槽</strong>：可以传递数据的插槽，子组件可以将数据传给父组件，父组件在自己的模板中使用该数据。</p><p>父接收一个参数slotProps，它是一个包含了插槽数据的对象。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">//子</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;"> &gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">slot</span><span style="color:#89DDFF;"> :message=&quot;message&quot;&gt;&lt;/slot&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/div&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//父</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;child &gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">v-slot</span><span style="color:#89DDFF;">:</span><span style="color:#C792EA;">default</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">slotProps</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">p</span><span style="color:#89DDFF;">&gt;{{</span><span style="color:#A6ACCD;">slotProps.message</span><span style="color:#89DDFF;">}}&lt;/</span><span style="color:#F07178;">p</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">child</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div><h2 id="vuex" tabindex="-1">vuex <a class="header-anchor" href="#vuex" aria-label="Permalink to &quot;vuex&quot;">​</a></h2><ol><li>Vuex是Vue中的全局状态管理框架，它可以管理应用的所有组件的状态。并不是每个项目都需要引入Vuex的，当我们的项目有很多个页面，并且这些页面共享着多个数据状态，此时我们可以引入Vuex。</li><li>Vuex有三个核心的概念，state,mutations,actions,其中state为存放数据的地方，mutations中的函数作用则是用来修改state，actions中一般是用了处理一些异步操作的函数。</li><li>Vuex除了上面三个概念还有getters,moudles，getters就像Vue中的计算属性computed一样用来描述依赖响应式状态state中的复杂逻辑。moudles则是可以将store分割成模块（module），每个模块都拥有自己的state,mutations,actions等，在大型应用中经常用到</li><li>场景：当我们异步获取结果并赋值给state的时候，比如数据请求，我们可以在actions中进行数据请求，拿到结果通过它的dispatch方法调用mutations中修改state的函数，从而将结果赋值给了state</li></ol><h2 id="pinia" tabindex="-1">pinia <a class="header-anchor" href="#pinia" aria-label="Permalink to &quot;pinia&quot;">​</a></h2><ol><li>创建Store，<code>import {defineStore} from &#39;pinia&#39;</code>,</li></ol><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">defineStore</span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">pinia</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">exporet </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#A6ACCD;"> myStore </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">defineStore</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">id</span><span style="color:#89DDFF;">:</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">ljt</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#82AAFF;">state</span><span style="color:#89DDFF;">:()</span><span style="color:#C792EA;">=&gt;</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">            name</span><span style="color:#89DDFF;">:</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">孙悟空</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span></code></pre></div><ol start="2"><li>获取 state</li></ol><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">myStore</span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">@/地址</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> mystore </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">myStore</span><span style="color:#A6ACCD;">()</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(mystore</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">name)</span></span></code></pre></div><p>Pinia解构方法：storeToRefs,响应式解构</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">storeToRefs</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">pinia</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">name</span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">storeToRefs</span><span style="color:#A6ACCD;">(myStore)</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(name)</span></span></code></pre></div><ol start="3"><li>修改state 建议通过 actions 去修改 state，action 里可以直接通过 this 访问</li></ol><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">defineStore</span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">pinia</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">exporet </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#A6ACCD;"> myStore </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">defineStore</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">id</span><span style="color:#89DDFF;">:</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">ljt</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#82AAFF;">state</span><span style="color:#89DDFF;">:()</span><span style="color:#C792EA;">=&gt;</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">            name</span><span style="color:#89DDFF;">:</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">孙悟空</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">action</span><span style="color:#89DDFF;">:{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#F07178;">changename</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">name</span><span style="color:#89DDFF;">){</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">name</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">name</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span></code></pre></div><p>通过getter修改，不建议，方法每次页面渲染都会调用，性能消化大</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">exporet </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#A6ACCD;"> myStore </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">defineStore</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">id</span><span style="color:#89DDFF;">:</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">ljt</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#82AAFF;">state</span><span style="color:#89DDFF;">:()</span><span style="color:#C792EA;">=&gt;</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">            name</span><span style="color:#89DDFF;">:</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">孙悟空</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">actions</span><span style="color:#89DDFF;">:{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#F07178;">changename</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">name</span><span style="color:#89DDFF;">){</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">name</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">name</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">getters</span><span style="color:#89DDFF;">:{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#F07178;">changenames</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">state</span><span style="color:#89DDFF;">){</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">state</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">name</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">孙行者</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;"> </span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span></code></pre></div><ol start="4"><li>多条数据修改 <code>$patch</code> 方法可以接受两个类型的参数，函数 和 对象</li></ol><ul><li><code>$patch</code> + 对象</li></ul><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">myStore</span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">@/地址</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> mystore </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">myStore</span><span style="color:#A6ACCD;">()</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> patch </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">()</span><span style="color:#C792EA;">=&gt;</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">mystore</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">$patch</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        name</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">state</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">name</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">孙行者</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">        count</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">state</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">count</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">1</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p><code>$patch</code> + 函数： 通过函数方式去使用的时候，函数接受一个 state 的参数，state 就是 store 仓库中的 state</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">myStore</span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">@/地址</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> mystore </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">myStore</span><span style="color:#A6ACCD;">()</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> patchmethod </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">()</span><span style="color:#C792EA;">=&gt;</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">mystore</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">$patch</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">state</span><span style="color:#89DDFF;">)</span><span style="color:#C792EA;">=&gt;</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#A6ACCD;">state</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">name</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">state</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">name</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">孙行者</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#A6ACCD;">state</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">count</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">state</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">count</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">1</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><h3 id="调用其他store" tabindex="-1">调用其他store <a class="header-anchor" href="#调用其他store" aria-label="Permalink to &quot;调用其他store&quot;">​</a></h3><p>在 action 里调用其他 store 里的 action 也比较简单，引入对应的 store 后即可访问其内部的方法了。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// src/store/app.ts</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> useAppStore </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">defineStore</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">id</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">app</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">actions</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">setData</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">name</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">name</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">useAppStore</span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./app</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> useuserStore </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">defineStore</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">id</span><span style="color:#89DDFF;">:</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">user</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#82AAFF;">states</span><span style="color:#89DDFF;">:()</span><span style="color:#C792EA;">=&gt;</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">            name</span><span style="color:#89DDFF;">:</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">孙悟空</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">actions</span><span style="color:#89DDFF;">:{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#F07178;">usercomputed</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">name</span><span style="color:#89DDFF;">){</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">name</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">name</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">appstore</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">useAppStore</span><span style="color:#F07178;">()</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#A6ACCD;">appstore</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">setData</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">name</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">            </span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span></code></pre></div><ul><li>pinia其实就是Vuex5，它和Vuex的主要区别有以下几点</li><li>Pinia使用更简单，更符合开发者的开发习惯</li><li>pinia中抛弃传统的 Mutation ，只有 state, getter 和 action ，简化状态管理库,状态state的修改可以直接进行修改，或者在actions中修改，或者使用它的$patch方法进行修改</li><li>pinia中没有了modules,如果想使用多个store，直接使用defineStore定义多个store传入不同的id即可</li><li>更好的TS支持，不需要创建自定义的复杂包装器来支持TS</li></ul><h2 id="vue自定义指令" tabindex="-1">vue自定义指令 <a class="header-anchor" href="#vue自定义指令" aria-label="Permalink to &quot;vue自定义指令&quot;">​</a></h2><p><a href="./vue自定义指令/vue自定义指令.html">vue自定义指令</a></p><h2 id="keep-alive" tabindex="-1">keep-alive <a class="header-anchor" href="#keep-alive" aria-label="Permalink to &quot;keep-alive&quot;">​</a></h2><p><code>&lt;KeepAlive&gt; </code>是一个内置组件，它的功能是在多个组件间动态切换时缓存被移除的组件实例。</p><ol><li>通常我们切换组件的时候，上一个组件就会被销毁，而当我们使用<code>&lt;KeepAlive&gt;</code>将其包裹的话这个组件就会被缓存，当这个组件再一次被显示时就会保留之前的状态。</li><li>keep-alive接收两个属性include 和 exclude，分别代表哪些组件要用缓存和哪些不需要缓存，它接收组件的名字数组，字符串或者正则，当我们使用动态组件component或者路由router-view的时候可以使用</li><li>keep-alive还接收max属性表示最大缓存实例数，如果超出这个数则最久没有被访问的缓存实例将被销毁。</li><li>keep-alive有两个生命周期，分别是activated和deactivated，activated钩子会在首次挂载或者每次从缓存中被重新插入的时候调用,此时组件被激活。deactivated钩子则是在组件从DOM上移除或者组件卸载时调用，此时组件被缓存</li></ol><h3 id="activated" tabindex="-1">activated <a class="header-anchor" href="#activated" aria-label="Permalink to &quot;activated&quot;">​</a></h3><ol><li>首次执行执行顺序：created =&gt; mounted =&gt; activated ...</li><li>第二次或以后使用组件时触发activated， beforeCreate created beforeMount mounted 都不会触发。，执行顺序：activated =&gt; beforeupdate ...</li></ol><h3 id="deactivated" tabindex="-1">deactivated <a class="header-anchor" href="#deactivated" aria-label="Permalink to &quot;deactivated&quot;">​</a></h3><ol><li>使用了keep-alive就不会调用beforeDestroy(组件销毁前钩子)和destroyed(组件销毁)，因为组件没被销毁，被缓存起来了。</li></ol><h2 id="vue2混入-mixin" tabindex="-1">vue2混入-Mixin <a class="header-anchor" href="#vue2混入-mixin" aria-label="Permalink to &quot;vue2混入-Mixin&quot;">​</a></h2><p>混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。</p><ol><li>Mixin的作用将组件的公共逻辑提取出来，哪个组件需要用到时，直接将提取的这部分混入到组件内部即可</li><li>Mixin的生命周期会在父组件生命周期之前执行，如果Mixin中的属性或者方法与父组件冲突则会使用父组件中的</li><li>优点：可以降低代码冗余提高逻辑复用性。</li><li>缺点：命名容易冲突，不好追溯源，后期排查不方便</li></ol><h2 id="object-defineproperty和proxy区别" tabindex="-1"><code>Object.defineProperty</code>和<code>proxy</code>区别 <a class="header-anchor" href="#object-defineproperty和proxy区别" aria-label="Permalink to &quot;\`Object.defineProperty\`和\`proxy\`区别&quot;">​</a></h2><ol><li>Object.defineProperty 只能代理属性，Proxy 代理的是对象。</li><li>对象上新增属性，Proxy可以监听到，Object.defineProperty不能。</li><li>Object.defineProperty 的代理行为是在破坏原对象的基础上实现的，Proxy 则不会破坏原对象，只是在原对象上覆盖了一层。</li><li>数组新增修改，Proxy可以监听到，Object.defineProperty不能。</li><li>Proxy不兼容IE11及以下</li></ol><h2 id="vue3内置组件" tabindex="-1">vue3内置组件 <a class="header-anchor" href="#vue3内置组件" aria-label="Permalink to &quot;vue3内置组件&quot;">​</a></h2><p>vue3新增了两个内置组件分别是Teleport和Suspense。</p><h3 id="teleport" tabindex="-1">teleport <a class="header-anchor" href="#teleport" aria-label="Permalink to &quot;teleport&quot;">​</a></h3><p>可以称之为传送门，作用将其插槽内容渲染到 DOM 中的另一个位置，接收两个参数to（要去的位置）和disabled（是否留在原位置）。接收比如下面代码</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">teleport</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">to</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">#popup</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">video</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">src</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">./my-movie.mp4</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">teleport</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div><p>video将会被传送到id为popup的元素下。</p><h3 id="suspense组件" tabindex="-1">Suspense组件 <a class="header-anchor" href="#suspense组件" aria-label="Permalink to &quot;Suspense组件&quot;">​</a></h3><ol><li><code>&lt;Suspense&gt;</code> 组件用于协调对组件树中嵌套的异步依赖的处理。</li><li>它一般用于包裹多个异步组件处理多个异步组件加载前与完成后的统一状态</li><li><code>&lt;Suspense&gt;</code> 组件可以通过插槽的方式提供两个模板：<code>default</code> 和 <code>fallback</code>。 <code>fallback</code> 模板用于展示一个占位符，表示正在等待异步操作完成；<code>default</code>模板用于渲染实际内容，即异步组件。</li></ol><h2 id="nexttick及原理" tabindex="-1">nextTick及原理 <a class="header-anchor" href="#nexttick及原理" aria-label="Permalink to &quot;nextTick及原理&quot;">​</a></h2><h3 id="vue中的nexttick是干什么用的" tabindex="-1">vue中的nextTick是干什么用的? <a class="header-anchor" href="#vue中的nexttick是干什么用的" aria-label="Permalink to &quot;vue中的nextTick是干什么用的?&quot;">​</a></h3><p>在下次 DOM 更新循环结束之后执行延迟回调。它的作用是在 Vue 更新视图后，通过回调函数来访问更新后的 DOM，这个回调函数会在 DOM 更新循环结束之后执行，确保在访问更新后的 DOM 时是准确的。</p><p>这是什么意思呢,其实vue中修改data不会立刻触发dom更新;而是把需要更新的Watcher加入到queueWatcher队列中,然后在合适的时机在nextTick中调用这些Watcher的更新函数进行dom更新,所以在data刚被修改的时候,我们是获取不到更新后的dom的,这时候便需要调用nextTick函数在它的回调函数中获取到变化后的dom</p><p>利用了异步任务在同步任务之后执行的原理</p><h2 id="vue虚拟dom-diff算法" tabindex="-1">vue虚拟dom,diff算法 <a class="header-anchor" href="#vue虚拟dom-diff算法" aria-label="Permalink to &quot;vue虚拟dom,diff算法&quot;">​</a></h2><h3 id="什么是虚拟dom" tabindex="-1">什么是虚拟dom？ <a class="header-anchor" href="#什么是虚拟dom" aria-label="Permalink to &quot;什么是虚拟dom？&quot;">​</a></h3><p>每当我们用原生JS或者JQ操作DOM时，浏览器会从头开始进行DOM树的构建，频繁的操作DOM开销是很大的。 而虚拟DOM就是为了减少这些操作的，虚拟DOM首先会通过状态生成一个虚拟节点树（js对象），然后使用虚拟节点树进行渲染。当某些状态发生变更时会生成新的虚拟DOM节点树，然后与上一次虚拟DOM节点树进行比较（diff），从而找到差异的部分，最后渲染到真实的DOM节点上面</p><h3 id="说一下diff算法-对比两棵vdom-树-找到有差异的部分" tabindex="-1">说一下diff算法（对比两棵vdom 树，找到有差异的部分） <a class="header-anchor" href="#说一下diff算法-对比两棵vdom-树-找到有差异的部分" aria-label="Permalink to &quot;说一下diff算法（对比两棵vdom 树，找到有差异的部分）&quot;">​</a></h3><p>在vue中是当状态发生改变，用来计算改变后的虚拟DOM与改变前的虚拟DOM之间的差异的算法。 diff算法的本质是找出两个对象之间的差异，目的是尽可能复用节点，也就是通过移动代替新增。 两棵树的 diff 是 O(n^3) 的，时间复杂度太高，因此前端框架规定了只做同层 diff，还有 type 不一样就认为节点不一样，不再对比子节点。这样时间复杂度一下子就降到了 O(n)。 其实 diff 算法最重要的就是找到可复用的节点，然后移动到正确的位置。只不过不同的算法查找顺序不一样。</p><h2 id="vue的diff流程" tabindex="-1">vue的diff流程 <a class="header-anchor" href="#vue的diff流程" aria-label="Permalink to &quot;vue的diff流程&quot;">​</a></h2><ol><li><strong>生成新的虚拟DOM树</strong>：在每次数据更新时，Vue.js会重新构建一棵新的虚拟DOM树，表示新的UI结构。</li><li><strong>比较新旧虚拟DOM树的根节点</strong>：Vue.js会比较新旧虚拟DOM树的根节点，判断它们是否相同类型的节点。 <ol><li>如果根节点相同，进入下一步，比较其子节点。</li><li>如果根节点不同，Vue.js会销毁旧的虚拟DOM树及其对应的真实DOM，并将新的虚拟DOM树转换为真实DOM，插入到DOM树中。</li></ol></li><li><strong>比较子节点</strong>： <ol><li>对于每对相同位置的子节点，递归地应用Diff算法，比较它们的差异。</li><li>Vue.js会使用一种叫做&quot;<strong>双端比较</strong>&quot;的策略，同时从新旧虚拟DOM树的头部和尾部开始比较子节点，以尽可能地复用已有的DOM节点。</li></ol></li><li>递归处理子节点： <ol><li>继续递归地应用Diff算法，比较每对相同位置的子节点的差异。</li><li>在比较子节点的过程中，Vue.js会使用一些优化策略，例如为每个子节点添加唯一的key属性，以便更精确地定位和复用已有的DOM节点。</li></ol></li><li>完成Diff过程：当所有子节点都比较完成后，Diff算法就完成了。</li></ol><p>Vue.js会根据Diff算法生成一系列需要进行的DOM操作，如添加、删除、移动、替换等。 Vue.js会将这些DOM操作打包成批量更新操作，通过一次性地应用到真实DOM上，以减少DOM操作的次数。</p><h2 id="props使用-透传" tabindex="-1">props使用，透传 <a class="header-anchor" href="#props使用-透传" aria-label="Permalink to &quot;props使用，透传&quot;">​</a></h2><ul><li>props 父传子 在父组件里引用的子组件上使用<code>v-bind</code>或<code>：</code>传给子组件，子组件用<code>const props = defineProps([&quot;isShow&quot;])</code>接收</li><li>可透传：在上级组件中的属性可以直接传给最底层的根组件，最底层的根组件可以直接接收到父组件的属性</li></ul><p>父组件<code>father.vue</code></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">//父组件</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//从pinia拿数据</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">useMealsStore</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">../../store/meals</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> meals </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">useMealsStore</span><span style="color:#A6ACCD;">()</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">children</span><span style="color:#89DDFF;"> :meal=&quot;Meals.fillterMeals&quot;&gt;&lt;/children&gt;</span></span></code></pre></div><p>子组件<code>children.vue</code></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> props </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">defineProps</span><span style="color:#A6ACCD;">([</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">meal</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">])</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">v-if</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">props.meal &gt; 0</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">123</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div><h2 id="emit-1" tabindex="-1">emit <a class="header-anchor" href="#emit-1" aria-label="Permalink to &quot;emit&quot;">​</a></h2><ul><li>定义一个方法,将参数hide传递给父组件，父组件通过@hide监听并接收参数。</li><li>可透传</li></ul><p>子组件<code>children.vue</code></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> emit </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">defineEmit</span><span style="color:#A6ACCD;">([</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">hide</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">])</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;"> @click.self=&quot;$emit(&#39;hide&#39;)&quot;&gt;123&lt;/div&gt;</span></span></code></pre></div><p>父组件<code>father.vue</code></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">children</span><span style="color:#89DDFF;"> @hide=&quot;showdatils = false&quot;&gt;&lt;/children&gt;</span></span></code></pre></div><h2 id="vue-nexttick、this-nexttick-vue2-nexttick-vue3" tabindex="-1">Vue.nextTick、this.$nextTick（vue2），nextTick（vue3） <a class="header-anchor" href="#vue-nexttick、this-nexttick-vue2-nexttick-vue3" aria-label="Permalink to &quot;Vue.nextTick、this.$nextTick（vue2），nextTick（vue3）&quot;">​</a></h2><ul><li><code>组件的更新是异步执行</code>的，这意味着当您修改组件的数据或状态时，Vue并不会立即对DOM进行更新。相反，<code>Vue会将更新操作推入一个更新队列</code>，并缓冲在同一事件循环中发生的所有数据变更。如果<code>同一个 watcher 被多次触发，只会被推入到队列中一次</code>。并等待下一次DOM更新循环（也称为&quot;事件循环&quot;或&quot;帧&quot;）结束后才进行实际的DOM更新。</li><li>如果在<code>修改数据后立即访问更新后的 DOM 元素，可能无法获取到最新的结果</code>，因为组件的更新是异步执行的，需要等待下一次 DOM 更新循环结束后才能获取到更新后的 DOM。在这种情况下，可以使用 Vue.nextTick 来确保在 DOM 更新后执行相关操作。</li><li>Vue.nextTick 是 Vue 提供的方法，用于在下次 DOM 更新循环结束后执行回调函数。<code>传入nextTick的回调函数会在DOM更新完成后被调用</code>，就可以拿到最新的DOM元素了。</li></ul><h2 id="v-for的key" tabindex="-1">v-for的key <a class="header-anchor" href="#v-for的key" aria-label="Permalink to &quot;v-for的key&quot;">​</a></h2><p>为了配合diff算法更加高效，key是为了让diff算法更精准的识别到新旧dom的差异的节点，判断元素是新创建的还是被移动的元素，从而减少不必要的元素渲染，v-for不写key默认是index，index的效率低，如果在列表中添加一个数据后面的index就要重新排列，所以说能加key就加key</p><h2 id="suspense" tabindex="-1">suspense <a class="header-anchor" href="#suspense" aria-label="Permalink to &quot;suspense&quot;">​</a></h2><p>Suspense是一种用于在异步组件加载期间显示占位符内容的特性。有两个插槽#default和#fallback，#default是显示具体内容，#fallback是占位符，当异步组件一些耗时的任务是，先在fallback插槽显示占位符例如加载中...，拿到数据后再default 显示出来</p><h2 id="ref和reactive区别" tabindex="-1">ref和reactive区别 <a class="header-anchor" href="#ref和reactive区别" aria-label="Permalink to &quot;ref和reactive区别&quot;">​</a></h2><ul><li>ref适合基础类型的值将其包装为响应式对象，储存在value中</li><li>reactive适合复杂数据类型的对象将其包装成响应式对象，追踪更新对象的多个属性</li><li>ref需要用value读取更新值，reactive可以直接读取更新</li></ul><h2 id="slot-1" tabindex="-1">slot <a class="header-anchor" href="#slot-1" aria-label="Permalink to &quot;slot&quot;">​</a></h2><p>具名插槽</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">//父</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">child-component</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">v-slot</span><span style="color:#89DDFF;">:</span><span style="color:#C792EA;">header</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">h1</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">Header Content</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">h1</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;"> #footer&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">        &lt;p&gt;Footer Content&lt;/p&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">      &lt;/template&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">    &lt;/child-component&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">  &lt;/div&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/template&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//子</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;template&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">  &lt;div&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">    &lt;slot </span><span style="color:#C792EA;">name</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">header</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">slot</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">      &lt;!-- 子组件的内容 --&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">slot</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">name</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">footer</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">slot</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div><h2 id="vue的双向绑定和单向数据流冲突吗" tabindex="-1">Vue的双向绑定和单向数据流冲突吗? <a class="header-anchor" href="#vue的双向绑定和单向数据流冲突吗" aria-label="Permalink to &quot;Vue的双向绑定和单向数据流冲突吗?&quot;">​</a></h2><h3 id="单双向绑定-指的是view层和model层之间的映射关系。" tabindex="-1">单双向绑定，指的是View层和Model层之间的映射关系。 <a class="header-anchor" href="#单双向绑定-指的是view层和model层之间的映射关系。" aria-label="Permalink to &quot;单双向绑定，指的是View层和Model层之间的映射关系。&quot;">​</a></h3>`,164),F=s("li",null,"在React中，当View层发生更改时，用户通过发出Actions进行处理，Actions中通过setState对State进行更新，State更新后触发View更新。可以看出，View层不能直接修改State，必须要通过Actions来进行操作，这样更加清晰可控",-1),d=s("li",null,"双向绑定：表单的v-model，用户对View层的更改会直接同步到Model层,实际上v-model只是v-bind:value 和 v-on:input的语法糖",-1),u=l('<h3 id="单向数据流-vs-双向数据流" tabindex="-1">单向数据流 vs 双向数据流 <a class="header-anchor" href="#单向数据流-vs-双向数据流" aria-label="Permalink to &quot;单向数据流 vs 双向数据流&quot;">​</a></h3><ol><li><p>数据流指的是组件之间的数据流动。</p></li><li><p>Vue与React都是单向数据流的模型，虽然vue有双向绑定v-model，但是vue和react父子组件之间数据传递，仍然还是遵循单向数据流的，父组件可以向子组件传递props，但是子组件不能修改父组件传递来的props，子组件只能通过事件通知父组件进行数据更改</p></li><li><p>而真正的双向数据流，比如AngularJs，是允许在子组件中直接更新父组件的值的</p></li><li><p>总得来说，<code>数据绑定是View与Model之间的映射关系，数据流指的是组件之间的数据流动</code>。单双向数据绑定与数据流是两个不同维度的概念，数据绑定是View与Model之间的映射关系，数据流指的是组件之间的数据流动。因此，单向数据流也可有双向绑定，双向数据流也可以有双向绑定，两者不应该混为一谈</p></li></ol><h2 id="spa首屏加载速度慢的怎么解决" tabindex="-1">SPA首屏加载速度慢的怎么解决？ <a class="header-anchor" href="#spa首屏加载速度慢的怎么解决" aria-label="Permalink to &quot;SPA首屏加载速度慢的怎么解决？&quot;">​</a></h2><ul><li>网络延时问题</li><li>资源文件体积是否过大</li><li>资源是否重复发送请求去加载了</li><li>加载脚本的时候，渲染内容堵塞了</li></ul><h3 id="解决方案" tabindex="-1">解决方案 <a class="header-anchor" href="#解决方案" aria-label="Permalink to &quot;解决方案&quot;">​</a></h3><ul><li>减小入口文件积 (路由懒加载，动态路由)</li><li>静态资源本地缓存(合理利用localStorage)</li><li>UI框架按需加载</li><li>图片资源的压缩</li><li>组件重复打包 （<code>在webpack的config文件中，修改CommonsChunkPlugin的配置,minChunks为3表示会把使用3次及以上的包抽离出来，放进公共依赖文件，避免了重复加载组件</code>）</li><li>开启GZip压缩</li><li>使用SSR</li></ul><h2 id="说下你的vue项目的目录结构-如果是大型项目你该怎么划分结构和划分组件呢" tabindex="-1">说下你的vue项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢？ <a class="header-anchor" href="#说下你的vue项目的目录结构-如果是大型项目你该怎么划分结构和划分组件呢" aria-label="Permalink to &quot;说下你的vue项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢？&quot;">​</a></h2><ul><li>文件夹和文件夹内部文件的语义一致性</li><li>就近原则，紧耦合的文件应该放到一起，且应以相对路径引用</li><li>公共的文件应该以绝对路径的方式从根目录引用</li><li>/src 外的文件不应该被引入</li><li>vue-cli脚手架已经帮我们做了相关的约束了，正常我们的前端项目都会有个src文件夹，里面放着所有的项目需要的资源，js,css, png, svg 等等。src 外会放一些项目配置，依赖，环境等文件</li></ul><h2 id="vue使用css" tabindex="-1">vue使用css <a class="header-anchor" href="#vue使用css" aria-label="Permalink to &quot;vue使用css&quot;">​</a></h2><ul><li>通过 style 标签编写样式</li><li>scoped 属性决定编写的样式是否局部有效</li><li>lang 属性设置预处理器</li><li>内联样式风格的方式来根据最新状态设置和改变css</li></ul>',10);function C(n,A,h,m,f,g){return o(),t("div",null,[y,s("ol",null,[F,s("li",null,[a("Vue则同时支持单向绑定和双向绑定 "),s("ol",null,[s("li",null,[a("单向绑定：插值形式"),s("code",null,p(n.data),1),a("，v-bind也是单向绑定")]),d])])]),u])}const x=e(D,[["render",C]]);export{b as __pageData,x as default};
