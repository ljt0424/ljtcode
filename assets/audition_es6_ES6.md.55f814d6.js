import{_ as l,o as a,c as e,U as t}from"./chunks/framework.afdf1834.js";const m=JSON.parse('{"title":"ES6","description":"","frontmatter":{},"headers":[],"relativePath":"audition/es6/ES6.md","filePath":"audition/es6/ES6.md","lastUpdated":null}'),o={name:"audition/es6/ES6.md"},s=t(`<h1 id="es6" tabindex="-1">ES6 <a class="header-anchor" href="#es6" aria-label="Permalink to &quot;ES6&quot;">​</a></h1><h2 id="_1-什么是es6模块化" tabindex="-1">1. 什么是ES6模块化？ <a class="header-anchor" href="#_1-什么是es6模块化" aria-label="Permalink to &quot;1. 什么是ES6模块化？&quot;">​</a></h2><p>ES6 模块化规范是<strong>浏览器端与服务器端通用的模块化开发规范</strong>。</p><h3 id="定义" tabindex="-1">定义： <a class="header-anchor" href="#定义" aria-label="Permalink to &quot;定义：&quot;">​</a></h3><ol><li>每个 js 文件都是一个独立的模块</li><li>导入其它模块成员使用 import关键字</li><li>向外共享模块成员使用 export关键字</li></ol><h3 id="用法" tabindex="-1">用法： <a class="header-anchor" href="#用法" aria-label="Permalink to &quot;用法：&quot;">​</a></h3><ol><li>默认导出与默认导入</li><li>按需导出与按需导入</li><li>直接导入并执行模块中的代码</li></ol><h3 id="默认导出与默认导入注意点" tabindex="-1">默认导出与默认导入注意点： <a class="header-anchor" href="#默认导出与默认导入注意点" aria-label="Permalink to &quot;默认导出与默认导入注意点：&quot;">​</a></h3><ol><li>每个模块中，只允许使用唯一的一次export default，否则会报错</li><li>默认导入时的接收名称可以任意名称，只要是合法的成员名称即可</li></ol><h3 id="按需导入与按需导出注意点" tabindex="-1">按需导入与按需导出注意点： <a class="header-anchor" href="#按需导入与按需导出注意点" aria-label="Permalink to &quot;按需导入与按需导出注意点：&quot;">​</a></h3><ol><li>每个模块中可以使用多次按需导出</li><li>按需导入的成员名称必须和按需导出的名称保持一致</li><li>按需导入时，可以使用 as 关键字进行重命名</li><li>按需导入可以和默认导入一起使用</li></ol><h1 id="es6新增" tabindex="-1">ES6新增 <a class="header-anchor" href="#es6新增" aria-label="Permalink to &quot;ES6新增&quot;">​</a></h1><h2 id="_2-新增了let-const关键字" tabindex="-1">2. 新增了let const关键字 <a class="header-anchor" href="#_2-新增了let-const关键字" aria-label="Permalink to &quot;2. 新增了let const关键字&quot;">​</a></h2><ol><li>var允许重复声明，let、const不允许</li><li>var会提升变量的声明到作用域的顶部，但let和const不会</li><li>只要作用域内存在let、const，它们所声明的变量或常量就会自动“绑定”这个区域，不再受外部作用域的影响</li><li>全局作用域中，var声明的变量，通过function声明的函数，会自动变为window对象的变量，属性或方法，但const和let不会</li><li>var没有块级作用域，let和const有块级作用域</li></ol><h2 id="_3-作用域" tabindex="-1">3. 作用域 <a class="header-anchor" href="#_3-作用域" aria-label="Permalink to &quot;3. 作用域&quot;">​</a></h2><p>常见的作用域主要分为几个类型：全局作用域、函数作用域、块状作用域、动态作用域</p><table><thead><tr><th style="text-align:left;">对象</th><th style="text-align:center;">类型</th></tr></thead><tbody><tr><td style="text-align:left;">global/window</td><td style="text-align:center;">全局作用域</td></tr><tr><td style="text-align:left;">function</td><td style="text-align:center;">函数作用域（局部作用域）</td></tr><tr><td style="text-align:left;">{}</td><td style="text-align:center;">块级作用域</td></tr><tr><td style="text-align:left;">this</td><td style="text-align:center;">动态作用域</td></tr></tbody></table><ul><li>ECMAScript 6(简称ES6)中新增了块级作用域，使用let声明的变量只能在块级作用域里访问，有“暂时性死区”的特性（也就是说声明前不可用）。</li><li>大部分包含{}的都可以构成块级作用域，但是函数和对象不构成块级作用域（函数属于的是函数作用域而不是块级作用域，对象的话，又不能在里面let）</li></ul><h2 id="_4-新增的解构赋值" tabindex="-1">4. 新增的解构赋值 <a class="header-anchor" href="#_4-新增的解构赋值" aria-label="Permalink to &quot;4. 新增的解构赋值&quot;">​</a></h2><p>解构赋值针对数组或者对象进行模式匹配，然后对其中的变量进行赋值。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;">a</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;">b</span><span style="color:#89DDFF;">]</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> [</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#F78C6C;">2</span><span style="color:#A6ACCD;">]</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">user</span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> obj</span></span></code></pre></div><h2 id="_5-新增了箭头函数" tabindex="-1">5. 新增了箭头函数 <a class="header-anchor" href="#_5-新增了箭头函数" aria-label="Permalink to &quot;5. 新增了箭头函数&quot;">​</a></h2><p>箭头函数和普通函数的区别</p><ol><li>普通函数存在着变量的提升，箭头函数没有</li><li>普通函数的this指向，谁调用指向谁，箭头函数是在哪定义就指向谁</li><li>普通函数可以当成构造函数，而箭头函数是不可以的</li><li>箭头函数没有arguments,要接受所有的参数用...rest(扩展运算符)</li></ol><h2 id="_6-js新增简单数据类型symbol" tabindex="-1">6. js新增简单数据类型Symbol <a class="header-anchor" href="#_6-js新增简单数据类型symbol" aria-label="Permalink to &quot;6. js新增简单数据类型Symbol&quot;">​</a></h2><p><a href="./symbol.html">symbol</a></p><h2 id="_7-新增了class关键字" tabindex="-1">7. 新增了class关键字 <a class="header-anchor" href="#_7-新增了class关键字" aria-label="Permalink to &quot;7. 新增了class关键字&quot;">​</a></h2><p>class关键字是es5构造函数+原型模式创建对象的语法糖。创建类的方式 class 类名{构造函数和方法} 通过extends关键字实现继承。</p><h2 id="_8-es6新增了模块化" tabindex="-1">8. es6新增了模块化 <a class="header-anchor" href="#_8-es6新增了模块化" aria-label="Permalink to &quot;8. es6新增了模块化&quot;">​</a></h2><p>与node.js的commonjs不同,es6新增esmoudule 根据功能封装模块 通过import导入 然后通过export导出，也可以使用export default导出</p><ol><li>export 可以导出多个属性或者方法 ,需要用{}括起来 在用import接受的时候也得用{}接受</li><li>export default是以整体的方式抛出，接受的时候只接一个</li></ol><h2 id="_9-新增promise" tabindex="-1">9. 新增promise <a class="header-anchor" href="#_9-新增promise" aria-label="Permalink to &quot;9. 新增promise&quot;">​</a></h2><p><a href="./../js/promise.html">promise</a></p><h2 id="generator-生成器" tabindex="-1">Generator（生成器） <a class="header-anchor" href="#generator-生成器" aria-label="Permalink to &quot;Generator（生成器）&quot;">​</a></h2><p>Generator（生成器）是 ES6 中引入的一种特殊函数，它可以被暂停和恢复</p><p>场景： 惰性计算（Lazy Evaluation）：Generator 函数可以实现惰性计算，只有当需要获取值时 异步编程：Generator 函数与 yield 结合可以实现更简洁的异步编程 迭代器（Iterator）：Generator 函数默认返回一个迭代器对象，可以通过 next() 方法逐步遍历生成器函数中的每个值 状态机：由于 Generator 函数可以被暂停和恢复，因此可以用于实现复杂的状态机逻辑。</p><h2 id="es6新增-1" tabindex="-1">ES6新增 <a class="header-anchor" href="#es6新增-1" aria-label="Permalink to &quot;ES6新增&quot;">​</a></h2><ol><li>数组： <ol><li>扩展运算符</li><li>构造函数新增方法，Array.from、Array.of</li><li>数组新增方法，find,findindex,includes,fill,keys,values,entires，copywithin</li></ol></li><li>对象 <ol><li>属性简写</li><li>属性名表达式，<code>obj={a:1},obj[a] = 1</code></li><li>super,指向当前对象的原型对象</li><li>解构赋值,扩展运算符的应用,<code>let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };</code></li><li>对象新增的方法,Object.is()、Object.assign()、Object.keys()、Object.values()、Object.entries()</li></ol></li><li>函数 <ol><li>函数的参数设置默认值</li><li>函数的length属性，length将返回没有指定默认值的参数个数</li><li>作用域</li><li>箭头函数</li></ol></li><li>set&amp;map</li><li>promise</li><li>generator</li><li>proxy</li><li>模块化</li><li>Docorator修饰对象，在不改变原有代码情况下，对原来功能进行扩展，只能对类进行装饰，不能对函数进行装饰</li></ol>`,38),i=[s];function r(n,c,d,h,p,u){return a(),e("div",null,i)}const y=l(o,[["render",r]]);export{m as __pageData,y as default};
