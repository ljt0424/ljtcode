import{_ as t,o as e,c as l,U as a}from"./chunks/framework.afdf1834.js";const g=JSON.parse('{"title":"http","description":"","frontmatter":{},"headers":[],"relativePath":"audition/http/http协议.md","filePath":"audition/http/http协议.md","lastUpdated":null}'),i={name:"audition/http/http协议.md"},o=a('<h1 id="http" tabindex="-1">http <a class="header-anchor" href="#http" aria-label="Permalink to &quot;http&quot;">​</a></h1><h2 id="http概述" tabindex="-1">HTTP概述 <a class="header-anchor" href="#http概述" aria-label="Permalink to &quot;HTTP概述&quot;">​</a></h2><p>HTTP ( HyperText Transfer Protocal)，全称为超文本传输协议。HTTP是一个客户端终端（用户）和服务器端（网站）请求和应答的标准。通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如&quot;HTTP/1.1 200 OK&quot;，以及返回的内容，如请求的文件、错误消息、或者其它信息。</p><p>客户端 --&gt; 服务器（默认是80端口）--&gt; 服务器监听客户端的请求 --&gt; 收到请求 --(状态码，以及返回的内容，如请求的文件、错误消息、或者其它信息)--&gt; 客户端</p><h2 id="http特点" tabindex="-1">HTTP特点： <a class="header-anchor" href="#http特点" aria-label="Permalink to &quot;HTTP特点：&quot;">​</a></h2><ul><li>支持客户端、服务端模式</li><li>简单快速：客户向服务器请求服务时，只需要传送请求方法和路径。由于HTTP协议简单，使得通信速度比较快</li><li>灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记</li><li>无连接：每次连接只处理一个请求，服务器处理完客户请求，收到用户的应答后，便断开连接，这种方式可以节省传输时间</li><li>无状态：无状态是指协议对于事物处理没有记忆能力。不对请求和响应之间的通信状态进行保存，缺少状态意味着如果后续处理需要前面的信息，则它必须重传</li><li>无状态协议解决办法： 1、通过、Cookie 2、通过Session会话保存</li></ul><h2 id="tcp-ip" tabindex="-1">TCP/IP <a class="header-anchor" href="#tcp-ip" aria-label="Permalink to &quot;TCP/IP&quot;">​</a></h2><p>TCP/IP（Transmission Control Protocol/Internet Protocol，传输控制协议/网际协议）是指能够在多个不同网络间实现信息传输的协议簇。TCP/IP协议不仅仅指的是TCP 和IP两个协议，而是指一个由FTP、SMTP、TCP、UDP、IP等协议构成的协议簇， 只是因为在TCP/IP协议中TCP协议和IP协议最具代表性，所以被称为TCP/IP协议。</p><h2 id="tcp阻塞" tabindex="-1">tcp阻塞 <a class="header-anchor" href="#tcp阻塞" aria-label="Permalink to &quot;tcp阻塞&quot;">​</a></h2><p>可能会发生阻塞的情况：</p><ul><li>建立连接阻塞：在客户端请求建立连接时，如果<code>服务器没有及时响应</code>，客户端的连接请求可能会一直等待，导致阻塞。<code>设置超时等待时间</code></li><li>数据传输阻塞：在数据传输过程中，如果<code>网络拥塞或数据包丢失，TCP会进行重传</code>，重传的过程可能会导致数据传输的阻塞。</li><li>关闭连接阻塞：在关闭连接时，如果对方的确认未及时到达，TCP会等待一段时间进行重传，这可能导致关闭连接的操作阻塞。</li></ul><h2 id="http与https的区别" tabindex="-1">HTTP与HTTPS的区别 <a class="header-anchor" href="#http与https的区别" aria-label="Permalink to &quot;HTTP与HTTPS的区别&quot;">​</a></h2><p>HTTP协议传输的数据都是未加密的，也就是明文的，可以用抓包工具直接抓下来并且可见，而HTTPS则是利用了网景公司设计的SSL（Secure Sockets Layer）协议对HTTP协议传输的数据进行加密，SSL 依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。抓包工具抓下来的是密文，大幅增加了中间人攻击的成本。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比HTTP协议安全</p><p>主要区别：</p><ol><li>HTTP的URL由<code>http://起始且默认使用端口80</code>，而HTTPS的URL由<code>https://起始且默认使用端口443</code></li><li>HTTP是超文本传输协议，信息是明文传输，HTTPS则是具有安全性的 SSL 加密传输协议</li><li>HTTP的连接很简单，是无状态的，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全</li></ol><h2 id="ssl" tabindex="-1">ssl <a class="header-anchor" href="#ssl" aria-label="Permalink to &quot;ssl&quot;">​</a></h2><p>SSL（Secure Sockets Layer）是一种加密协议，用于在计算机网络上保证通信安全。它通过使用对称加密和非对称加密的组合来实现数据的机密性、完整性和身份验证。</p><p>SSL的工作原理：</p><ul><li>客户端请求：客户端（通常是Web浏览器）向服务器发送一个连接请求，并<code>请求服务器发送其SSL证书</code>。</li><li>服务器响应：服务器收到客户端的请求后，会将自己的SSL证书发送给客户端。<code>SSL证书包含了服务器的公钥、证书的颁发机构和有效期等信息</code>。</li><li>客户端验证：客户端收到服务器的SSL证书后，<code>会对证书进行验证</code>。它会检查证书的合法性和有效性，包括检查证书的颁发机构是否受信任，是否在有效期内等。</li><li>密钥交换：如果证书验证通过，<code>客户端会生成一个随机的对称密钥</code>，并使用服务器的<code>公钥对其进行加密</code>。然后将<code>加密后的密钥发送给服务器</code>。</li><li>服务器解密：服务器使用自己的<code>私钥对客户端发送的密钥进行解密</code>，得到对称密钥。</li><li>安全通信：服务器和客户端都有了<code>相同的对称密钥</code>，它们可以使用对称加密算法来进行通信，保障数据在传输过程中的保密性和完整性。</li></ul><h2 id="对称加密" tabindex="-1">对称加密 <a class="header-anchor" href="#对称加密" aria-label="Permalink to &quot;对称加密&quot;">​</a></h2><p>对称加密是一种加密方式，使用<strong>相同的密钥</strong>对数据进行加密和解密。</p><h2 id="非对称加密" tabindex="-1">非对称加密 <a class="header-anchor" href="#非对称加密" aria-label="Permalink to &quot;非对称加密&quot;">​</a></h2><p>非对称加密<strong>使用一对密钥</strong>：公钥和私钥。公钥用于加密数据，而私钥用于解密数据。</p><h2 id="http1-0与http2-0的区别" tabindex="-1">HTTP1.0与HTTP2.0的区别 <a class="header-anchor" href="#http1-0与http2-0的区别" aria-label="Permalink to &quot;HTTP1.0与HTTP2.0的区别&quot;">​</a></h2><p>HTTP 2.0 的出现，相比于 HTTP 1.x ，大幅度的提升了 web 性能</p><ul><li>HTTP/2是HTTP/1.1的升级版本，于2015年发布。它引入了一些重要的改进，其中最显著的是<code>多路复用</code>（multiplexing）功能。</li><li><code>多路复用允许在单个TCP连接上同时发送多个请求和响应</code>，从而提高性能并减少延迟。这对于加载复杂网页或处理大量资源请求时特别有用。</li><li>HTTP/2还引入了<code>头部压缩</code>（header compression）和<code>服务器推送</code>（server push）等功能，以减少数据传输量和提高效率。</li><li></li></ul><h3 id="多路复用" tabindex="-1">多路复用 <a class="header-anchor" href="#多路复用" aria-label="Permalink to &quot;多路复用&quot;">​</a></h3><p>多路复用允许在单个TCP连接上同时发送多个请求和响应`，从而提高性能并减少延迟。这对于加载复杂网页或处理大量资源请求时特别有用。</p><h3 id="头部压缩" tabindex="-1">头部压缩： <a class="header-anchor" href="#头部压缩" aria-label="Permalink to &quot;头部压缩：&quot;">​</a></h3><p>使用了<code>HPACK</code>压缩算法，它采用了动态表和静态表的方式来减少头部信息的大小</p><ul><li>动态表和静态表：在<code>客户端和服务器之间维护了一个动态表和一个静态表</code>，这些表中包含了一些常用的头部字段和值。<code>静态表是在协议中预定义的，不会改变</code>；<code>动态表则会根据请求和响应的头部信息动态变化</code>。</li><li>头部字段的索引：在每次请求和响应的头部信息中，<code>使用索引来引用静态表和动态表中的字段</code>。<code>索引是整数值，通过索引可以找到对应的头部字段和值</code>。</li><li>增量更新动态表：在处理请求和响应的过程中，<code>如果发现某些头部字段和值是自定义的或者是没出现过的新内容，那么可以将这些新内容添加到动态表中，并生成对应的索引。</code></li><li>压缩：通过 HPACK 算法对头部信息进行压缩。压缩后的头部信息会包含索引和增量更新动态表的信息，以及实际的头部字段和值。</li></ul><h3 id="服务器推送" tabindex="-1">服务器推送 <a class="header-anchor" href="#服务器推送" aria-label="Permalink to &quot;服务器推送&quot;">​</a></h3><p>服务器可以根据<code>当前请求和之前的请求历史预测</code>客户端可能需要的资源，并在客户端请求这些资源之前将它们推送给客户端,客户端<code>可以拒绝接收</code>推送的资源，或者已经缓存了相同资源的情况下，可以<code>忽略服务器推送</code>。</p><h2 id="cdn" tabindex="-1">CDN <a class="header-anchor" href="#cdn" aria-label="Permalink to &quot;CDN&quot;">​</a></h2><p>CDN就是根据用户位置分配最近的资源,用户在上网的时候不用直接访问源站，访问离他“最近的”一个 CDN 节点，术语叫边缘节点，其实就是缓存了源站内容的代理服务器 应用CDN后，DNS 返回的不再是 IP 地址，而是一个CNAME(Canonical Name ) 别名记录，指向CDN的全局负载均衡系统，</p><ul><li>负载均衡系统：CDN的全局负载均衡系统找到一个合适的边缘节点，返回给用户，就近访问CDN的缓存代理</li><li>缓存代理：缓存系统会有选择地缓存那些最常用的那些资源， <ul><li>命中率：用户访问的资源恰好在缓存系统里，可以直接返回给用户，命中次数与所有访问次数之比</li><li>回源率：缓存里没有，必须用代理的方式回源站取，回源次数与所有访问次数之比，可以分为一级缓存和二级缓存</li></ul></li></ul><h2 id="url的组成" tabindex="-1">URL的组成 <a class="header-anchor" href="#url的组成" aria-label="Permalink to &quot;URL的组成&quot;">​</a></h2><p>协议+主机名+路径+参数</p><h2 id="http请求" tabindex="-1">HTTP请求 <a class="header-anchor" href="#http请求" aria-label="Permalink to &quot;HTTP请求&quot;">​</a></h2><h3 id="请求行" tabindex="-1">请求行 <a class="header-anchor" href="#请求行" aria-label="Permalink to &quot;请求行&quot;">​</a></h3><p>请求行包括三个方面：请求方法、请求地址、协议版本</p><table><thead><tr><th style="text-align:left;">方法名</th><th style="text-align:left;">功能</th></tr></thead><tbody><tr><td style="text-align:left;">GET</td><td style="text-align:left;">向指定的资源发出“显示”请求，使用 GET 方法应该只用在读取数据上，而不应该用于产生“副作用”的操作中</td></tr><tr><td style="text-align:left;">POST</td><td style="text-align:left;">指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求文本中。这个请求可能会创建新的资源或者修改现有资源，或两者皆有。</td></tr><tr><td style="text-align:left;">PUT</td><td style="text-align:left;">向指定资源位置上传其最新内容</td></tr><tr><td style="text-align:left;">DELETE</td><td style="text-align:left;">请求服务器删除 Request-URI 所标识的资源</td></tr><tr><td style="text-align:left;">OPTIONS</td><td style="text-align:left;">使服务器传回该资源所支持的所有HTTP请求方法。用*来代替资源名称，向 Web 服务器发送 OPTIONS 请求，可以测试服务器功能是否正常运作</td></tr><tr><td style="text-align:left;">HEAD</td><td style="text-align:left;">与 GET 方法一样，都是向服务器发出指定资源的请求，只不过服务器将不传回资源的本文部分，它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中关于该资源的信息（原信息或称元数据）</td></tr><tr><td style="text-align:left;">TRACE</td><td style="text-align:left;">显示服务器收到的请求，主要用于测试或诊断</td></tr><tr><td style="text-align:left;">CONNECT</td><td style="text-align:left;">HTTP/1.1 中预留给能够将连接改为通道方式的代理服务器。通常用于 SSL 加密服务器的链接（经由非加密的 HTTP 代理服务器）</td></tr></tbody></table><h3 id="get与post的区别" tabindex="-1">GET与POST的区别： <a class="header-anchor" href="#get与post的区别" aria-label="Permalink to &quot;GET与POST的区别：&quot;">​</a></h3><ol><li>GET：一般用于信息获取，使用URL传递参数并且可见，传递参数数量有限</li><li>POST：一般用于提交数据，参数不可见，传递参数数量无限制</li></ol><p><strong>注意：</strong></p><p>安全性讲，get和post都一样，没啥所谓的哪个更安全,get请求参数在url地址上，直接暴露，post请求的参数放Request body部分，按F12也直接暴露了，所以没啥安全性可言</p><p>GET和POST有一个重大区别，简单的说：GET产生一个TCP数据包；POST产生两个TCP数据包</p><p>原因是：</p><ul><li>对于GET方式的请求，浏览器会把http<code>header和data</code>一并发送出去，服务器响应200（返回数据）</li><li>而对于POST，浏览器先发送header预检请求，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）</li><li>预检请求的目的是检查服务器是否支持实际的请求，以及是否允许跨域请求。</li><li>预检请求完成后，浏览器才会发送实际的 POST 请求。</li></ul><h3 id="什么情况下使用post请求" tabindex="-1">什么情况下使用POST请求： <a class="header-anchor" href="#什么情况下使用post请求" aria-label="Permalink to &quot;什么情况下使用POST请求：&quot;">​</a></h3><ol><li>无法使用缓存文件（更新服务器上的文件或数据库），GET能请求缓存，POST不能</li><li>向服务器发送大量数据（POST 没有数据量限制）</li><li>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</li></ol><h3 id="请求头" tabindex="-1">请求头 <a class="header-anchor" href="#请求头" aria-label="Permalink to &quot;请求头&quot;">​</a></h3><p>请求头可用于传递一些附加信息，格式为：键: 值，注意，冒号后面有一个空格：</p><ol><li>常见的请求 Header：</li></ol><table><thead><tr><th style="text-align:left;">名称</th><th style="text-align:left;">作用</th></tr></thead><tbody><tr><td style="text-align:left;">Authorization</td><td style="text-align:left;">用于设置身份认证信息</td></tr><tr><td style="text-align:left;">User-Agent</td><td style="text-align:left;">用户标识，如：OS 和浏览器的类型和版本</td></tr><tr><td style="text-align:left;">If-Modified-Since</td><td style="text-align:left;">值为上一次服务器返回的Last-Modified值，用于确定某个资源是否被更改过，没有更改过就从缓存中读取</td></tr><tr><td style="text-align:left;">If-None-Match</td><td style="text-align:left;">值为上一次服务器返回的 ETag 值，一般会和If-Modified-Since</td></tr><tr><td style="text-align:left;">Cookie</td><td style="text-align:left;">已有的Cookie</td></tr><tr><td style="text-align:left;">Referer</td><td style="text-align:left;">标识请求引用自哪个地址，比如你从页面 A 跳转到页面 B 时，值为页面 A 的地址</td></tr><tr><td style="text-align:left;">Host</td><td style="text-align:left;">请求的主机和端口号</td></tr></tbody></table><ol start="2"><li>请求和响应常见通用的 Header</li></ol><table><thead><tr><th style="text-align:left;">名称</th><th style="text-align:left;">作用</th></tr></thead><tbody><tr><td style="text-align:left;">Content-Type</td><td style="text-align:left;">请求体/响应体的类型，如：text/plain、application/json、x-www-form-urlencoded</td></tr><tr><td style="text-align:left;">Accept</td><td style="text-align:left;">说明接收的类型，可以多个值，用,(英文逗号)分开</td></tr><tr><td style="text-align:left;">Content-length</td><td style="text-align:left;">请求体/响应体的长度，单位字节</td></tr><tr><td style="text-align:left;">Content-Encoding</td><td style="text-align:left;">请求体/响应体的编码格式，如 gzip、deflate</td></tr><tr><td style="text-align:left;">Accept-Encoding</td><td style="text-align:left;">告知对方我方接受的 Content-Encoding</td></tr><tr><td style="text-align:left;">ETag</td><td style="text-align:left;">给当前资源的标识，和Last-Modified、If-None-Match、If-Modified-Since配合，用于缓存控制</td></tr><tr><td style="text-align:left;">Cache-Control</td><td style="text-align:left;">取值一般为no-cache、max-age=xx，xx为整数，表示资源缓存有效期（秒）</td></tr></tbody></table><h3 id="请求体" tabindex="-1">请求体 <a class="header-anchor" href="#请求体" aria-label="Permalink to &quot;请求体&quot;">​</a></h3><p>请求体（又叫请求正文）是 post 请求方式中的请求参数，以 key = value 形式进行存储，多个请求参数之间用&amp;连接，如果请求当中请求体，那么在请求头当中的 Content-Length 属性记录的就是该请求体的长度</p><h2 id="http响应" tabindex="-1">HTTP响应 <a class="header-anchor" href="#http响应" aria-label="Permalink to &quot;HTTP响应&quot;">​</a></h2><p>HTTP响应报文分为三个部分：<strong>响应状态行，响应头，响应体</strong></p><h3 id="响应状态行" tabindex="-1">响应状态行 <a class="header-anchor" href="#响应状态行" aria-label="Permalink to &quot;响应状态行&quot;">​</a></h3><table><thead><tr><th style="text-align:left;">状态码</th><th style="text-align:left;">对应的信息</th></tr></thead><tbody><tr><td style="text-align:left;">1XX</td><td style="text-align:left;">提示信息—表示请求已接收，继续处理</td></tr><tr><td style="text-align:left;">2XX</td><td style="text-align:left;">用于表示请求已被成功接收、理解、接收</td></tr><tr><td style="text-align:left;">3XX</td><td style="text-align:left;">用于表示资源（网页等）被永久转移到其它 URL，也就是所谓的重定向</td></tr><tr><td style="text-align:left;">4XX</td><td style="text-align:left;">客户端错误—请求有语法错误或者请求无法实现</td></tr><tr><td style="text-align:left;">5XX</td><td style="text-align:left;">服务器端错误—服务器未能实现合法的请求</td></tr></tbody></table><h3 id="常见状态码" tabindex="-1">常见状态码 <a class="header-anchor" href="#常见状态码" aria-label="Permalink to &quot;常见状态码&quot;">​</a></h3><ol><li><strong>2XX 成功</strong><ol><li><strong>200</strong> （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。</li><li>201 （已创建） 请求成功并且服务器创建了新的资源。</li><li>202 （已接受） 服务器已接受请求，但尚未处理。</li><li>203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。</li><li>204 （无内容） 服务器成功处理了请求，但没有返回任何内容。</li><li>205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。</li><li>206 （部分内容） 服务器成功处理了部分 GET 请求。</li></ol></li><li><strong>3XX 重定向</strong><ol><li>300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。</li><li><strong>301</strong> （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。</li><li><strong>302</strong> （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</li><li>303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。</li><li><strong>304</strong> （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。</li><li>305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。</li><li>307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</li></ol></li><li><strong>4XX 客户端错误</strong><ol><li><strong>400</strong> （错误请求） 服务器不理解请求的语法。</li><li><strong>401</strong> （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</li><li><strong>403</strong> （禁止） 服务器拒绝请求。</li><li><strong>404</strong> （未找到） 服务器找不到请求的网页。</li><li>405 （方法禁用） 禁用请求中指定的方法。</li><li>406 （不接受） 无法使用请求的内容特性响应请求的网页。</li><li>407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。</li><li><strong>408</strong> （请求超时） 服务器等候请求时发生超时。</li><li>409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。</li><li>410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。</li><li>411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。</li><li>412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。</li><li>413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。</li><li>414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。</li><li>415 （不支持的媒体类型） 请求的格式不受请求页面的支持。</li><li>416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。</li><li>417 （未满足期望值） 服务器未满足&quot;期望&quot;请求标头字段的要求。</li></ol></li><li><strong>5XX 服务器错误</strong><ol><li><strong>500</strong> （服务器内部错误） 服务器遇到错误，无法完成请求。</li><li>501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。</li><li>502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。</li><li><strong>503</strong> （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。</li><li>504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。</li><li>505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。</li></ol></li></ol><h3 id="响应头-响应体" tabindex="-1">响应头 响应体 <a class="header-anchor" href="#响应头-响应体" aria-label="Permalink to &quot;响应头 响应体&quot;">​</a></h3><h2 id="浏览器输入url按回车背后经历了哪些" tabindex="-1">浏览器输入url按回车背后经历了哪些 <a class="header-anchor" href="#浏览器输入url按回车背后经历了哪些" aria-label="Permalink to &quot;浏览器输入url按回车背后经历了哪些&quot;">​</a></h2><p><a href="https://juejin.cn/post/6844903922084085773" target="_blank" rel="noreferrer">参考这篇博文</a></p><ol><li>URL 解析</li><li>DNS 查询(获取网站的ip地址，向 DNS 服务器发送查询请求，通过网址获取ip地址)</li><li>TCP 连接</li><li>客户端向服务器发请求(http协议)</li><li>服务器处理请求，返回响应(http协议)</li><li>客户端接受响应</li><li>渲染页面</li></ol><h3 id="url-解析" tabindex="-1">URL 解析 <a class="header-anchor" href="#url-解析" aria-label="Permalink to &quot;URL 解析&quot;">​</a></h3><ol><li>地址解析,首先判断你输入的是一个合法的 URL 还是一个待搜索的关键词，并且根据你输入的内容进行自动完成、字符编码等操作。</li><li>会使用 HSTS 强制客户端使用 HTTPS 访问页面</li><li>浏览器还会进行一些额外的操作，比如安全检查、访问限制</li><li>检查缓存</li></ol><h3 id="dns-查询" tabindex="-1">DNS 查询 <a class="header-anchor" href="#dns-查询" aria-label="Permalink to &quot;DNS 查询&quot;">​</a></h3><ol><li>浏览器缓存,浏览器会先检查是否在缓存中，没有则调用系统库函数进行查询。</li><li>操作系统缓存,操作系统也有自己的 DNS缓存，但在这之前，会向检查域名是否存在本地的 Hosts 文件里，没有则向 DNS 服务器发送查询请求。</li><li>路由器缓存</li><li>ISP DNS 缓存</li></ol><h3 id="计算机网络五层七层协议" tabindex="-1">计算机网络五层七层协议 <a class="header-anchor" href="#计算机网络五层七层协议" aria-label="Permalink to &quot;计算机网络五层七层协议&quot;">​</a></h3><p>五层协议模型（TCP/IP协议模型）：</p><ul><li>物理层（Physical Layer）：负责传输数据的物理媒介，如电缆、光纤等。</li><li>数据链路层（Data Link Layer）：<code>在直接连接的节点之间传输数据</code>，提供了可靠的数据传输。</li><li>网络层（Network Layer）：<code>负责路由和寻址</code>，将数据包从源地址传输到目的地址。</li><li>传输层（Transport Layer）：<code>提供端到端的数据传输服务</code>，确保数据的可靠传输。</li><li>应用层（Application Layer）：为应用程序提供网络服务，是最接近用户的层次。</li></ul><p>七层协议模型（OSI参考模型）：</p><ul><li>物理层（Physical Layer）</li><li>数据链路层（Data Link Layer）</li><li>网络层（Network Layer）</li><li>传输层（Transport Layer）</li><li>会话层（Session Layer）</li><li>表示层（Presentation Layer）</li><li>应用层（Application Layer）</li></ul><h3 id="处理请求" tabindex="-1">处理请求 <a class="header-anchor" href="#处理请求" aria-label="Permalink to &quot;处理请求&quot;">​</a></h3><p>服务器处理收到的请求，将数据返回至浏览器</p><h3 id="浏览器收到http响应" tabindex="-1">浏览器收到HTTP响应 <a class="header-anchor" href="#浏览器收到http响应" aria-label="Permalink to &quot;浏览器收到HTTP响应&quot;">​</a></h3><p>浏览器解码响应，如果响应可以缓存，则存入缓存。</p><h3 id="渲染页面" tabindex="-1">渲染页面 <a class="header-anchor" href="#渲染页面" aria-label="Permalink to &quot;渲染页面&quot;">​</a></h3><h2 id="tcp-建立连接是三次握手-而断开连接是四次挥手。" tabindex="-1">TCP 建立连接是三次握手，而断开连接是四次挥手。 <a class="header-anchor" href="#tcp-建立连接是三次握手-而断开连接是四次挥手。" aria-label="Permalink to &quot;TCP 建立连接是三次握手，而断开连接是四次挥手。&quot;">​</a></h2><h3 id="三次握手" tabindex="-1">三次握手 <a class="header-anchor" href="#三次握手" aria-label="Permalink to &quot;三次握手&quot;">​</a></h3><p>三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。</p><p>刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。 进行三次握手判断服务端的接收、发送能力，客户端的接收、发送能力是否是正常的</p><ol><li>第一次握手就是客户端给服务器端发送一个报文，客户端的发送能力、服务端的接收能力是正常的。</li><li>第二次就是服务器收到报文之后，会应答一个报文给客户端，服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。</li><li>第三次握手就是客户端收到报文后再给服务器发送一个报文，三次握手就成功了。客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</li></ol><h3 id="四次挥手" tabindex="-1">四次挥手 <a class="header-anchor" href="#四次挥手" aria-label="Permalink to &quot;四次挥手&quot;">​</a></h3><p>TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，客户端或服务器均可主动发起挥手动作。</p><ol><li>第一次挥手：客户端发送一个 FIN 报文，等待服务端的确认。此时客户端处于<strong>FIN_WAIT1</strong>状态。</li><li>服务端收到 FIN 之后，会发送 ACK 报文，表明已经收到客户端的报文了，此时服务端处于 <strong>CLOSE_WAIT</strong>状态。</li><li>如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，此时服务端处于<strong>LAST_ACK</strong>的状态。</li><li>客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，此时客户端处于<strong>TIME_WAIT</strong>状态</li><li>服务端收到 ACK 报文之后，就处于关闭连接了，处于<strong>CLOSED</strong>状态。</li></ol><h2 id="ip" tabindex="-1">ip <a class="header-anchor" href="#ip" aria-label="Permalink to &quot;ip&quot;">​</a></h2><p>IP（Internet Protocol）是用于在网络中标识和定位设备的地址。在 IP 地址中，有内网 IP 和公网 IP，同时还有子网掩码用于定义 IP 地址的网络部分和主机部分。</p><h2 id="tcp和udp" tabindex="-1">tcp和udp <a class="header-anchor" href="#tcp和udp" aria-label="Permalink to &quot;tcp和udp&quot;">​</a></h2><p>TCP（Transmission Control Protocol）和 UDP（User Datagram Protocol）是两种在计算机网络中常用的传输层协议，它们在数据传输方式、可靠性、连接性等方面存在一些区别。</p><ul><li>连接性：TCP 是面向<strong>连接</strong>的协议，通过三次握手建立可靠的连接，确保数据的可靠传输。UDP <strong>是无连接的协议</strong>，数据包在发送之前不需要建立连接。</li><li>数据传输方式：TCP 提供<code>面向字节流的数据传输方式</code>，将数据切分为大小不等的数据段进行传输，并确保数据的顺序和完整性。UDP 则以<code>数据报的形式传输数据</code>，每个数据报都是独立的单元，可能会以<strong>不同的顺序</strong>到达目的地。</li><li>可靠性：TCP 提供<strong>可靠</strong>的数据传输，通过确认、重传和拥塞控制等机制，确保数据的完整性和顺序性。UDP 不提供<strong>可靠</strong>性保证，它只是简单地将数据报发送出去，不关心数据是否到达目的地。</li><li>效率：由于 TCP 需要维护连接状态和保证数据的可靠传输，因此相对而言会增加一定的开销，使得数据传输效率较低。而 UDP 没有这些开销，<strong>传输效率较高</strong>。</li><li>应用场景：TCP 适用于要求数据传输的可靠性和顺序性的应用，如文件传输、网页浏览、电子邮件等。UDP 适用于实时性要求较高、对数据可靠性要求较低的应用，如音频和视频流媒体、实时游戏等。</li></ul><p>总结来说，<code>TCP 提供可靠的、面向连接的数据传输，确保数据的完整性和顺序性</code>，适用于对数据可靠性和顺序性有要求的应用；<code>UDP 提供无连接的、不可靠的数据传输，数据传输速度快，不保证数据的完整性和顺序性</code>，适用于实时性要求较高、对数据可靠性要求较低的应用。选择使用 TCP 还是 UDP 取决于具体的应用需求。</p><h2 id="http无状态的协议" tabindex="-1">HTTP无状态的协议 <a class="header-anchor" href="#http无状态的协议" aria-label="Permalink to &quot;HTTP无状态的协议&quot;">​</a></h2><p>HTTP（Hypertext Transfer Protocol）是一种无状态的协议。</p><p>无状态指的是在每个独立的 HTTP 请求之间，<strong>服务器不会保留任何关于客户端的状态信息</strong>。每个请求都是独立的，服务器无法识别出不同请求来自同一个客户端。这意味着服务器不能基于之前的请求状态来处理当前的请求。它使得服务器可以独立地处理每个请求，不需要为每个客户端维护状态信息，从而更容易实现负载均衡和横向扩展。</p><p>使用 Cookie、Session、Token 来维护状态</p><h2 id="cookie、session、token" tabindex="-1">cookie、session、token <a class="header-anchor" href="#cookie、session、token" aria-label="Permalink to &quot;cookie、session、token&quot;">​</a></h2><p>Web应用程序中管理用户认证和授权的机制</p><p>Cookie：Cookie 是一种<strong>存储在客户端（通常是浏览器）的小型文本文件</strong>，由服务器通过 <strong>HTTP 响应头</strong>设置并发送给客户端。浏览器会在后续的请求中将 <strong>Cookie 自动包含在 HTTP 请求头</strong>中发送给服务器。Cookie 主要用于在客户端存储有<strong>关用户的一些状态信息或标识符</strong>，以便服务器在后续请求中进行识别和处理。Cookie 可以设置过期时间，可以是会话级别的（在浏览器关闭后失效）或持久性的（在一定时间后失效）。</p><p>Session：Session 是一种服务器端的状态管理机制。当用户<strong>进行身份认证</strong>后，服务器会为该用户<strong>创建一个唯一的 Session 对象</strong>，并为该对象<strong>分配一个唯一的标识符（Session ID）</strong>。Session ID 通常<strong>通过 Cookie 或 URL 参数的方式发送给客户端</strong>，并在后续的请求中<strong>通过 Cookie 或参数传递给服务器</strong>。服务器根据 Session ID 识别用户，并在<code>服务器端存储和管理与该用户相关的状态信息</code>。Session 通常存储在服务器的内存或持久化存储（如数据库）中，<code>需要在服务器上维护状态</code>，可以存储更多敏感的用户信息。</p><p>Token：Token 是一种<strong>无状态的身份验证机制</strong>。在用户<strong>进行身份认证</strong>后，服务器会生成一个加密的令牌（Token）并返回给客户端。客户端在后续的请求中将该 <strong>Token 包含在请求头</strong>中发送给服务器进行身份验证。服务器在接收到 Token 后解密并验证其有效性，从而确定用户的身份。Token 可以包含一些用户信息，但通常不存储在服务器端，而是在令牌本身进行加密和验证。常见的 Token 实现方式包括 JSON Web Token (JWT)。 Token 的优势在于它能够避免服务器上的Session存储，因为<code>Token本身就包含了认证信息，无需服务器去维护状态</code>，</p><h2 id="进程和线程" tabindex="-1">进程和线程 <a class="header-anchor" href="#进程和线程" aria-label="Permalink to &quot;进程和线程&quot;">​</a></h2><p>进程和线程是操作系统中用于执行任务的两个基本概念。 进程（Process）是指正在执行的程序的实例。 线程（Thread）是进程中的执行单元。一个进程可以拥有多个线程，</p>',108),r=[o];function n(d,s,h,c,T,p){return e(),l("div",null,r)}const u=t(i,[["render",n]]);export{g as __pageData,u as default};
