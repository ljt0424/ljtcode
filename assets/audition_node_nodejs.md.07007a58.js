import{_ as a,o as s,c as o,U as e}from"./chunks/framework.afdf1834.js";const D=JSON.parse('{"title":"Node.js","description":"","frontmatter":{},"headers":[],"relativePath":"audition/node/nodejs.md","filePath":"audition/node/nodejs.md","lastUpdated":null}'),n={name:"audition/node/nodejs.md"},l=e(`<h1 id="node-js" tabindex="-1">Node.js <a class="header-anchor" href="#node-js" aria-label="Permalink to &quot;Node.js&quot;">​</a></h1><h2 id="node-js-如何处理-es6-模块" tabindex="-1">Node.js 如何处理 ES6 模块 <a class="header-anchor" href="#node-js-如何处理-es6-模块" aria-label="Permalink to &quot;Node.js 如何处理 ES6 模块&quot;">​</a></h2><p>学习 JavaScript 语言，你会发现它有两种格式的模块。<br> 一种是 ES6 模块，简称 ESM；另一种是 Node.js 专用的 CommonJS 模块，简称 CJS。这两种模块不兼容.</p><h3 id="两种模块的差异" tabindex="-1">两种模块的差异 <a class="header-anchor" href="#两种模块的差异" aria-label="Permalink to &quot;两种模块的差异&quot;">​</a></h3><p>语法上面，CommonJS 模块使用require()加载一个模块对象和module.exports输出一个模块对象，ES6 模块使用import引入具体数据和export导出指定数据。<br> 用法上面，require()是同步加载，后面的代码必须等待这个命令执行完，才会执行。import命令则是异步加载，或者更准确地说，ES6 模块有一个独立的静态解析阶段，依赖关系的分析是在那个阶段完成的，最底层的模块第一个执行。</p><h3 id="两种模块的区分" tabindex="-1">两种模块的区分 <a class="header-anchor" href="#两种模块的区分" aria-label="Permalink to &quot;两种模块的区分&quot;">​</a></h3><p>Node.js 要求 ES6 模块采用.mjs后缀文件名。也就是说，只要脚本文件里面使用import或者export命令，那么就必须采用.mjs后缀名。Node.js 遇到.mjs文件，就认为它是 ES6 模块，默认启用严格模式，不必在每个模块文件顶部指定&quot;use strict&quot;。<br> 如果不希望将后缀名改成.mjs，可以在项目的package.json文件中，指定type字段为module。</p><h3 id="加载" tabindex="-1">加载 <a class="header-anchor" href="#加载" aria-label="Permalink to &quot;加载&quot;">​</a></h3><p>ES6 模块import命令<strong>可以</strong>加载 CommonJS 模块，但是只能整体加载，不能只加载单一的输出项，但是可以这样写：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> packageMain </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">commonjs-package</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> method </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> packageMain</span><span style="color:#89DDFF;">;</span></span></code></pre></div><p>因为 ES6 模块需要支持静态代码分析，而 CommonJS 模块的输出接口是module.exports，是一个对象，无法被静态分析，所以只能整体加载。CommonJS 模块<strong>不能</strong>加载 ES6 模块，require()不支持 ES6 模块的一个原因是，它是同步加载，而 ES6 模块内部可以使用顶层await命令，导致无法被同步加载。</p><h3 id="同时支持两种格式的模块" tabindex="-1">同时支持两种格式的模块 <a class="header-anchor" href="#同时支持两种格式的模块" aria-label="Permalink to &quot;同时支持两种格式的模块&quot;">​</a></h3><p>是在package.json文件的exports字段，指明两种格式模块各自的加载入口。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">exports</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">：</span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">require</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">: </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">./index.js</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">，</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">import</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">: </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">./esm/wrapper.js</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;"> </span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>上面代码指定require()和import，加载该模块会自动切换到不一样的入口文件。 <strong>总结为一句话</strong>：.mjs文件总是以 ES6 模块加载，.cjs文件总是以 CommonJS 模块加载，.js文件的加载取决于package.json里面type字段的设置。</p><h2 id="nodejs的内置模块" tabindex="-1">nodejs的内置模块 <a class="header-anchor" href="#nodejs的内置模块" aria-label="Permalink to &quot;nodejs的内置模块&quot;">​</a></h2><p>可以直接在node中使用</p><h3 id="process" tabindex="-1">process <a class="header-anchor" href="#process" aria-label="Permalink to &quot;process&quot;">​</a></h3><p>process表示控制当前node进程</p><ul><li><code>process.exit()</code>结束进程</li><li><code>process.nextTick(()=&gt;{})</code>将函数插入到tick队列</li><li>process.nextTick的优先级比promise.then高，优先输出process.nextTick的值</li></ul><h3 id="path" tabindex="-1">Path <a class="header-anchor" href="#path" aria-label="Permalink to &quot;Path&quot;">​</a></h3><p>获取文件夹路径</p><ul><li><code>path.resolve([...path])</code> 绝对路径，如果是相对路径则自动转为绝对路径</li><li><code>path.resolve(__dirname, path)</code></li></ul><h3 id="fs" tabindex="-1">Fs <a class="header-anchor" href="#fs" aria-label="Permalink to &quot;Fs&quot;">​</a></h3><p>读取磁盘中的文件</p><ul><li><code>fs.readFile</code></li><li><code>fs.appendFile</code></li><li><code>fs.mkdir</code></li><li><code>fs.rmdir</code></li></ul><h2 id="node是单线程的怎么做高并发" tabindex="-1">node是单线程的怎么做高并发 <a class="header-anchor" href="#node是单线程的怎么做高并发" aria-label="Permalink to &quot;node是单线程的怎么做高并发&quot;">​</a></h2><p>Node.js 通过非阻塞 I/O、异步编程和事件循环等机制，以及多进程和集群的方式，实现了高并发处理能力</p><h2 id="" tabindex="-1"><a class="header-anchor" href="#" aria-label="Permalink to &quot;&quot;">​</a></h2><h2 id="-1" tabindex="-1"><a class="header-anchor" href="#-1" aria-label="Permalink to &quot;&quot;">​</a></h2><h2 id="-2" tabindex="-1"><a class="header-anchor" href="#-2" aria-label="Permalink to &quot;&quot;">​</a></h2>`,31),t=[l];function r(p,c,i,d,h,u){return s(),o("div",null,t)}const F=a(n,[["render",r]]);export{D as __pageData,F as default};
