import{_ as t,o as e,c as a,U as l}from"./chunks/framework.afdf1834.js";const x=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"audition/面试/天正.md","filePath":"audition/面试/天正.md","lastUpdated":null}'),n={name:"audition/面试/天正.md"},s=l(`<h2 id="vue的生命周期" tabindex="-1">vue的生命周期 <a class="header-anchor" href="#vue的生命周期" aria-label="Permalink to &quot;vue的生命周期&quot;">​</a></h2><table><thead><tr><th style="text-align:left;">Vue2(选项式API)</th><th style="text-align:center;">Vue3(setup)(选项式API)</th><th style="text-align:center;">描述</th></tr></thead><tbody><tr><td style="text-align:left;">beforeCreate</td><td style="text-align:center;">-</td><td style="text-align:center;">实例创建前</td></tr><tr><td style="text-align:left;">created</td><td style="text-align:center;">-</td><td style="text-align:center;">实例创建后</td></tr><tr><td style="text-align:left;">beforeMount</td><td style="text-align:center;">onBeforeMount</td><td style="text-align:center;">DOM挂载前调用</td></tr><tr><td style="text-align:left;">mounted</td><td style="text-align:center;">onMounted</td><td style="text-align:center;">DOM挂载完成调用</td></tr><tr><td style="text-align:left;">beforeUpdate</td><td style="text-align:center;">onBeforeUpdate</td><td style="text-align:center;">数据更新之前被调用</td></tr><tr><td style="text-align:left;">updated</td><td style="text-align:center;">onUpdated</td><td style="text-align:center;">数据更新之后被调用</td></tr><tr><td style="text-align:left;">beforeDestroy</td><td style="text-align:center;">onBeforeUnmount</td><td style="text-align:center;">组件销毁前调用</td></tr><tr><td style="text-align:left;">destroyed</td><td style="text-align:center;">onUnmounted</td><td style="text-align:center;">组件销毁完成调用</td></tr></tbody></table><h2 id="vue数据挂载在哪个生命周期" tabindex="-1">vue数据挂载在哪个生命周期 <a class="header-anchor" href="#vue数据挂载在哪个生命周期" aria-label="Permalink to &quot;vue数据挂载在哪个生命周期&quot;">​</a></h2><p>看实际情况，一般在created(或者BeforeRouter)里面就可以，如果涉及到需要页面加载完成之后的话用mounted 在created时，视图中的html并没有渲染出来，此时如果直接操作dom节点一定找不到相关元素，而在mounted中html渲染出来了可以直接操作dom</p><h2 id="vue的data为什么要return" tabindex="-1">vue的data为什么要return <a class="header-anchor" href="#vue的data为什么要return" aria-label="Permalink to &quot;vue的data为什么要return&quot;">​</a></h2><p>其实就是一个作用域的问题，在自己的组件中可以访问，别的组件访问不到。 在vue中，data必须是一个函数且返回一个对象，这是因为在vue中每一个组件都是一个单独的实例，如果data是一个对象那么所有的组件都会共享这个data对象</p><h2 id="axios的拦截响应怎么做" tabindex="-1">axios的拦截响应怎么做 <a class="header-anchor" href="#axios的拦截响应怎么做" aria-label="Permalink to &quot;axios的拦截响应怎么做&quot;">​</a></h2><p>拦截：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">axios</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">interceptors</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">response</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">use</span><span style="color:#A6ACCD;">(</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">response</span><span style="color:#89DDFF;">){</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">//拦截操作</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">response</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">err</span><span style="color:#89DDFF;">){</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">//对响应错误进行处理</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#FFCB6B;">Promise</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">reject</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">err</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">)</span></span></code></pre></div><p>全局拦截：对所有的axios获取数据时都拦截 特定拦截：当需要对特定的请求进行拦截时，可以通过<code>axios.creat()</code>创建一个axios实例，用这个实例对特定请求进行拦截</p><h2 id="组件通讯的方式" tabindex="-1">组件通讯的方式 <a class="header-anchor" href="#组件通讯的方式" aria-label="Permalink to &quot;组件通讯的方式&quot;">​</a></h2><table><thead><tr><th style="text-align:left;">方式</th><th style="text-align:center;">Vue2</th><th style="text-align:center;">Vue3</th></tr></thead><tbody><tr><td style="text-align:left;">父传子</td><td style="text-align:center;">props</td><td style="text-align:center;">props</td></tr><tr><td style="text-align:left;">子传父</td><td style="text-align:center;">$emit</td><td style="text-align:center;">emits</td></tr><tr><td style="text-align:left;">父传子</td><td style="text-align:center;">$attrs</td><td style="text-align:center;">attrs</td></tr><tr><td style="text-align:left;">子传父</td><td style="text-align:center;">$listeners</td><td style="text-align:center;">无(合并到 attrs方式)</td></tr><tr><td style="text-align:left;">父传子</td><td style="text-align:center;">provide/inject</td><td style="text-align:center;">provide/inject</td></tr><tr><td style="text-align:left;">子组件访问父组件</td><td style="text-align:center;">$parent</td><td style="text-align:center;">无</td></tr><tr><td style="text-align:left;">父组件访问子组件</td><td style="text-align:center;">$children</td><td style="text-align:center;">无</td></tr><tr><td style="text-align:left;">父组件访问子组件</td><td style="text-align:center;">$ref</td><td style="text-align:center;">expose&amp;ref</td></tr><tr><td style="text-align:left;">兄弟组件传值</td><td style="text-align:center;">EventBus</td><td style="text-align:center;">mitt</td></tr></tbody></table><p>attrs :它包含了父组件在使用子组件时传递给子组件的所有非 props 属性。 expose：子组件通过expose把需要暴露出来的属性暴露出来，父组件通过inject接收</p><h2 id="vuex的五大部分" tabindex="-1">vuex的五大部分 <a class="header-anchor" href="#vuex的五大部分" aria-label="Permalink to &quot;vuex的五大部分&quot;">​</a></h2><ol><li>State（状态）：State 是应用程序的中央数据存储库，代表了应用程序的整体状态。</li><li>Mutation（变更）：Mutation 是修改 State 的唯一途径。</li><li>Action（动作）：Action 类似于 Mutation，不同之处在于 Action 是用于执行异步操作或批量的 Mutation。</li><li>Getter（获取器）：Getter 用于从 State 中派生出一些衍生状态，类似于组件中的计算属性。</li><li>Module（模块）：Module 可以将 Store 分割成多个小模块，每个模块都有自己的 State、Mutation、Action、Getter，并且可以嵌套子模块。</li></ol><h2 id="pinia" tabindex="-1">pinia <a class="header-anchor" href="#pinia" aria-label="Permalink to &quot;pinia&quot;">​</a></h2><ol><li>store</li><li>State（状态）</li><li>Actions（动作）</li><li>Getters（获取器） Mutations没有了，用this获取数据</li></ol><p>在 Pinia 中，this.$patch 是一个用于修改状态的特殊方法。它允许你以更简洁的方式更新状态，而不需要显式地编写一个 mutations 方法。</p><h2 id="computed和watch区别" tabindex="-1">computed和watch区别 <a class="header-anchor" href="#computed和watch区别" aria-label="Permalink to &quot;computed和watch区别&quot;">​</a></h2><p>Watch适用于需要在属性变化时执行异步或开销较大的操作的场景。你可以监视一个或多个属性，并在属性变化时执行特定的操作</p><p>Computed属性是基于它们的依赖进行缓存的，只有当依赖发生变化时，才会重新计算。在模板中使用Computed属性时，你可以像使用普通属性一样获取它们的值，而无需编写计算逻辑。</p><h2 id="组件的技术选型你应该怎么考虑" tabindex="-1">组件的技术选型你应该怎么考虑 <a class="header-anchor" href="#组件的技术选型你应该怎么考虑" aria-label="Permalink to &quot;组件的技术选型你应该怎么考虑&quot;">​</a></h2><h2 id="data是个什么格式的" tabindex="-1">data是个什么格式的 <a class="header-anchor" href="#data是个什么格式的" aria-label="Permalink to &quot;data是个什么格式的&quot;">​</a></h2><h2 id="你的前端是怎么学的-系统学过吗" tabindex="-1">你的前端是怎么学的 系统学过吗 <a class="header-anchor" href="#你的前端是怎么学的-系统学过吗" aria-label="Permalink to &quot;你的前端是怎么学的 系统学过吗&quot;">​</a></h2>`,24),r=[s];function o(i,d,c,p,y,u){return e(),a("div",null,r)}const g=t(n,[["render",o]]);export{x as __pageData,g as default};
