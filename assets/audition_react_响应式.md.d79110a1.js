import{_ as e,o as t,c as a,U as r}from"./chunks/framework.afdf1834.js";const f=JSON.parse('{"title":"响应式","description":"","frontmatter":{},"headers":[],"relativePath":"audition/react/响应式.md","filePath":"audition/react/响应式.md","lastUpdated":null}'),o={name:"audition/react/响应式.md"},i=r('<h1 id="响应式" tabindex="-1">响应式 <a class="header-anchor" href="#响应式" aria-label="Permalink to &quot;响应式&quot;">​</a></h1><h2 id="react、vue的响应式原理" tabindex="-1">react、vue的响应式原理 <a class="header-anchor" href="#react、vue的响应式原理" aria-label="Permalink to &quot;react、vue的响应式原理&quot;">​</a></h2><ul><li>从底层实现来看修改数据：在react中，组件的状态是不能被修改的，setState没有修改原来那块内存中的变量，而是去新开辟一块内存； 而vue则是直接修改保存状态的那块原始内存。</li><li>数据修改了，接下来要解决视图的更新：react中，调用setState方法后，会自顶向下重新渲染组件，自顶向下的含义是，<code>该组件以及它的子组件全部需要渲染</code>；而vue使用Object.defineProperty（vue@3迁移到了Proxy）对数据的设置（setter）和获取（getter）做了劫持，也就是说，<code>vue能准确知道视图模版中哪一块用到了这个数据</code>，并且在这个数据修改时，告诉这个视图，你需要重新渲染了。react的组件渲染是很消耗性能的——父组件的状态更新了，所有的子组件得跟着一起渲染，它不能像vue一样，精确到当前组件的粒度。</li></ul><h2 id="每次的视图更新流程是这样的" tabindex="-1">每次的视图更新流程是这样的： <a class="header-anchor" href="#每次的视图更新流程是这样的" aria-label="Permalink to &quot;每次的视图更新流程是这样的：&quot;">​</a></h2><ul><li>组件渲染生成一棵新的虚拟dom树；</li><li>新旧虚拟dom树对比，找出变动的部分；（也就是常说的diff算法）</li><li>为真正改变的部分创建真实dom，把他们挂载到文档，实现页面重渲染；</li></ul>',5),c=[i];function l(d,n,s,_,u,h){return t(),a("div",null,c)}const p=e(o,[["render",l]]);export{f as __pageData,p as default};
