import{_ as e,o as l,c as a,U as i}from"./chunks/framework.afdf1834.js";const b=JSON.parse('{"title":"项目","description":"","frontmatter":{},"headers":[],"relativePath":"audition/js/项目.md","filePath":"audition/js/项目.md","lastUpdated":null}'),o={name:"audition/js/项目.md"},t=i('<h1 id="项目" tabindex="-1">项目 <a class="header-anchor" href="#项目" aria-label="Permalink to &quot;项目&quot;">​</a></h1><h2 id="组件时怎么封装的" tabindex="-1">组件时怎么封装的 <a class="header-anchor" href="#组件时怎么封装的" aria-label="Permalink to &quot;组件时怎么封装的&quot;">​</a></h2><ol><li>先把组件样式写好，然后为每个组件配置一个公共代码，定义一个方法组建作为参数传入，内部为组件添加install函数，并且通过app.component注册组件，在通过export导出</li><li>创建一个声明文件，作用是为了让组件有属性提示</li></ol><h2 id="表单样式" tabindex="-1">表单样式 <a class="header-anchor" href="#表单样式" aria-label="Permalink to &quot;表单样式&quot;">​</a></h2><p>表单输入框，常规，禁用，尺寸，一键清空，密码显示隐藏，带icon图标，文本域自适应宽高，复合型输入框</p><ol><li>Input组件的核心功能:双向数据绑定,原生input的v-model其实就是<code>:value @input</code>结合的语法糖。而在 vue3 组件中使用v-model则表示的是<code>:modelValue @update:modelValue</code>的语法糖。</li><li><strong>双向数据绑定</strong>：子组件通过父组件定义的<code>:modelValue</code>接收值传给原生input的<code>:value</code>，通过原生input的<code>@input</code>给子组件<code>update:modelValue</code>传值传给父组件，这样就实现了数据双向绑定</li><li>常规，禁用，尺寸通过计算属性来更改类名</li><li>使用<code>useAttrs</code>来继承原生input的属性</li><li>一键清空通过<code>update:modelValue</code>给父组件传一个空值</li><li>密码框： <ol><li>这里通过ref拿到了原生input的dom实例，当父组件给子组件传一个showpassword时，给input的type赋值为password，这里通过promise.then放进微任务中，确保在更新 showPassword 的值后，下一轮事件循环开始之前再次访问 ipt.value.type 进行类型的切换。</li><li>showPassword 的值发生变化时，Vue.js 的响应式更新是异步的，Vue.js 尚未对模板进行重新渲染，因此 ipt.value.type 的初始类型仍然是 &quot;text&quot;。通过将设置密码框类型的逻辑放入微任务队列中，可以确保在下一轮事件循环开始之前进行密码框类型的切换。</li><li>这种做法可以避免在<strong>同一轮事件循环中执行密码框类型切换的逻辑</strong>，从而确保正确的初始密码框类型。如果在同一轮事件循环中意味着在切换密码框类型之后，模板中对应的元素可能仍然是使用旧的类型进行渲染，从而无法立即反映出切换后的效果。</li></ol></li><li>带icon图标，注意icon放在后面时要用计算属性做一个判断，因为会与一键清空，密码显示隐藏图标冲突</li><li>复合型输入框，具名插槽做的</li><li>文本域自适应高度，比较复杂，通过创建一个虚拟文本域，通过window.getComputedStyle(获取原生css对象),getPropertyValue(获取css属性值)，把当前文本域的属性和值赋给虚拟文本域，通过计算虚拟文本域的<code>scrollhight</code>总高度,来计算真实文本域高度这里要判断<code>boxsizing</code>是<code>borderbox</code>还是<code>contentbox</code>,如果是borderbox，高度要加上<code>上下boreder的高度</code>,如果是<code>contentbox</code>高度要减去<code>上下padding的高度</code>，然后清空虚拟文本域计算单行行高，设置最小行数的高度和最大行数的高度，最后把虚拟文本域移除</li></ol><h2 id="glup打包样式文件" tabindex="-1">glup打包样式文件 <a class="header-anchor" href="#glup打包样式文件" aria-label="Permalink to &quot;glup打包样式文件&quot;">​</a></h2><p>因为vite打包样式文件是会把所有的组件的样式合并到一个css文件中，每次都要全部引入所有的样式文件，做不到按需加载，样式文件将使用 gulp 进行打包</p><h2 id="为什么选择gulp" tabindex="-1">为什么选择gulp <a class="header-anchor" href="#为什么选择gulp" aria-label="Permalink to &quot;为什么选择gulp&quot;">​</a></h2><p>gulp很方便，不仅仅是打包css文件，经常用的一个series和parallel定义执行任务顺序执行并行执行，比如说打包时先删除之前的打包文件再打包，可以用series规定执行顺序，样式打包和组件打包通过parallel并行执行</p><h2 id="ts用在哪些方面" tabindex="-1">ts用在哪些方面 <a class="header-anchor" href="#ts用在哪些方面" aria-label="Permalink to &quot;ts用在哪些方面&quot;">​</a></h2><p>在组件库上ts主要用来写打包的配置文件，执行命令的函数，删除之前的打包文件函数，获取路径的函数，在js的基础上声明了变量</p><h2 id="axios怎么进行二次封装的" tabindex="-1">axios怎么进行二次封装的 <a class="header-anchor" href="#axios怎么进行二次封装的" aria-label="Permalink to &quot;axios怎么进行二次封装的&quot;">​</a></h2><p>把api放在一个文件，把请求的地址放在一个文件，写了一个配置文件，在里面重新定义了各种请求错误信息，和一个timeout，和一个获取数据之前的拦截器</p><h2 id="怎么用的pinia" tabindex="-1">怎么用的pinia <a class="header-anchor" href="#怎么用的pinia" aria-label="Permalink to &quot;怎么用的pinia&quot;">​</a></h2><p>pinia里存放了一个data是一个空数组，用来存放从服务器拿到的数据，在pinia的配置文件里写项目要用到的actions（方法）和getters（获取器），actions写一些复杂的逻辑和异步逻辑</p><h2 id="node-js构建的后端服务器怎么写的" tabindex="-1">Node.js构建的后端服务器怎么写的 <a class="header-anchor" href="#node-js构建的后端服务器怎么写的" aria-label="Permalink to &quot;Node.js构建的后端服务器怎么写的&quot;">​</a></h2><p>用的express写的一些get、post等请求，通过中间件设置了querystring模块来解析请求体，设置了允许跨域的响应头</p><h2 id="前后端分离" tabindex="-1">前后端分离 <a class="header-anchor" href="#前后端分离" aria-label="Permalink to &quot;前后端分离&quot;">​</a></h2><ul><li>并行开发：前后端分离允许前端和后端团队并行开发，不受彼此的依赖关系限制。这可以显著加快整个开发过程，提高团队的效率。</li><li>更好的扩展性：由于前后端分离的松耦合性，您可以更容易地扩展和升级应用程序的不同部分。例如，您可以独立扩展前端服务器或后端 API，而无需重新编写整个应用程序。</li><li>更好的可维护性：前后端分离使代码更模块化，更易于理解和维护。前端和后端团队可以专注于各自的领域，通过清晰的接口定义和规范化的开发流程，减少代码冲突和问题。</li><li>跨平台开发：前后端分离可以为不同的客户端提供服务，如 Web 应用、移动应用和其他第三方集成。通过提供统一的后端 API，不同平台可以共享相同的业务逻辑和数据处理功能。</li><li>更好的用户体验：前后端分离可以通过前端技术的灵活性和交互性，提供更丰富、动态和响应式的用户界面。这可以改善用户体验并提高用户满意度。</li></ul><h2 id="http23" tabindex="-1">http23 <a class="header-anchor" href="#http23" aria-label="Permalink to &quot;http23&quot;">​</a></h2><p>HTTP/2：</p><ul><li>HTTP/2是HTTP/1.1的升级版本，于2015年发布。它引入了一些重要的改进，其中最显著的是多路复用（multiplexing）功能。</li><li>多路复用允许在单个TCP连接上同时发送多个请求和响应，从而提高性能并减少延迟。这对于加载复杂网页或处理大量资源请求时特别有用。</li><li>HTTP/2还引入了头部压缩（header compression）和服务器推送（server push）等功能，以减少数据传输量和提高效率。</li></ul><p>HTTP/3：</p><ul><li>HTTP/3是HTTP协议的下一代版本，目前还处于实验阶段，预计基于QUIC（Quick UDP Internet Connections）协议。</li><li>QUIC是基于UDP协议的传输协议，相较于基于TCP的HTTP/2，QUIC在网络层上提供更好的性能和连接管理能力。</li><li>HTTP/3的一个重要特性是使用QUIC代替了TCP作为传输层协议。QUIC通过减少连接建立时间、降低丢包重传延迟等优化，提供更快的数据传输和更可靠的连接。</li><li>HTTP/3旨在进一步提升性能、降低延迟，并解决某些网络环境下TCP存在的一些问题，如丢包恢复速度慢、拥塞控制等。</li></ul><h2 id="https-mitm" tabindex="-1">https mitm <a class="header-anchor" href="#https-mitm" aria-label="Permalink to &quot;https mitm&quot;">​</a></h2><p>在HTTPS通信中，中间人攻击（Man-in-the-Middle Attack，缩写为MITM攻击）是一种攻击方式，攻击者试图在通信双方之间插入自己以截获、篡改或窃取通信内容。</p><p>正常的HTTPS通信是经过加密和身份验证的，基于使用公钥加密的SSL/TLS协议来确保通信的安全性和完整性。然而，中间人攻击利用了攻击者能够截取和篡改通信流量的位置，以破坏通信的安全性。</p><h2 id="静态资源缓存" tabindex="-1">静态资源缓存 <a class="header-anchor" href="#静态资源缓存" aria-label="Permalink to &quot;静态资源缓存&quot;">​</a></h2><p>配置资源文件的缓存可以通过使用HTTP响应头中的Cache-Control和Expires字段来实现。这些字段可以告诉客户端（浏览器）如何缓存和重新获取资源文件。</p><p>使用Cache-Control字段：</p><ul><li><code>Cache-Control: max-age=&lt;seconds&gt;</code>：指定资源文件在被认为是新鲜（未过期）之前的最长时间（以秒为单位）。例如，Cache-Control: max-age=3600表示资源文件将被缓存1小时。</li><li><code>Cache-Control: no-cache</code>：指示客户端在每次请求时都必须向服务器验证资源的有效性，但仍然可以缓存资源文件。</li><li><code>Cache-Control: no-store</code>：指示客户端不应缓存资源文件，并且每次都必须从服务器获取最新的文件副本。</li></ul><p>使用Expires字段：</p><ul><li><code>Expires: &lt;date&gt;</code>：指定资源文件过期的日期和时间。例如，Expires: Wed, 12 May 2023 08:00:00 GMT表示资源文件将在指定日期之后过期。</li><li>推荐的做法是结合使用Cache-Control和Expires字段，以提供更好的缓存控制和兼容性。</li></ul><h2 id="layout-shift-布局偏移" tabindex="-1">layout shift 布局偏移 <a class="header-anchor" href="#layout-shift-布局偏移" aria-label="Permalink to &quot;layout shift 布局偏移&quot;">​</a></h2><p>布局偏移（Layout Shift）是指在网页加载过程中，元素的位置发生了突然而意外的变化，可能会导致用户体验的不良影响。这种突然的变化可能会使用户点击错位或产生其他交互问题，影响网页的可用性和可读性。</p><ul><li>明确指定资源尺寸：在网页中为图像、视频和其他资源指定明确的尺寸，可以在加载前为它们保留空间，避免布局偏移。</li><li>预加载字体：使用preload标签或CSS中的@font-face规则，提前加载字体文件，确保字体在应用前已经准备就绪。</li><li>使用占位符：在资源加载完成之前，使用占位符或固定尺寸的元素来预留空间，以避免后续内容加载时的布局偏移。</li><li>使用动画和过渡：如果有元素在网页加载后需要进行动画或过渡效果，尽量使用 CSS 动画或过渡，以平滑地过渡，避免突然的布局变化。</li><li>避免动态内容：尽量避免在页面加载后动态插入或移除内容，或者在动态内容加载前预留足够的空间。</li></ul><h2 id="优化跨端应用性能" tabindex="-1">优化跨端应用性能 <a class="header-anchor" href="#优化跨端应用性能" aria-label="Permalink to &quot;优化跨端应用性能&quot;">​</a></h2><p>代码优化：</p><ul><li>选择高效的框架和库：选择经过优化和性能良好的框架和库，以确保代码执行效率和响应速度。</li><li>减少重绘和回流：避免频繁的DOM操作，合并多个操作，减少页面重绘和回流，提高性能。</li><li>优化网络请求：减少网络请求次数，使用压缩和缓存等技术来优化网络传输。</li><li>懒加载和按需加载：只在需要时加载资源，如图片、脚本和样式，以减少初始加载时间。</li></ul><p>图像和媒体优化：</p><ul><li>图像压缩：使用适当的图像压缩算法和工具，减少图像文件的大小，提高加载速度。</li><li>响应式图片：根据设备和屏幕大小，使用合适的图像尺寸和分辨率，避免不必要的图像加载。</li><li>视频流优化：使用流式视频传输，根据网络速度和设备性能动态调整视频质量。</li></ul><p>缓存策略：</p><ul><li>使用浏览器缓存：设置合适的缓存头部，利用浏览器缓存来存储静态资源，减少重复请求。</li><li>数据缓存：合理缓存数据，减少对后端接口的请求次数，提高数据加载速度。</li></ul><p>响应式设计和布局优化：</p><ul><li>自适应布局：使用响应式设计，根据不同设备和屏幕大小，自动适应布局和样式。</li><li>优化CSS和布局：减少CSS文件的大小，使用合适的选择器和样式规则，避免过度嵌套和复杂的布局结构。</li></ul><p>性能监测和优化：</p><ul><li>使用性能分析工具：使用工具如Chrome开发者工具、Lighthouse等来分析和监测应用的性能指标，发现潜在的性能瓶颈并进行优化。</li><li>定期优化和更新：持续监测应用的性能，定期进行优化和更新，以适应不断变化的平台和设备环境。</li></ul><h2 id="webgpu" tabindex="-1">webgpu <a class="header-anchor" href="#webgpu" aria-label="Permalink to &quot;webgpu&quot;">​</a></h2><p>WebGPU是一种新兴的Web标准，旨在为Web开发者提供直接访问图形硬件的低级别图形编程接口。它是WebGL的继任者，旨在提供更高效、更可编程和更现代化的图形处理能力。</p><h2 id="pnpm和npm" tabindex="-1">pnpm和npm <a class="header-anchor" href="#pnpm和npm" aria-label="Permalink to &quot;pnpm和npm&quot;">​</a></h2><p>而pnpm使用<strong>硬链接技术</strong>，跳过了解压的过程</p><ol><li>速度</li><li>空间占用</li><li>并发安装</li><li>pnpm使用一种称为&quot;<strong>锁定文件链接</strong>&quot;的机制，将项目的依赖版本信息存储在单独的pnpm-lock.yaml文件中，从而更好地管理依赖版本。</li><li>可靠性</li></ol><h2 id="monorepo" tabindex="-1">monorepo <a class="header-anchor" href="#monorepo" aria-label="Permalink to &quot;monorepo&quot;">​</a></h2><p>Monorepo（单一代码仓库）是一种软件开发模式，它将多个相关的项目或组件放置在同一个代码仓库中管理</p><ol><li>Lerna</li><li>Yarn Workspaces</li></ol>',56),r=[t];function n(p,s,d,h,c,u){return l(),a("div",null,r)}const P=e(o,[["render",n]]);export{b as __pageData,P as default};
