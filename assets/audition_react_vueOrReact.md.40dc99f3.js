import{_ as e,o as a,c as t,U as r}from"./chunks/framework.afdf1834.js";const f=JSON.parse('{"title":"react和vue区别","description":"","frontmatter":{},"headers":[],"relativePath":"audition/react/vueOrReact.md","filePath":"audition/react/vueOrReact.md","lastUpdated":null}'),o={name:"audition/react/vueOrReact.md"},c=r('<h1 id="react和vue区别" tabindex="-1">react和vue区别 <a class="header-anchor" href="#react和vue区别" aria-label="Permalink to &quot;react和vue区别&quot;">​</a></h1><h2 id="核心思想" tabindex="-1">核心思想 <a class="header-anchor" href="#核心思想" aria-label="Permalink to &quot;核心思想&quot;">​</a></h2><p>vue：进行数据拦截、代理，对侦测数据的变化更敏感，更精确 React：推崇函数式编程，数据不可变</p><h2 id="响应式原理不同" tabindex="-1">响应式原理不同 <a class="header-anchor" href="#响应式原理不同" aria-label="Permalink to &quot;响应式原理不同&quot;">​</a></h2><p>vue：vue则是直接修改保存状态的那块原始内存，vue用defineproperty和proxy对数据进行劫持，<code>vue能准确知道视图模版中哪一块用到了这个数据</code>，可以自动找到引用组件进行渲染 react：在react中，组件的状态是不能被修改的，setState没有修改原来那块内存中的变量，而是去新开辟一块内存，<code>该组件以及它的子组件全部需要渲染</code>，需要额外的方法避免</p><h2 id="语法" tabindex="-1">语法 <a class="header-anchor" href="#语法" aria-label="Permalink to &quot;语法&quot;">​</a></h2><p>vue：模板语法+指令，简单易懂 react：jsx+inlinestyle相对复杂</p><h2 id="diff" tabindex="-1">diff <a class="header-anchor" href="#diff" aria-label="Permalink to &quot;diff&quot;">​</a></h2><p>vue：双端比较，最长递增子序列 react：从左到右依次对比，最后一个放到最前面，会把前面的节点依次移动</p><h2 id="vuex和redux" tabindex="-1">vuex和redux <a class="header-anchor" href="#vuex和redux" aria-label="Permalink to &quot;vuex和redux&quot;">​</a></h2><p>redux：数据不可变，新state替换旧state vuex：数据可变，直接修改</p>',11),d=[c];function i(u,n,s,l,h,_){return a(),t("div",null,d)}const v=e(o,[["render",i]]);export{f as __pageData,v as default};
