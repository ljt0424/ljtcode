const t={map:'[{"ajax":["0.0","0.2","19.49"],"什么是ajax":["0.1"],"json字符串转换集json对象":["0.3"],"ajax几种请求方式":["0.4"],"什么情况造成跨域":["0.5"],"跨域解决方案有哪些":["0.6"],"使用axios怎么中止请求":["0.7"],"axios的请求响应拦截":["0.8"],"axios封装":["0.9"],"axios取消请求":["0.10"],"css":["1.0","5.11","56.6"],"清除浮动":["1.2"],"自适应布局rem":["1.10"],"flex":["1.13","1.14","1.15","1.16"],"clip":["1.23","85.8"],"行内元素和块元素":["1.24"],"text":["1.25"],"对齐":["1.26"],"动画":["1.27"],"响应式布局rem和em":["1.28"],"css选择器排序":["1.29","56.16"],"属性选择器和伪类选择器":["1.30"],"伪元素选择器":["1.31"],"继承属性":["1.32"],"响应式布局":["1.33"],"如果要做优化":["1.34"],"媒体查询工作原理":["1.35"],"盒模型":["2.3"],"指定盒模型的类型":["2.5"],"媒体查询":["2.9"],"es6":["3.0"],"定义":["3.2"],"用法":["3.3"],"默认导出与默认导入注意点":["3.4"],"按需导入与按需导出注意点":["3.5"],"generator":["3.14"],"es6新增":["3.15"],"js新增简单数据类型symbol":["4.0"],"dom":["5.0","5.2"],"什么是dom":["5.1"],"javascript和css会不会影响dom树构建和渲染":["5.3"],"javascript对dom树构建和渲染的影响":["5.4"],"规避javascript线程阻塞dom现象":["5.5"],"domcontentloaded":["5.6"],"dom文档加载的步骤为":["5.7"],"网页的渲染":["5.8"],"dom树的构建是文档加载完成开始的":["5.9"],"render":["5.10"],"js":["5.12","19.11"],"virtual":["5.13","5.14"],"vue的virtual":["5.15"],"vnode":["5.16"],"dom常用接口":["5.17"],"document":["5.18"],"常用属性":["5.19","5.25","5.27"],"element":["5.20"],"dom元素对象属性":["5.21"],"dom常见的操作有哪些":["5.22"],"window":["5.23"],"常用方法":["5.24","5.28"],"event":["5.26"],"html八股文":["6.0"],"重绘":["6.12"],"避免重排重绘":["6.13"],"触发合成层":["6.15"],"层压缩":["6.16"],"层爆炸":["6.17"],"为什么要语义化":["6.19"],"iframe":["6.20"],"seo":["7.0"],"什么是seo":["7.1"],"优化的三要素":["7.2"],"tdk是搜索引擎判断页面主题内容的关键":["7.3"],"提升页面关键词密度":["7.4"],"细枝末节但不可忽视的优化":["7.5"],"w3c标准":["8.0"],"概念":["8.1"],"体现":["8.2"],"意义":["8.3"],"http":["9.0","15.1"],"http概述":["9.1"],"http特点":["9.2"],"tcp":["9.3","9.32","53.5"],"tcp阻塞":["9.4"],"http与https的区别":["9.5"],"ssl":["9.6"],"对称加密":["9.7"],"非对称加密":["9.8"],"http1":["9.9"],"多路复用":["9.10"],"头部压缩":["9.11"],"服务器推送":["9.12"],"cdn":["9.13","53.21"],"url的组成":["9.14"],"http请求":["9.15"],"请求行":["9.16"],"get与post的区别":["9.17"],"什么情况下使用post请求":["9.18"],"请求头":["9.19"],"请求体":["9.20"],"http响应":["9.21"],"响应状态行":["9.22"],"常见状态码":["9.23"],"响应头":["9.24"],"浏览器输入url按回车背后经历了哪些":["9.25"],"url":["9.26"],"dns":["9.27"],"计算机网络五层七层协议":["9.28"],"处理请求":["9.29"],"浏览器收到http响应":["9.30"],"渲染页面":["9.31"],"三次握手":["9.33"],"四次挥手":["9.34"],"ip":["9.35"],"tcp和udp":["9.36"],"http无状态的协议":["9.37"],"cookie":["9.38","30.10"],"进程和线程":["9.39"],"安全":["10.0"],"xss":["10.1"],"web安全有哪些方面":["10.2"],"csrf和xss":["10.3"],"csrf":["10.4"],"防范":["10.5","10.6"],"sql注入":["10.7"],"javase":["11.0"],"jdk":["11.1"],"面向对象的特性":["11.2"],"基本数据类型":["11.3"],"为什么不能用浮点型表示金额":["11.4"],"了解java的包装类型吗":["11.5"],"自动装箱和拆箱":["11.6"],"string":["11.7","11.8"],"new":["11.9","65.2"],"什么是字符串常量池":["11.10"],"两个对象的hashcode":["11.11"],"static":["11.12","34.7"],"main":["11.13"],"继承extends":["11.14"],"权限修饰符":["11.15"],"final":["11.16"],"抽象类":["11.17"],"接口":["11.18","42.18"],"接口和类的关系":["11.19"],"抽象类和接口的对比":["11.20"],"多态":["11.21"],"多态的转型":["11.22"],"代码块":["11.23"],"内部类":["11.24"],"bigdecimal":["11.25"],"正则匹配":["11.26"],"throws":["11.28"],"maven":["12.0"],"生命周期":["12.1"],"mybatis":["13.0"],"数据库连接池":["13.1"],"xml命名规范":["13.2"],"动态sql":["13.3"],"mysql":["14.0"],"sql语句被分为四大类":["14.1"],"ddl":["14.2"],"常见数据类型":["14.3"],"dml语法":["14.4"],"dql":["14.5"],"dql基本查询":["14.6"],"where和having的区别":["14.7"],"执行顺序":["14.8","34.19"],"排序查询":["14.9"],"分页查询":["14.10","18.4"],"多表":["14.11"],"多表查询":["14.12"],"多表查询案例":["14.13"],"事务":["14.14"],"索引":["14.15"],"sringboot":["15.0"],"解耦":["15.2"],"aop":["15.3"],"aop通知的类型":["15.4"],"aop通知的顺序":["15.5"],"spring获取bean对象":["15.6"],"springboot原理":["15.7"],"线程":["17.0"],"什么是线程":["17.1"],"什么是进程":["17.2"],"并发":["17.3"],"并行":["17.4"],"线程的优先级":["17.5"],"守护线程setdeamon":["17.6"],"线程的生命周期":["17.8"],"java线程安全是什么":["17.9"],"确保线程安全常见的方式":["17.10"],"原子操作":["17.11"],"同步代码块":["17.12"],"同步方法":["17.13"],"stringbuilder和stringbuffer":["17.14"],"lock锁":["17.15"],"死锁":["17.16"],"生产者消费者":["17.17"],"线程池":["17.18"],"线程池多大合适":["17.19"],"总结":["18.0","85.12"],"slf4j":["18.1"],"请求方式":["18.2"],"操作":["18.3","30.4"],"javascript八股文":["19.0"],"js为什么是单线程的":["19.1"],"async":["19.6"],"defer":["19.7"],"不同":["19.8"],"立即执行函数是闭包":["19.9"],"class类的函数默认是严格模式":["19.10"],"eventloop事件循环":["19.12"],"同步异步":["19.13"],"宏任务和微任务":["19.14"],"settimeout的误区":["19.15"],"nexttick":["19.16"],"队列执行顺序":["19.17"],"深拷贝浅拷贝":["19.18"],"深拷贝":["19.19","59.3"],"浅拷贝":["19.20"],"赋值和浅拷贝的区别":["19.21"],"闭包":["19.22","57.0"],"内存泄漏":["19.23"],"内存的生命周期":["19.24"],"垃圾回收机制":["19.25"],"执行上下文":["19.26","19.77"],"isnan":["19.27"],"hasownproperty":["19.28"],"valueof":["19.30"],"javascript变量在内存中具体存储形式":["19.31"],"javascript的装箱和拆箱":["19.32"],"装箱":["19.33"],"拆箱":["19.34"],"null和undefined的异同点有哪些":["19.35"],"为什么typeof":["19.36"],"与":["19.37"],"javascript的隐式转换规则":["19.38"],"双等号左右两边的转换规则":["19.39"],"undefined":["19.40"],"null":["19.41"],"为什么是":["19.42"],"什么是匿名函数":["19.44"],"绑定点击事件有几种方式":["19.45"],"addeventlistener的第三个参数是干嘛的":["19.46"],"函数声明和函数表达式的区别":["19.47"],"javascript的事件流模型有哪些":["19.48"],"load":["19.50"],"如何阻止事件冒泡":["19.51"],"如何阻止事件默认行为":["19.52"],"什么是事件委托":["19.53"],"如何实现数组去重":["19.54"],"nan是什么":["19.55"],"javascript继承方式有几种":["19.56"],"class继承super":["19.57"],"数组常用方法":["19.58"],"math的常用方法有哪些":["19.59"],"js中有哪些不同类型的弹出框":["19.60"],"如何将":["19.61"],"如何在js中编码和解码":["19.62"],"什么是bom":["19.63"],"bom":["19.64"],"js中的substr":["19.65"],"substr":["19.66"],"substring":["19.67"],"解释一下":["19.68"],"input标签":["19.69"],"属性":["19.70"],"arguements":["19.71"],"类数组转数组方法":["19.72"],"for":["19.73"],"可迭代对象":["19.74"],"new的过程":["19.75"],"事件处理函数event":["19.76"],"执行栈":["19.78"],"object":["20.0","20.1","20.2","20.3","20.4","20.5","20.7","20.8","20.9","20.10","20.11","20.13","20.14","20.16","20.17","20.18","20.19","20.20","20.21","20.22","20.23","20.24","20.25","20.26","20.27","20.28","20.29","20.30","20.31","22.10","44.41","45.7","85.3"],"语法":["20.6","20.12","39.3"],"instanceof":["20.15"],"promise":["21.0","60.0","61.1"],"reject和catch":["21.1"],"promise的状态":["21.2"],"resolve不同值的区别":["21.3"],"promise的实例方法":["21.4"],"then方法":["21.5"],"catch方法":["21.6"],"finally方法":["21.7"],"promise中的类方法":["21.8"],"promise其他":["21.9"],"acync":["21.10"],"set":["22.0","22.1","22.2","22.3"],"转为数组":["22.4"],"所以set可以使用数组里的":["22.5"],"因此":["22.6"],"map":["22.7","22.9","45.30"],"属性方法":["22.8"],"weakmap":["22.11","45.31"],"this":["23.0"],"node环境和浏览器环境":["23.1"],"this方法":["23.2"],"this指向的四种情况":["23.3"],"apply":["23.4"],"运算符":["24.0"],"隐式转换":["24.2"],"优先级":["24.3"],"同域名下的单点登录":["25.0"],"不同域名下的单点登录":["25.1"],"数组":["26.0","42.1","75.0"],"数组的方法":["26.1"],"数组去重":["26.2","56.0","77.3"],"数组找一个值的方法":["26.3"],"entries":["26.4"],"copywithin":["26.5"],"javascript中的正则表达式":["27.0"],"项目":["28.0","51.0"],"组件时怎么封装的":["28.1"],"表单样式":["28.2"],"glup打包样式文件":["28.3"],"为什么选择gulp":["28.4"],"ts用在哪些方面":["28.5"],"axios怎么进行二次封装的":["28.6"],"怎么用的pinia":["28.7"],"node":["28.8","29.0","29.1","55.2"],"前后端分离":["28.9"],"http23":["28.10"],"https":["28.11"],"静态资源缓存":["28.12"],"layout":["28.13"],"优化跨端应用性能":["28.14"],"webgpu":["28.15"],"pnpm和npm":["28.16"],"monorepo":["28.17"],"两种模块的差异":["29.2"],"两种模块的区分":["29.3"],"加载":["29.4"],"同时支持两种格式的模块":["29.5"],"nodejs的内置模块":["29.6"],"process":["29.7"],"path":["29.8"],"fs":["29.9"],"node是单线程的怎么做高并发":["29.10"],"存储的时间有效期不同":["30.1"],"存储的大小不同":["30.2"],"与服务端的通信":["30.3"],"对于浏览器的支持":["30.5"],"token":["30.7"],"是用来干嘛的":["30.8"],"token存在哪里":["30.9"],"vite":["31.0","31.3","51.4"],"命令":["31.1"],"vite脚手架":["31.2"],"webpack":["32.0","32.1","32.8"],"mode":["32.2"],"entry":["32.3"],"output":["32.4"],"loader":["32.5"],"bable":["32.6"],"plugin":["32.7"],"devtool":["32.9"],"最全前端八股文":["33.0"],"基础知识":["34.0"],"react":["34.1","34.11","34.22","34.25","35.1","36.14","37.0","37.2","37.17","40.1"],"如何避免不必要的render":["34.2"],"请求数据的时机":["34.3"],"函数组件和类组件":["34.4"],"类组件的生命周期":["34.5"],"react17之后":["34.6"],"getsnapshotbeforeupdate":["34.8"],"有状态组件和无状态组件":["34.9"],"react的响应式原理":["34.10"],"为什么vue不用fiber":["34.12"],"react的事件机制":["34.13"],"react事件机制流程":["34.14"],"合成事件":["34.15"],"原生事件和合成事件是如何对应起来的":["34.16"],"listenerbank事件池":["34.17"],"react的事件和普通的html事件有什么不同":["34.18"],"react17":["34.20"],"react的高阶组件":["34.21"],"组件渲染的时机":["34.23"],"react可以在render阶段访问refs吗":["34.24"],"父子组件生命周期执行顺序":["34.26"],"高阶函数":["34.27"],"react中引入css的方式有哪几种":["34.28"],"在react中组件间过渡动画如何实现":["34.29"],"按功能组织":["34.30"],"react项目是如何捕获错误的":["34.31"],"diff":["35.0","39.4"],"vue2":["35.2","44.23","45.5","45.6","45.11","45.14","45.24"],"双端比较":["35.3"],"vue3":["35.4","45.16","45.17","45.19","45.20","45.21","45.22"],"快速diff":["35.5"],"说说react":["35.6"],"hook":["36.0"],"hooks解决了那些问题":["36.1"],"限制":["36.2"],"usestate":["36.3"],"传入":["36.4","38.1"],"关于setstate是同步还是异步的问题":["36.5","38.2"],"setstate":["36.6","38.0","38.3","38.4"],"useeffect":["36.7"],"uselayouteffect":["36.8"],"usecontext":["36.9"],"usecallback":["36.10"],"usecallback使用场景":["36.11"],"usememo":["36.12"],"usememo和usecallback区别":["36.13"],"memo":["36.15"],"useref":["36.16"],"ref函数组件中转发":["36.17"],"useimperativehandle":["36.18"],"usesyncexternalstore":["36.19"],"usetransition":["36.20"],"usedeferredvalue":["36.21"],"路由":["37.1"],"browserrouter":["37.3"],"route组件":["37.4","37.14"],"redirect":["37.5"],"switch":["37.6"],"四个钩子":["37.7"],"usehistory":["37.8"],"useparams":["37.9"],"uselocation":["37.10"],"useroutematch":["37.11"],"参数传递":["37.12"],"routes组件":["37.13"],"outlet组件":["37.15"],"usematch":["37.16"],"link和a的区别":["37.18"],"link":["37.19"],"react的state和props区别":["38.5"],"react的props的验证":["38.6"],"父组件props发生变化时调用的生命周期函数":["38.7"],"控制是否首次渲染":["38.8"],"react和vue区别":["39.0"],"核心思想":["39.1"],"响应式原理不同":["39.2"],"vuex和redux":["39.5"],"响应式":["40.0"],"每次的视图更新流程是这样的":["40.2"],"redux和vuex和pinia":["41.0"],"vuex的五大部分":["41.1","52.5"],"pinia":["41.2","44.34","52.6"],"redux":["41.3","41.7"],"store常用的方法":["41.4"],"多个reducer的redux用法":["41.5"],"redux的中间件":["41.6"],"第三方中间件":["41.8"],"自定义中间件":["41.9"],"函数柯里化":["41.10"],"typescript":["42.0"],"函数":["42.2"],"参数":["42.3"],"函数重载":["42.4"],"元组":["42.5"],"元祖类型的解构赋值":["42.6"],"void":["42.7"],"never":["42.8"],"any":["42.9"],"unknown":["42.10"],"类型推断":["42.12"],"类型断言":["42.13"],"非空断言":["42.14"],"确定赋值断言":["42.15"],"字面量类型":["42.16"],"let和const分析":["42.17"],"可选":["42.19"],"任意属性":["42.20"],"鸭式辨型法":["42.21"],"绕开额外属性检查的方式":["42.22"],"索引签名":["42.23"],"interface":["42.24"],"objects":["42.25"],"other":["42.26"],"接口可以定义多次":["42.27"],"扩展":["42.28"],"泛型":["42.29"],"泛型约束":["42.30"],"泛型工具":["42.32"],"vue":["43.0","43.1","43.2","43.11","44.0","44.53","45.0","53.26","55.3"],"如何实现":["43.3"],"hash模式":["43.4"],"history模式":["43.5"],"路由跳转方式有哪些":["43.6"],"说一下路由守卫":["43.7"],"完整的导航解析流程":["43.8"],"懒加载":["43.9"],"懒加载实现":["43.10"],"路由元信息":["43.12"],"数据获取":["43.13"],"vue路由的传参方式":["43.14"],"params和query":["43.15"],"对vue的理解":["44.1"],"单页面应用":["44.2"],"vue生命周期":["44.3"],"setup":["44.4"],"各自生命周期的事情":["44.5"],"vue父子组件生命周期":["44.6"],"注意":["44.7","46.4"],"v":["44.8","44.9","44.54","47.0","48.0","63.0","64.0"],"说一下computed和watch":["44.10"],"computed和methods的区别":["44.11"],"computed为什么是同步的":["44.12"],"computed和watch的区别":["44.13"],"computed和watch使用场景":["44.14"],"computed的原理":["44.15"],"computed的两种定义方式":["44.16"],"computed属性的初始化":["44.17"],"computed":["44.18"],"依赖收集的时机":["44.19"],"watch和watcheffect区别和用法":["44.20"],"vue2和vue3区别":["44.21"],"vue初始化阶段":["44.22"],"数组的改进":["44.24"],"vue插件使用":["44.25"],"vue插槽":["44.26"],"组件通信":["44.27"],"prosps":["44.28"],"emit":["44.29","44.52"],"attrs":["44.30"],"ref":["44.31"],"slot":["44.32","44.57"],"vuex":["44.33"],"调用其他store":["44.35"],"vue自定义指令":["44.36","46.0"],"keep":["44.37"],"activated":["44.38"],"deactivated":["44.39"],"vue2混入":["44.40"],"vue3内置组件":["44.42"],"teleport":["44.43"],"suspense组件":["44.44"],"nexttick及原理":["44.45"],"vue中的nexttick是干什么用的":["44.46"],"vue虚拟dom":["44.47"],"什么是虚拟dom":["44.48"],"说一下diff算法":["44.49"],"vue的diff流程":["44.50"],"props使用":["44.51"],"suspense":["44.55"],"ref和reactive区别":["44.56"],"vue的双向绑定和单向数据流冲突吗":["44.58"],"单双向绑定":["44.59"],"单向数据流":["44.60"],"spa首屏加载速度慢的怎么解决":["44.61"],"解决方案":["44.62"],"说下你的vue项目的目录结构":["44.63"],"vue使用css":["44.64"],"观察者模式和发布订阅模式":["45.1"],"什么是观察者模式":["45.2"],"什么是发布订阅模式":["45.3"],"vue2的响应式原理":["45.4"],"definereactive":["45.8"],"observe":["45.9"],"数组是怎么做到响应式的":["45.10"],"watcher和数据之间的关系":["45.12"],"watcher依赖的数据改变方式有":["45.13"],"dep怎么收集依赖的":["45.15"],"vue3的收集依赖":["45.18"],"副作用函数":["45.23"],"vue3响应式核心方法":["45.25"],"核心方法注意":["45.26"],"activeeffect和effect":["45.27"],"track函数":["45.28"],"trigger":["45.29"],"reactive":["45.32"],"reflect":["45.33"],"proxy和reflect":["45.34"],"什么是自定义指令":["46.1"],"自定义组件注册":["46.2"],"钩子函数":["46.3"],"指令的使用":["46.5"],"在":["46.6"],"常用自定义指令":["46.7"],"加油特种兵":["50.0"],"vxe":["50.1"],"jsx语法遍历":["50.2"],"getcheckboxrecords":["50.3"],"弹框子组件用v":["50.4"],"npm包管理器":["51.1"],"git":["51.2"],"vue2和vue3的区别":["51.3"],"vite的优势在哪":["51.5"],"请求可以取消吗":["51.6"],"代码题":["51.7"],"vue的生命周期":["52.0"],"vue数据挂载在哪个生命周期":["52.1"],"vue的data为什么要return":["52.2"],"axios的拦截响应怎么做":["52.3"],"组件通讯的方式":["52.4"],"computed和watch区别":["52.7","56.2"],"组件的技术选型你应该怎么考虑":["52.8"],"data是个什么格式的":["52.9"],"你的前端是怎么学的":["52.10"],"数组存储怎么压缩":["53.0"],"数据类型":["53.1"],"let":["53.2","85.13"],"settimeout和settineinterval哪个更准确":["53.3"],"事件循环":["53.4","56.15"],"http如何建立连接":["53.6"],"https如何防窃听和篡改":["53.7"],"promise状态":["53.8"],"vue怎么防止xss攻击":["53.9"],"vue如何渲染用户想要的自定义文本":["53.10"],"console":["53.11"],"手写题2":["53.12","53.29"],"手写题3":["53.13","53.30"],"手写题4":["53.14","59.9"],"项目难点":["53.15","53.31"],"canvas":["53.16"],"canvas绘制的图像怎么用图片形式直接展示":["53.17"],"图片类型和格式分别有哪些":["53.18"],"浏览器缓存":["53.19"],"虚拟内存":["53.20"],"sessionstorage":["53.22"],"进程":["53.23"],"事件循环输出题":["53.24"],"一面13题追问":["53.25"],"场景题":["53.27","53.37"],"手写题1":["53.28"],"实习有关":["53.32"],"offer情况":["53.33"],"从输入url到渲染页面的全过程":["53.34"],"强缓存":["53.35"],"长连接":["53.36"],"手写题":["53.38","59.10"],"项目都有那些组件":["54.0"],"垂直居中":["54.1"],"选择器":["54.2"],"dom的接口":["54.3"],"组件通讯方式":["54.4"],"vue通信方式":["54.5"],"环境搭建":["55.0"],"插件":["55.1"],"pnpm":["55.4"],"数组有那些属性":["56.1"],"那些地方可以用到watch":["56.3"],"vue3的生命周期":["56.4"],"在哪个生命周期拿数据":["56.5"],"flex布局的常用属性":["56.7"],"垂直居中的方式":["56.8"],"vue的通讯方式":["56.9"],"position的属性":["56.10"],"vue的单向数据流":["56.11"],"为什么要用异步任务":["56.12"],"为什么要用promise":["56.13"],"同步任务异步任务任务队列是一个什么样的关系":["56.14"],"媒体查询原理":["57.1"],"还有什么能改变this指向":["57.2"],"组件库封装模态框":["57.3"],"最全前端代码":["58.0"],"code":["59.0"],"防抖":["59.1"],"节流":["59.2"],"递归实现深拷贝":["59.4"],"json实现简单的":["59.5"],"判断类型的函数":["59.6"],"最长递增子序列":["59.7"],"bind":["59.8"],"promiseall":["61.0"],"vue3响应式proxy":["62.0"],"创建对象":["65.0"],"直接创建":["65.1"],"工厂方法1":["65.3"],"工厂方法2":["65.4"],"构造函数":["65.5","86.2"],"原型":["65.6"],"排序算法":["66.0"],"冒泡":["66.1"],"选择排序":["66.2"],"插入排序":["66.3"],"希尔排序":["66.4"],"快速排序":["66.5"],"arraylist":["67.0"],"反转链表":["67.1"],"回文链表":["67.2"],"移除链表元素":["67.3"],"相交链表":["67.4"],"回形链表":["67.5"],"删除排序链表中的重复元素":["67.6"],"合并两个有序链表":["67.7"],"二叉树":["68.0"],"哈希表":["69.0"],"哈希函数":["69.1"],"put":["69.2"],"get":["69.3","72.5"],"remove":["69.4","72.8"],"判断质数":["69.5"],"得到质数":["69.6"],"其他":["69.7"],"栈":["70.0"],"例子":["70.1","74.2"],"二叉搜索树":["71.0"],"什么是二叉搜索树":["71.1"],"二叉搜索树的特点":["71.2"],"二叉搜索树常见的操作":["71.3"],"创建二叉搜索树":["71.4"],"insert":["71.5","72.4"],"遍历二叉搜索树":["71.6"],"先序遍历":["71.7"],"中序遍历":["71.8"],"后序遍历":["71.9"],"最大最小值":["71.10"],"查找特定值":["71.11"],"二叉搜索树的删除":["71.12"],"情况一":["71.13"],"情况二":["71.14"],"情况三":["71.15"],"删除节点完整代码":["71.16"],"链表":["72.0"],"js普通构造函数":["72.1"],"增":["72.2"],"tostring":["72.3"],"indexof":["72.6"],"update":["72.7"],"removedata":["72.9"],"isempty":["72.10"],"js普通构造函数版本code":["72.11"],"class语法糖版本code":["72.12"],"优先级队列":["73.0"],"普通构造函数封装":["73.1","74.1"],"class语法糖封装":["73.2"],"队列":["74.0"],"array":["75.1","75.2","75.3","75.4","75.5","75.6","75.7","75.8","75.9","75.10","75.11","75.12","75.13","75.14","75.15","75.16","75.17","75.18","75.19","75.20","75.21","75.22","75.23","75.24","75.25","75.26","75.27","75.28","75.29","75.30","75.31","75.32"],"数组扁平化":["76.0"],"一层":["76.4"],"多层":["76.5"],"foreach递归":["76.6"],"reduce递归":["76.7"],"reduce":["77.0"],"累加":["77.1"],"最大值":["77.2"],"分类":["77.4"],"翻转字符串":["77.5"],"流光按钮":["78.0"],"展示效果":["78.1"],"全局挂载":["78.2","79.2","82.2"],"局部挂载":["78.3","79.3","82.3"],"禁用":["78.4","79.7","80.2","83.2"],"button":["79.0"],"效果展示":["79.1","82.1"],"类型":["79.4"],"朴素按钮":["79.5"],"圆角":["79.6"],"给按钮添加icon":["79.8"],"输入框":["80.0"],"普通输入框":["80.1"],"尺寸":["80.3"],"一键清空":["80.4"],"密码框":["80.5"],"带icon输入框":["80.6"],"复合输入框":["80.7"],"自适应高度文本域":["80.8"],"安装":["81.0"],"icon":["82.0"],"徽标提示":["82.4"],"颜色":["82.5"],"使用":["82.6"],"logo":["82.7"],"链接":["82.8"],"筛选":["82.9"],"点赞收藏":["82.10"],"声音":["82.11"],"箭头":["82.12"],"分享":["82.13"],"删除":["82.14"],"编写文字":["82.15"],"设置帮助":["82.16"],"超链接":["83.0"],"下划线":["83.1"],"文件上传":["84.0"],"点击上传":["84.1"],"拖拽上传":["84.2"],"bilibili错题":["85.0"],"定时器":["85.1"],"哪个样式在现代浏览器默认样式下设置宽度不生效":["85.2"],"obj对象里的箭头函数的this指向的是obj的上下文":["85.4"],"input标签的输入类型":["85.5"],"状态码":["85.6"],"影响原数组":["85.7"],"promise的catch":["85.9"],"对象键值":["85.10"],"分析":["85.11"],"过渡效果transition":["85.14"],"input":["85.15"],"定位的top属性":["85.16"],"取余":["85.17"],"三栏布局":["85.18"],"leecode":["85.19","88.0"],"日常错题":["86.0"],"箭头函数":["86.1"],"错题集":["87.0"],"介绍":["90.0"],"快速开始":["91.0"]},{"0":["1.15","13.3","14.10","19.43","24.2","51.7","60.0","66.2","72.11","72.12","73.1","75.13"],"1":["0.6","0.8","1.1","1.5","1.13","1.14","1.15","1.16","2.7","2.10","3.1","3.2","3.3","3.4","3.5","3.15","4.0","5.3","5.4","5.6","5.7","5.8","5.14","5.17","6.1","6.13","6.14","6.15","6.16","6.17","6.19","7.2","7.5","8.2","9.17","9.18","9.19","9.23","9.25","9.26","9.27","10.1","10.2","11.12","11.16","11.19","11.21","11.22","13.3","14.3","15.7","16.0","16.1","16.2","16.3","16.4","16.5","16.6","16.8","16.11","16.13","16.16","16.17","16.19","16.21","16.23","16.27","16.28","16.30","16.32","16.35","16.39","16.41","16.43","16.45","16.46","16.49","16.50","17.10","18.4","19.1","19.2","19.8","19.13","19.14","19.15","19.24","19.31","19.38","19.39","19.42","19.43","19.54","19.69","19.72","19.76","20.3","21.0","21.2","21.3","21.4","21.5","21.6","21.8","22.11","23.2","23.3","24.2","24.3","25.0","25.1","26.1","27.0","28.1","28.2","28.10","30.0","30.1","30.2","30.3","30.4","30.5","30.8","30.9","32.0","32.3","32.4","34.4","34.14","34.20","34.22","35.2","35.4","35.5","36.1","36.2","36.9","37.12","38.7","41.1","41.2","41.3","41.5","42.22","42.32","43.6","43.7","43.8","43.10","43.11","43.14","44.1","44.6","44.9","44.10","44.13","44.14","44.17","44.20","44.21","44.24","44.31","44.33","44.34","44.38","44.39","44.44","44.50","44.59","44.60","45.11","45.13","45.14","45.24","45.25","45.26","45.27","45.34","46.3","51.0","51.3","51.5","51.7","52.5","52.6","53.14","53.19","53.34","55.1","56.0","56.2","56.3","56.10","56.12","56.14","59.9","71.2","71.4","71.11","71.12","71.15","76.1","77.4","85.2","85.12","85.13","85.17"],"2":["0.6","1.3","1.6","2.10","3.6","3.15","4.0","5.8","5.17","6.2","6.13","8.2","9.9","9.23","11.12","11.19","11.21","14.10","16.3","16.4","16.5","16.6","16.7","16.8","16.9","16.10","16.11","16.12","16.14","16.18","16.19","16.22","16.24","16.28","16.33","16.36","16.39","16.42","16.43","16.46","16.50","19.3","20.3","21.8","25.1","28.10","30.6","36.9","37.12","38.7","41.5","42.32","43.8","44.50","45.13","52.6","53.14","56.0","59.9","71.4","71.12","76.2","80.8","85.13"],"3":["0.6","1.7","1.12","3.7","3.15","6.3","8.2","9.23","11.12","13.3","16.5","16.11","16.15","16.16","16.17","16.18","16.19","16.20","16.21","16.22","16.25","16.39","16.41","16.42","16.45","16.46","16.50","19.4","21.8","25.1","38.7","41.5","42.16","43.8","45.13","53.14","53.30","59.9","71.12","76.3"],"4":["0.6","1.4","3.8","6.4","9.23","16.16","16.21","16.22","16.23","16.24","16.25","16.26","16.27","16.28","16.29","16.30","16.31","16.34","16.35","16.36","16.37","16.39","16.47","16.50","19.5","38.7","41.5","79.1"],"5":["1.8","3.9","6.5","9.23","16.30","16.38","16.39","16.40","16.43","16.44","16.45","16.46","16.47","16.48","16.49","16.50"],"6":["1.9","3.10","6.6","16.35","16.36","85.17"],"7":["1.11","3.11","6.7","16.37"],"8":["1.17","1.18","3.12","6.8","13.3"],"9":["1.19","3.13","6.9"],"10":["1.20","6.10","14.13"],"11":["1.21","6.11"],"12":["1.22","6.14"],"13":["2.0","6.18"],"14":["2.1"],"15":["2.2"],"16":["2.4"],"17":["2.6"],"18":["2.7"],"19":["2.8"],"20":["2.10","16.16"],"24":["16.39"],"25":["16.39"],"40":["11.24"],"50":["16.39"],"100":["2.10"],"123":["85.10"],"200":["9.23"],"201":["9.23"],"202":["9.23","88.1"],"203":["9.23"],"204":["9.23"],"279":["85.19"],"405":["85.6"],"3000":["0.2"],"ajax作用是什么":["0.1"],"常见的方法":["0.2"],"xhr":["0.2"],"js":["0.2","0.6","4.0","19.4","19.28","19.34","19.51","19.52","19.54","19.61","19.73","20.26","21.1","21.3","21.5","21.6","21.7","21.8","21.9","22.5","22.6","22.10","23.1","23.3","24.2","26.4","29.0","29.1","29.3","34.4","36.3","36.9","41.5","41.7","41.8","41.9","41.10","42.3","42.4","42.7","42.23","44.34","44.57","45.4","45.8","45.9","45.15","45.17","45.19","45.21","45.29","45.32","46.3","46.6","47.0","50.2","50.4","51.7","52.3","53.13","53.14","56.0","59.1","59.2","59.4","59.5","59.6","59.7","59.8","59.9","59.10","60.0","61.0","61.1","62.0","63.0","65.1","65.3","65.4","65.5","65.6","66.1","66.3","66.5","67.3","67.4","67.5","67.6","67.7","69.1","69.2","69.3","69.4","69.5","69.6","69.7","70.0","70.1","71.5","71.7","71.8","71.9","71.10","71.11","71.16","72.1","72.2","72.3","72.4","72.5","72.6","72.7","72.8","72.9","72.10","72.11","72.12","73.1","73.2","74.1","74.2","75.17","76.0","76.2","76.4","76.5","76.6","76.7","77.1","77.2","77.3","77.4","77.5","78.2","78.3","79.2","79.3","82.2","82.3","85.1","85.10","88.1"],"const":["0.2","4.0","21.3","21.5","21.6","21.7","21.8","26.4","36.3","36.9","37.9","41.9","42.17","45.17","45.19","46.3","47.0","53.2","56.0","59.7","63.0","67.3","67.4","74.2","76.6","76.7","77.4"],"new":["0.2","16.3","16.4","16.5","16.16","16.39","17.18","19.34","19.75","21.3","21.5","21.8","56.0","59.7","62.0","67.1","72.11"],"xmlhttprequest":["0.2"],"open":["0.2"],"get":["0.2","0.4","9.16","9.17","45.33"],"http":["0.2","9.1","9.9","9.37","9.38","13.3","28.10"],"localhost":["0.2"],"goods":["0.2"],"json对象转换json字符串":["0.3"],"他们的优缺点":["0.4"],"常用的post":["0.4"],"delete":["0.4","22.3"],"同源策略限制":["0.5"],"不同源会造成跨域":["0.5"],"jsonp":["0.6"],"只能解决get跨域":["0.6"],"问的最多":["0.6"],"原理":["0.6","15.7"],"动态创建一个script标签":["0.6"],"利用script标签的src属性不受同源策略限制":["0.6"],"因为所有的src属性和href属性都不受同源策略限制":["0.6"],"可以请求第三方服务器数据内容":["0.6"],"步骤":["0.6"],"去创建一个script标签":["0.6"],"script的src属性设置接口地址":["0.6"],"接口参数":["0.6"],"必须要带一个自定义函数名":["0.6"],"要不然后台无法返回数据":["0.6"],"通过定义函数名去接收后台返回数据":["0.6"],"var":["0.6","19.34","20.26","59.7","59.10","67.1","67.2","67.3","67.4","67.5","67.6","67.7","72.4","72.11","72.12","85.10","85.13","88.1"],"script":["0.6"],"document":["0.6","5.17","5.25","19.50","30.4"],"createelement":["0.6","5.22","37.17"],"并带一个callback回调函数名称":["0.6"],"axios":["0.7","19.49","52.3"],"响应拦截":["0.8"],"全局错误处理":["0.8"],"你可以在响应拦截器中检查响应的状态码":["0.8"],"并根据不同的状态码执行相应的操作":["0.8"],"例如":["0.8","16.28","16.45","36.7","38.4","79.4"],"如果响应状态码是401":["0.8"],"未授权":["0.8"],"你可以执行相应的操作":["0.8"],"例如重新登录或跳转到登录页面":["0.8"],"统一的数据处理":["0.8"],"你可以在响应拦截器中对响应数据进行处理":["0.8"],"例如将响应的":["0.8"],"数据格式化":["0.8"],"转换成特定的数据结构":["0.8"],"或进行数据解析":["0.8"],"全局":["0.8"],"loading状态管理":["0.8"],"你可以在请求发送和响应返回的过程中显示和隐藏全局loading状态":["0.8"],"通过在请求开始时显示loading状态":["0.8"],"然后在响应拦截器中隐藏loading状态":["0.8"],"设置接口请求前缀":["0.9"],"根据开发":["0.9"],"测试":["0.9"],"canceltoken":["0.10"],"source":["0.10"],"在get方法中":["0.10"],"常见的水平垂直居中实现方案":["1.1"],"最简单的方案当然是flex布局":["1.1"],"css":["1.1","1.25","1.26","1.30","1.32","2.10","5.8","33.0","34.29"],"father":["1.1","11.14"],"display":["1.1","1.5","85.2"],"清除浮动是为了解决浮动元素导致的父元素高度塌陷问题":["1.2"],"使用额外的空元素清除浮动":["1.2"],"html":["1.2","5.2","33.0","44.22"],"div":["1.2","2.10","6.3","34.4","34.28","44.57","80.7","84.2"],"bfc问题":["1.3"],"触发bfc的元素":["1.3"],"常规方法":["1.5"],"none":["1.5","1.16"],"结构消失":["1.5"],"会":["1.5"],"逃逸视窗":["1.6"],"position":["1.6","1.20","72.4","72.8"],"移行变换":["1.7"],"px":["1.8"],"vw":["1.9"],"vh":["1.9"],"是什么":["1.9"],"自适应布局使用rem作为单位":["1.10"],"其原理是基于":["1.10"],"浏览器默认字体大小":["1.10"],"的相对值来计算元素的尺寸":["1.10"],"flex":["1.11","1.17"],"布局如何使用":["1.11"],"是":["1.11","3.14","30.7","32.7","34.15","36.7"],"auto":["1.14"],"grid布局":["1.17"],"那就是":["1.17"],"如何用":["1.18"],"居中为什么要使用":["1.19"],"transform":["1.19"],"为什么不使用":["1.19"],"marginleft":["1.19"],"介绍下粘性布局":["1.20"],"sticky":["1.20"],"说出":["1.21"],"space":["1.21"],"css3":["1.22","2.8"],"中":["1.22","23.2","34.2","34.25"],"transition":["1.22"],"和":["1.22","9.36","11.8","19.64","20.22","32.5","36.8","38.5","42.24","44.23","44.41","51.4"],"animation":["1.22","1.27"],"的属性分别有哪些":["1.22"],"path":["1.23","37.4","85.8"],"块级元素以块状形式显示":["1.24"],"并占据一行或多行的空间":["1.24"],"aline":["1.25"],"h1":["1.25","6.2"],"align":["1.25","1.26"],"vertical":["1.26"],"属性设置一个元素的垂直对齐方式":["1.26"],"rem相对于根元素":["1.28"],"内联样式的权重为1000":["1.29","56.16"],"属性选择器使用方括号":["1.30"],"来指定属性和属性值":["1.30"],"伪类选择器选择处于特定状态或特定位置的元素":["1.30"],"它们通过在选择器后面使用冒号":["1.30"],"和关键词来指定":["1.30"],"选择已选中的复选框":["1.30"],"不用js":["1.30"],"input":["1.30","19.69","28.2"],"伪元素选择器允许在元素的特定位置插入额外的内容":["1.31"],"字体系列属性":["1.32"],"font":["1.32","16.11","16.16","16.39","16.41","16.42"],"组合字体":["1.32"],"媒体查询":["1.33"],"css提高性能的方法有哪些":["1.34"],"当浏览器加载页面时":["1.35"],"如何实现一个自适应的正方形":["2.1"],"清除浮动的方法":["2.2"],"clear":["2.2","72.10"],"清除浮动":["2.2"],"css盒模型是指在html中":["2.3"],"每个元素都被视为一个矩形的盒子":["2.3"],"其包括四个部分":["2.3"],"内容":["2.3"],"两种盒模型以及区别":["2.4"],"可以使用box":["2.5"],"如何触发重排和重绘":["2.6"],"如何优化图片":["2.7"],"对于很多装饰类图片":["2.7"],"新增了那些东西":["2.8"],"选择器nth":["2.8"],"child":["2.8"],"last":["2.8"],"媒体查询是css3中新增的一种功能":["2.9"],"它允许开发者根据设备屏幕尺寸":["2.9"],"实现三栏布局的7种方法":["2.10"],"浮动float":["2.10"],"calc":["2.10"],"height":["2.10"],"100px":["2.10"],"left":["2.10"],"float":["2.10"],"width":["2.10"],"200px":["2.10"],"background":["2.10"],"color":["2.10","16.11","16.16","16.39","16.41","16.42","82.1"],"red":["2.10","82.1"],"middle":["2.10"],"400px":["2.10"],"green":["2.10"],"right":["2.10"],"blue":["2.10","16.11","16.16","16.39","16.41","16.42"],"margin":["2.10"],"负值":["2.10"],"新增了let":["3.6"],"const关键字":["3.6"],"作用域":["3.7"],"常见的作用域主要分为几个类型":["3.7"],"全局作用域":["3.7"],"新增了箭头函数":["3.9"],"es6新增了模块化":["3.12"],"生成器":["3.14"],"数组":["3.15","16.42"],"扩展运算符":["3.15"],"构造函数新增方法":["3.15"],"array":["3.15","19.58","19.72","22.4","26.1","51.7","59.7"],"from":["3.15","14.6","14.9","14.10","14.12","14.13","19.72","26.1","41.5","44.34","75.15","78.2","79.2","82.2"],"of":["3.15","19.73","19.74","26.1","75.16"],"新增简单数据类型symbol":["4.0"],"用于表示一个独一无二的值":["4.0"],"a":["4.0","11.26","19.4","19.29","24.2","41.10","42.1","45.17","66.2","82.12","85.10"],"symbol":["4.0","19.4","20.18"],"symbol创建实例不需要new":["4.0"],"console":["4.0","21.1","23.3","41.9"],"log":["4.0","21.1","23.3","41.9","53.11"],"不能在调用symbol时使用new关键字":["4.0"],"因为symbol是基本数据类型":["4.0"],"而不是对象":["4.0"],"唯一性":["4.0"],"使用symbol":["4.0"],"创建一个symbol类型的值并赋值给a变量后":["4.0"],"你就得到了一个在内存中独一无二的值":["4.0"],"数据类型的修饰":["4.0"],"文档对象模型":["5.1"],"从网络传给渲染引擎的":["5.1"],"树如何生成":["5.2"],"渲染引擎内部":["5.2"],"有一个叫html":["5.2"],"解析器":["5.2"],"htmlparser":["5.2"],"的模块":["5.2"],"它的职责就是负责将html":["5.2"],"字节流转换为":["5.2"],"结构":["5.2","14.15"],"解析器并不是等整个文档加载完成之后再解析的":["5.2"],"而是网络进程加载了多少数据":["5.2"],"解析器便解析多少数据":["5.2"],"网络进程接收到响应头之后":["5.2"],"执行到":["5.4"],"javascript":["5.4","5.5","23.2","24.3","32.5","38.5","67.1","67.2"],"dom文档的加载顺序是由上而下的顺序加载":["5.8"],"下载html":["5.8"],"内联css使浏览器在下载完html后就能立刻渲染":["5.8"],"在解析html到link标签":["5.8"],"构建":["5.9"],"树是":["5.10"],"的解析注意点":["5.11"],"操作真实":["5.12"],"dom":["5.12","5.13","5.15","5.16","19.64","36.16","36.17","41.5","44.46","46.3"],"就是一个js对象模拟的dom树":["5.13"],"参考这篇":["5.13"],"虚拟":["5.13"],"就是为了解决浏览器性能问题而被设计出来的":["5.13"],"dom的实现":["5.14"],"模拟":["5.16"],"表示整个文档":["5.17"],"提供了操作和访问文档的方法和属性":["5.17"],"getelementbyid":["5.18"],"id":["5.18","14.6","14.12","14.13","37.12","44.34"],"根据元素的":["5.18"],"属性获取对应的元素节点":["5.18"],"documentelement":["5.19"],"返回文档的根元素节点":["5.19"],"getattribute":["5.20"],"dom元素对象":["5.21"],"element":["5.21","70.0"],"具有许多属性":["5.21"],"用于访问和操作元素的不同方面":["5.21"],"下面列举一些常见的属性":["5.21"],"classlist":["5.21"],"返回一个domtokenlist对象":["5.21"],"包含了元素的类名":["5.21"],"class":["5.21","11.14","11.24","16.4","16.5","16.9","16.15","16.16","16.17","16.22","16.23","16.33","16.36","16.39","16.41","16.42","17.17","34.4","45.4","45.9","60.0","72.12","73.2","79.1","80.7","84.2"],"列表":["5.21"],"创建新元素":["5.22"],"alert":["5.24"],"message":["5.24"],"显示一个带有消息和确定按钮的对话框":["5.24"],"confirm":["5.24"],"获取当前窗口的":["5.25"],"type":["5.27","16.28","42.4","42.24","79.1","85.15"],"事件的类型":["5.27"],"如":["5.27"],"click":["5.27"],"preventdefault":["5.28"],"取消事件的默认行为":["5.28"],"什么是":["6.1"],"title":["6.2"],"与":["6.2","19.27","19.30","20.22","22.7"],"行内元素和块级元素分别有哪些":["6.3"],"有何区别":["6.3"],"怎样转换":["6.3"],"常见的块级元素":["6.3"],"p":["6.3"],"label的作用是什么":["6.4"],"是怎么用的":["6.4"],"label元素不会向用户呈现任何特殊效果":["6.4"],"但是":["6.4"],"a元素除了用于导航外":["6.5"],"还有什么作用":["6.5"],"怎么处理html5新标签兼容问题":["6.7"],"html5新增了哪些新特性":["6.8"],"移除了哪些元素":["6.8"],"html5主要是关于图像":["6.8"],"位置":["6.8"],"网页的渲染":["6.9"],"渲染树":["6.10"],"重排":["6.11"],"当页面发生变化时浏览器会对页面重新绘制":["6.12"],"避免频繁使用":["6.13"],"style":["6.13"],"而是采用修改class的方式":["6.13"],"使":["6.13"],"合成层":["6.14"],"使用css3硬件加速":["6.15"],"将元素的属性设置为transform":["6.15"],"opacity":["6.15"],"层隐式合成的例子":["6.16"],"同合成层重叠也会使元素提升为合成层":["6.17"],"谈谈html语义化":["6.18"],"页面结构":["6.19"],"使页面没有css的情况下":["6.19"],"inline":["6.20"],"frame":["6.20"],"是html中的一个元素":["6.20"],"seo":["7.1"],"所以要在title里面言简意赅的体现出页面的主要内容":["7.3"],"关键词密度":["7.4"],"页面上经常会有各种图片":["7.5"],"对于搜索引擎来说":["7.5"],"它是不识别图片上的内容的":["7.5"],"你可能知道代码中img标签的alt属性是为了图片加载失败的时候":["7.5"],"web标准简单来说可以分为结构":["8.1"],"需要声明":["8.2"],"doctype":["8.2","13.3"],"需要定义语言编码":["8.2"],"标签规范可以提高搜索引擎对页面的抓取效率":["8.3"],"对seo":["8.3"],"hypertext":["9.1","9.37"],"transfer":["9.1"],"protocal":["9.1"],"全称为超文本传输协议":["9.1"],"支持客户端":["9.2"],"服务端模式":["9.2"],"简单快速":["9.2"],"ip":["9.3"],"可能会发生阻塞的情况":["9.4"],"建立连接阻塞":["9.4"],"http协议传输的数据都是未加密的":["9.5"],"也就是明文的":["9.5"],"可以用抓包工具直接抓下来并且可见":["9.5"],"而https则是利用了网景公司设计的ssl":["9.5"],"secure":["9.5","9.6"],"sockets":["9.6"],"layer":["9.6","9.28"],"是一种加密协议":["9.6"],"对称加密是一种加密方式":["9.7"],"0与http2":["9.9"],"0的区别":["9.9"],"多路复用允许在单个tcp连接上同时发送多个请求和响应":["9.10"],"使用了":["9.11"],"hpack":["9.11"],"压缩算法":["9.11"],"服务器可以根据":["9.12"],"cdn就是根据用户位置分配最近的资源":["9.13","53.21"],"用户在上网的时候不用直接访问源站":["9.13","53.21"],"访问离他":["9.13","53.21"],"最近的":["9.13","53.21"],"协议":["9.14"],"请求行包括三个方面":["9.16"],"请求方法":["9.16"],"请求地址":["9.16"],"协议版本":["9.16"],"方法名":["9.16"],"功能":["9.16"],"向指定的资源发出":["9.16"],"一般用于信息获取":["9.17"],"使用url传递参数并且可见":["9.17"],"传递参数数量有限":["9.17"],"无法使用缓存文件":["9.18"],"请求头可用于传递一些附加信息":["9.19"],"格式为":["9.19"],"键":["9.19"],"值":["9.19","36.9"],"注意":["9.19","19.62"],"冒号后面有一个空格":["9.19"],"常见的请求":["9.19"],"header":["9.19"],"名称":["9.19"],"作用":["9.19","19.58","19.59"],"authorization":["9.19"],"用于设置身份认证信息":["9.19"],"user":["9.19","9.36"],"又叫请求正文":["9.20"],"http响应报文分为三个部分":["9.21"],"状态码":["9.22","53.35"],"对应的信息":["9.22"],"2xx":["9.23"],"成功":["9.23"],"服务器已成功处理了请求":["9.23"],"通常":["9.23"],"这表示服务器提供了请求的网页":["9.23"],"已创建":["9.23"],"请求成功并且服务器创建了新的资源":["9.23"],"已接受":["9.23"],"服务器已接受请求":["9.23"],"但尚未处理":["9.23"],"非授权信息":["9.23"],"但返回的信息可能来自另一来源":["9.23"],"无内容":["9.23"],"服务器成功处理了请求":["9.23"],"响应体":["9.24"],"参考这篇博文":["9.25"],"url":["9.25","19.62"],"解析":["9.26","44.22"],"查询":["9.27"],"五层协议模型":["9.28"],"tcp":["9.28","9.34","9.36"],"ip协议模型":["9.28"],"物理层":["9.28"],"physical":["9.28"],"服务器处理收到的请求":["9.29"],"浏览器解码响应":["9.30"],"建立连接是三次握手":["9.32"],"three":["9.33"],"way":["9.33","9.34"],"handshake":["9.33","9.34"],"的连接的拆除需要发送四个包":["9.34"],"因此称为四次挥手":["9.34"],"four":["9.34"],"transmission":["9.36"],"control":["9.36"],"protocol":["9.36"],"udp":["9.36","53.5"],"datagram":["9.36"],"是两种在计算机网络中常用的传输层协议":["9.36"],"它们在数据传输方式":["9.36"],"session":["9.38"],"token":["9.38"],"web应用程序中管理用户认证和授权的机制":["9.38"],"是一种":["9.38"],"存储在客户端":["9.38"],"通常是浏览器":["9.38"],"的小型文本文件":["9.38"],"由服务器通过":["9.38"],"响应头":["9.38"],"进程和线程是操作系统中用于执行任务的两个基本概念":["9.39"],"cross":["10.1","10.3","10.4"],"site":["10.1","10.3","10.4"],"scripting":["10.1"],"在受害者的":["10.1"],"浏览器中注入恶意脚本":["10.1"],"盗取存储在客户端的cookie或者其他网站用于识别客户端身份的敏感信息":["10.1"],"攻击通常可以分为三种类型":["10.1"],"反射型":["10.1"],"攻击":["10.1"],"web安全是指保护web应用程序和web服务器免受各种安全威胁的一系列措施":["10.2"],"web安全覆盖了很多方面":["10.2"],"包括但不限于以下几个方面":["10.2"],"身份认证和授权":["10.2"],"身份认证是验证用户身份的过程":["10.2"],"而授权是确定用户是否有权访问某些资源的过程":["10.2"],"csrf":["10.3","10.5"],"request":["10.4","21.5"],"forgery":["10.4"],"跨站请求伪造":["10.4"],"攻击的措施":["10.5","10.6"],"验证来源":["10.5"],"xss":["10.6"],"输入验证和过滤":["10.6"],"对于用户输入的数据":["10.6"],"sql":["10.7","14.2","14.4","14.6","14.9","14.10","14.12","14.13","14.14"],"jre":["11.1"],"jvm三者的关系":["11.1"],"jvm":["11.1"],"英文名称":["11.1"],"封装就是将类的信息隐藏在类内部":["11.2"],"不允许外部程序直接访问":["11.2"],"而是通过该类的方法实现对隐藏信息的操作和访问":["11.2"],"简单类型":["11.3"],"boolean":["11.3","16.22","19.4","42.11"],"byte":["11.3"],"由于计算机中保存的小数其实是十进制的小数的近似值":["11.4"],"为什么需要包装类":["11.5"],"java":["11.5","11.14","11.21","11.24","16.3","16.4","16.5","16.9","16.11","16.13","16.15","16.16","16.17","16.22","16.23","16.33","16.36","16.39","16.41","16.42","16.43","16.47","16.49","17.12","17.17","17.18","18.2","18.4"],"装箱":["11.6"],"将基础类型转化为包装类型":["11.6"],"拆箱":["11.6"],"将包装类型转化为基础类型":["11.6"],"当基础类型与它们的包装类有如下几种情况时":["11.6"],"编译器会自动帮我们进行装箱或拆箱":["11.6"],"赋值操作":["11.6"],"装箱或拆箱":["11.6"],"为什么不可变":["11.7"],"string对象其实在内部就是一个个字符":["11.7"],"存储在这个value数组里面的":["11.7"],"value数组用final修饰":["11.7"],"final":["11.7","16.41"],"修饰的变量":["11.7"],"值不能被修改":["11.7"],"stringbuffer":["11.8"],"stringbuilder区别":["11.8"],"string":["11.9","16.5","16.16","16.39","19.4","42.1","42.3","42.4","42.11","42.21"],"dabin":["11.9"],"字符串常量池":["11.10"],"相同":["11.11"],"则":["11.11","20.19"],"可以修饰成员变量":["11.12"],"也可以修饰成员方法":["11.12"],"特点":["11.12"],"被类的所有对象共享":["11.12"],"可以通过类名调用":["11.12"],"public":["11.13","11.14","11.21","11.24","13.3","16.4","16.5","16.9","16.13","16.15","16.16","16.17","16.22","16.23","16.33","16.36","16.39","16.41","16.42","16.43","16.47","16.49","17.12","17.17","18.4"],"子和父变量重名时":["11.14"],"要用":["11.14"],"super":["11.14","19.57"],"变量":["11.14","35.4"],"调用父的变量":["11.14"],"从小到大":["11.15"],"特殊的父类":["11.17"],"内部允许编写抽象方法":["11.17"],"将共性的方法":["11.17"],"抽取到父类之后":["11.17"],"发现这个方法在父类中无法给出具体明确":["11.17"],"而且这个方法还是子类必须要有的方法":["11.17"],"接口体现的思想就是声明规则":["11.18"],"一个类的所有组成都是":["11.18"],"抽象方法":["11.18"],"这种类会设计成接口":["11.18"],"这个类存在的唯一价值就只是声明规则":["11.18"],"不允许实例化":["11.18"],"类和类之间":["11.19"],"继承关系":["11.19"],"单继承":["11.19"],"多层继承":["11.19"],"不可多继承":["11.19"],"成员变量":["11.20"],"同一个行为具有多个表现形式或形态的能力":["11.21"],"对象多态":["11.21"],"方法的形参定义为父类型":["11.21"],"这个方法就可以接受到该父类的任意子类对象":["11.21"],"行为多态":["11.21"],"同一个方法有多中的表现形式":["11.21"],"或形态的能力":["11.21"],"package":["11.21"],"com":["11.21"],"higher":["11.21"],"mutiltai":["11.21"],"向上转型":["11.22"],"局部代码块":["11.23"],"可以限定变量的生命周期":["11.23"],"提早释放内存":["11.23"],"构造代码块":["11.23"],"在创建方法执行构造方法的时候":["11.23"],"会执行构造代码块":["11.23"],"outer":["11.24"],"int":["11.24","16.11","16.13","16.43","16.47"],"num":["11.24","19.4","74.2"],"用于解决小数运算中":["11.25"],"出现的不精确的问题":["11.25"],"匹配单个字符":["11.26"],"b":["11.26","41.10","85.10"],"c":["11.26","85.10"],"只能是a":["11.26"],"abc":["11.26"],"除了abc外的":["11.26"],"匹配所有单个字符":["11.26"],"除了换行符":["11.26"],"linux":["11.26"],"中换行是":["11.26"],"n":["11.26","67.2"],"windows":["11.26"],"r":["11.26"],"regex":["11.26"],"正则必须匹配字符串开头":["11.26"],"正则必须匹配字符串结尾":["11.26"],"throw":["11.28"],"clean":["12.1"],"是个容器":["13.1"],"id要与接口中的方法名一致":["13.2"],"公共配置部分":["13.3"],"xml":["13.3"],"version":["13.3"],"encoding":["13.3"],"utf":["13.3"],"mapper":["13.3"],"mybatis":["13.3"],"org":["13.3"],"dtd":["13.3"],"en":["13.3"],"抽取sql重复代码":["13.3"],"include调用":["13.3"],"整段sql逻辑代码用mapper包起来":["13.3"],"关系型数据库":["14.0"],"建立在关系模型基础上":["14.0"],"ddl":["14.1"],"创建":["14.2","65.2"],"create":["14.2","14.4","14.6","20.4"],"table":["14.2","16.42","85.2"],"tb":["14.2","14.4","14.6","14.9","14.10","14.12"],"tinyint":["14.3"],"增":["14.4","72.11","72.12"],"插入字段":["14.4"],"insert":["14.4","71.3"],"into":["14.4"],"emp":["14.4","14.6","14.10","14.12"],"username":["14.4","14.6","30.4"],"name":["14.4","14.6","14.12","14.13","23.3","42.19","44.34","79.8","82.1","82.7","82.8","82.9","82.10","82.12","82.13","82.14","82.15","82.16"],"gender":["14.4","14.6"],"time":["14.4","14.6","16.3"],"update":["14.4","14.6"],"select":["14.5","14.6","14.9","14.10","14.12","14.13"],"字段列表":["14.5"],"entrydate":["14.6"],"password":["14.6"],"image":["14.6"],"job":["14.6"],"查所有":["14.6"],"执行时机不同":["14.7"],"where":["14.8","14.12","14.13"],"limit":["14.10"],"外键关联一对一":["14.11"],"基本都用逻辑外连接":["14.11"],"内连接":["14.12"],"dept":["14.12"],"多表查询":["14.13"],"查询价格低于10元的菜品name":["14.13"],"price":["14.13"],"和对应的菜品分类名称":["14.13"],"d":["14.13"],"category":["14.13"],"dish":["14.13"],"开启事务":["14.14"],"start":["14.14"],"transaction":["14.14"],"默认b":["14.15"],"tree":["14.15","35.1"],"多路平衡搜索树":["14.15"],"server层及dao层的实现类交给ioc容器管理":["15.2"],"添加注解":["15.2"],"component":["15.2"],"为controller及service主图运行时依赖的对象":["15.2"],"autowired":["15.2"],"面向切面编程":["15.3"],"面向方面编程":["15.3"],"around":["15.4"],"环绕通知":["15.4"],"多个切面类的执行顺序":["15.5"],"默认情况下":["15.6","20.30"],"起步依赖":["15.7"],"maven的依赖传递":["15.7"],"自动配置":["15.7"],"状态介绍":["16.1"],"当线程被创建并启动以后":["16.1"],"它既不是一启动就进入了执行状态":["16.1"],"也不是一直处于执行状态":["16.1"],"线程对象在不同的时期有不同的状态":["16.1"],"那么java中的线程存在哪几种状态呢":["16.1"],"java中的线程":["16.1"],"状态被定义在了java":["16.1"],"lang":["16.1"],"thread":["16.1","16.22","16.39","17.17"],"state枚举类中":["16.1"],"state枚举类的源码如下":["16.1"],"案例一":["16.3"],"本案例主要演示time":["16.3"],"waiting的状态转换":["16.3"],"需求":["16.3","16.4","16.5","50.3"],"编写一段代码":["16.3","16.4","16.5"],"依次显示一个线程的这些状态":["16.3","16.4","16.5"],"runnable":["16.3","16.4","16.5","16.9","16.11"],"waiting":["16.3","16.4"],"terminated":["16.3","16.4","16.5"],"为了简化我们的开发":["16.3"],"本次我们使用匿名内部类结合lambda表达式的方式使用多线程":["16.3"],"代码实现":["16.3","16.9"],"案例二":["16.4"],"本案例主要演示waiting的状态转换":["16.4"],"threadstatedemo02":["16.4"],"static":["16.4","16.5","16.13","16.16","16.39","16.41","16.42","34.6","56.10"],"void":["16.4","16.5","16.11","16.16","16.39","17.17"],"案例三":["16.5"],"本案例主要演示blocked的状态转换":["16.5"],"blocked":["16.5"],"threadstatedemo03":["16.5"],"main":["16.5","16.16","16.39","46.6"],"args":["16.5","16.16","16.39"],"throws":["16.5"],"interruptedexception":["16.5"],"定义一个对象":["16.5"],"用来加锁和解锁":["16.5"],"object":["16.5","19.4","19.63","19.64","20.6","20.12","20.15","22.9","42.11","42.32","45.9","45.16","59.4","65.2"],"obj2":["16.5","36.9"],"概述":["16.6","16.18","16.32"],"提到池":["16.6"],"实现思路":["16.9","16.27"],"创建一个线程池类":["16.9"],"threadpool":["16.9"],"在该类中定义两个成员变量poolsize":["16.9"],"线程池初始化线程的个数":["16.9"],"blockingqueue":["16.9"],"任务容器":["16.9"],"通过构造方法来创建两个线程对象":["16.9"],"消费者线程":["16.9"],"并且启动":["16.9"],"使用内部类的方式去定义一个线程类":["16.9"],"taskthread":["16.9"],"可以提供一个构造方法用来初始化线程名称":["16.9"],"两个消费者线程需要不断的从任务容器中获取任务":["16.9"],"如果没有任务":["16.9"],"则线程处于阻塞状态":["16.9"],"提供一个方法":["16.9"],"submit":["16.9","16.11"],"向任务容器中添加任务":["16.9"],"定义测试类进行测试":["16.9"],"线程池类":["16.9"],"初始化线程个数":["16.9"],"private":["16.9","16.22","16.36"],"executors":["16.11"],"jdk对线程池也进行了相关的实现":["16.11"],"在真实企业开发中我们也很少去自定义线程池":["16.11"],"而是使用jdk中自带的线程池":["16.11"],"我们可以使用executors中所提供的":["16.11"],"静态":["16.11","17.13"],"方法来创建线程池":["16.11"],"size":["16.11","16.16","16.39","16.41","16.42","22.8","72.10","80.5","80.6"],"获取线程池的方法":["16.11"],"通过不同的方法创建出来的线程池具有不同的特点":["16.11"],"executorservice":["16.11","16.13"],"newcachedthreadpool":["16.11"],"创建一个可缓存线程池":["16.11"],"可灵活的去创建线程":["16.11"],"并且灵活的回收线程":["16.11"],"若无可回收":["16.11"],"则新建线程":["16.11"],"newfixedthreadpool":["16.11","16.13"],"nthreads":["16.11","16.13"],"初始化一个具有固定数量线程的线程池":["16.11"],"newsinglethreadexecutor":["16.11"],"初始化一个具有一个线程的线程池":["16.11"],"做完一个":["16.11"],"再做一个":["16.11"],"不停歇":["16.11"],"直到做完":["16.11"],"老黄牛性格":["16.11"],"scheduledexecutorservice":["16.11"],"newsinglethreadscheduledexecutor":["16.11"],"支持定时及周期性任务执行":["16.11"],"按照固定的计划去执行线程":["16.11"],"一个做完之后按照计划再做另一个":["16.11"],"这个方法返回的都是executorservice类型的对象":["16.11"],"scheduledexecutorservice继承executorservice":["16.11"],"而executorservice可以看做就是一个线程池":["16.11"],"那么executorservice":["16.11"],"给我们提供了哪些方法供我们使用呢":["16.11"],"executorservice中的常见方法":["16.11"],"future":["16.11"],"task":["16.11"],"提交任务方法":["16.11"],"shutdown":["16.11"],"关闭线程池的方法":["16.11"],"基本使用":["16.13"],"刚才我们是通过executors中的静态方法去创建线程池的":["16.13"],"通过查看源代码我们发现":["16.13"],"其底层都是通过threadpoolexecutor构建的":["16.13"],"比如":["16.13","16.46","16.50","19.23"],"newfixedthreadpool方法的源码":["16.13"],"创建了threadpoolexecutor对象":["16.13"],"工作原理":["16.14"],"接下来我们就来研究一下线程池的工作原理":["16.14"],"如下图所示":["16.14"],"1571732060388":["16.14"],"当我们通过submit方法向线程池中提交任务的时候":["16.14"],"具体的工作流程如下":["16.14"],"案例演示":["16.15"],"接下来我们就通过一段代码的断点测试":["16.15"],"来演示一下线程池的工作原理":["16.15"],"案例代码":["16.15"],"threadpoolexecutordemo01":["16.15","16.16"],"任务拒绝策略":["16.16"],"rejectedexecutionhandler是jdk提供的一个任务拒绝策略接口":["16.16"],"它下面存在4个子类":["16.16"],"threadpoolexecutor":["16.16","17.18"],"abortpolicy":["16.16"],"丢弃任务并抛出rejectedexecutionexception异常":["16.16"],"是默认的策略":["16.16"],"discardpolicy":["16.16"],"丢弃任务":["16.16"],"但是不抛出异常":["16.16"],"这是不推荐的做法":["16.16"],"discardoldestpolicy":["16.16"],"抛弃队列中等待最久的任务":["16.16"],"然后把当前任务加入队列中":["16.16"],"callerrunspolicy":["16.16"],"调用任务的run":["16.16"],"方法绕过线程池直接执行":["16.16"],"注":["16.16"],"明确线程池对多可执行的任务数":["16.16"],"队列容量":["16.16"],"最大线程数":["16.16"],"案例演示1":["16.16"],"演示threadpoolexecutor":["16.16"],"abortpolicy任务处理策略":["16.16"],"核心线程数量为1":["16.16"],"最大线程池数量为3":["16.16"],"任务容器的容量为1":["16.16"],"空闲线程的最大存在时间为20s":["16.16"],"timeunit":["16.16"],"seconds":["16.16"],"arrayblockingqueue":["16.16"],"看程序说结果":["16.17","16.23"],"分析如下程序":["16.17"],"说出在控制台的输出结果":["16.17"],"thread的子类":["16.17"],"volatilethread":["16.17","16.22"],"extends":["16.17","16.22","16.36","16.41","16.42","17.17","34.22","42.30","42.32"],"jmm":["16.18"],"问题分析":["16.19"],"了解了一下jmm":["16.19"],"那么接下来我们就来分析一下上述程序产生问题的原因":["16.19"],"1571744627663":["16.19"],"产生问题的流程分析":["16.19"],"volatilethread线程从主内存读取到数据放入其对应的工作内存":["16.19"],"加锁":["16.21"],"第一种处理方案":["16.21"],"我们可以通过加锁的方式进行处理":["16.21"],"测试类":["16.21","16.39"],"volatile关键字":["16.22"],"第二种处理方案":["16.22"],"我们可以通过volatile关键字来修饰flag变量":["16.22"],"线程类":["16.22","16.23"],"定义成员变量":["16.22"],"volatile":["16.22","16.42"],"flag":["16.22"],"false":["16.22","19.4","20.22"],"isflag":["16.22"],"分析如下程序的执行结果":["16.23"],"volatileatomicthread":["16.23"],"implements":["16.23","16.36","16.41","16.42"],"问题分析说明":["16.24"],"以上问题主要是发生在count":["16.24"],"操作上":["16.24"],"volatile原子性测试":["16.25"],"我们刚才说到了volatile在多线程环境下只保证了共享变量在多个线程间的可见性":["16.25"],"但是不保证原子性":["16.25"],"那么接下来我们就来做一个测试":["16.25"],"状态标志":["16.27"],"比如现在存在一个线程不断向控制台输出一段话":["16.27"],"传智播客中国it教育的标杆":["16.27"],"当这个线程执行5秒以后":["16.27"],"将该线程结束":["16.27"],"定义一个boolean类型的变量":["16.27"],"独立观察":["16.28"],"ai养猪":["16.28"],"设备区测量温度":["16.28"],"当温度高了":["16.28"],"需要给猪开空调":["16.28"],"加冰棍":["16.28"],"加喝的水":["16.28"],"volatile的另一种简单使用场景是":["16.28"],"定期":["16.28"],"发布":["16.28"],"观察结果供程序内部使用":["16.28"],"假设有一种环境传感器能够感觉环境温度":["16.28"],"一个后台线程可能会每隔几秒读取一次该传感器数据":["16.28"],"并更新包":["16.28"],"含这个volatile变量的值":["16.28"],"然后":["16.28"],"其他线程可以读取这个变量":["16.28"],"从而随时能够看到最新的温度值":["16.28"],"这种使用就是多个线程操作共享变量":["16.28"],"但是是有一个线程对其进行写操作":["16.28"],"其他的线程都是读":["16.28"],"我们可以设计一个程序":["16.28"],"模拟上面的温度传感器案例":["16.28"],"实现步说明":["16.28"],"定义一个温度传感器":["16.28"],"temperaturesensor":["16.28"],"的类":["16.28"],"在该类中定义两个成员变量":["16.28"],"temperature":["16.28"],"温度值":["16.28"],"锁机制":["16.30"],"我们可以给count":["16.30"],"操作添加锁":["16.30"],"那么count":["16.30"],"atomicinteger":["16.32","16.36"],"java从jdk1":["16.32"],"5开始提供了java":["16.32"],"util":["16.32"],"concurrent":["16.32"],"atomic包":["16.32"],"简称atomic包":["16.32"],"这个包中的原子操作类提供了一种用法简单":["16.32"],"性能高效":["16.32"],"线程安全地更新一个变量的方式":["16.32"],"因为变":["16.32"],"量的类型有很多种":["16.32"],"所以在atomic包里一共提供了13个类":["16.32"],"属于4种类型的原子更新方式":["16.32"],"分别是原子更新基本类型":["16.32"],"原子更新数组":["16.32"],"原子更新引用和原子更新属性":["16.32"],"案例改造":["16.33"],"使用atomicinteger对案例进行改造":["16.33"],"原理介绍":["16.35"],"atomicinteger的本质":["16.35"],"自旋锁":["16.35"],"cas算法":["16.35"],"cas的全成是":["16.35"],"compare":["16.35"],"and":["16.35"],"源码分析":["16.36"],"那么接下来我们就来查看一下atomicinteger类中incrementandget方法的源码":["16.36"],"number":["16.36","19.4","19.27","42.11","53.1"],"io":["16.36"],"serializable":["16.36","16.41","16.42"],"cas算法的实现类":["16.36"],"cas与synchronized":["16.37"],"概述以及基本使用":["16.39","16.45","16.49"],"在集合类中hashmap是比较常用的集合对象":["16.39"],"但是hashmap是线程不安全的":["16.39"],"多线程环境下可能会存在问题":["16.39"],"为了保证数据的安全性我们可以使用hashtable":["16.39"],"但是hashtable的效率低下":["16.39"],"基于以上两个原因我们可以使用jdk1":["16.39"],"5以后所提供的concurrenthashmap":["16.39"],"案例1":["16.39"],"演示hashmap线程不安全":["16.39"],"实现步骤":["16.39","16.46","16.50"],"创建一个hashmap集合对象":["16.39"],"创建两个线程对象":["16.39"],"第一个线程对象向集合中添加元素":["16.39"],"第二个线程对象向集合中添加元素":["16.39"],"主线程休眠1秒":["16.39"],"以便让其他两个线程将数据填装完毕":["16.39"],"从集合中找出键和值不相同的数据":["16.39"],"hashmapdemo01":["16.39"],"hashmap":["16.39"],"我们本次使用匿名内部类的方式去常见线程对象":["16.39"],"t1":["16.39"],"override":["16.39","17.17"],"run":["16.39","17.17"],"jdk1":["16.41","16.42"],"7版本":["16.41"],"concurrenthashmap中的重要成员变量":["16.41","16.42"],"concurrenthashmap":["16.41","16.42"],"k":["16.41","16.42","42.32"],"v":["16.41","16.42","16.49","44.51","80.6","80.7"],"abstractmap":["16.41","16.42"],"concurrentmap":["16.41","16.42"],"segment翻译中文为":["16.41"],"段":["16.41"],"段数组对象":["16.41"],"segment":["16.41"],"segments":["16.41"],"segment是一种可重入锁":["16.41"],"reentrantlock":["16.41"],"在concurrenthashmap里扮演锁的角色":["16.41"],"将一个大的table分割成多个小的table进行加锁":["16.41"],"8版本":["16.42"],"在jdk1":["16.42"],"8中为了进一步优化concurrenthashmap的性能":["16.42"],"去掉了segment分段锁的设计":["16.42"],"在数据结构方面":["16.42"],"则是跟hashmap一样":["16.42"],"使用一个哈希表table数组":["16.42"],"链表":["16.42"],"红黑树":["16.42"],"而线程安全方面是结合cas机制":["16.42"],"局部锁实现的":["16.42"],"减低锁的粒度":["16.42"],"提高性能":["16.42"],"同时在hashmap的基础上":["16.42"],"对哈希表table数组和链表节点的value":["16.42"],"next指针等使用volatile来修饰":["16.42"],"从而":["16.42"],"实现线程可见性":["16.42"],"node数组":["16.42"],"transient":["16.42"],"node":["16.42","23.1","29.3","29.10","72.11","72.12"],"node类的定义":["16.42"],"map":["16.42","19.54","22.0","22.5","22.10","22.11","67.5","75.9"],"entry":["16.42"],"countdownlatch":["16.43"],"countdownlatch允许一个或多个线程等待其他线程完成操作以后":["16.43"],"再执行当前线程":["16.43"],"比如我们在主线程需要开启2个其他线程":["16.43"],"当其他的线程执行完毕以后我们再去执行主线程":["16.43"],"针对这":["16.43"],"个需求我们就可以使用countdownlatch来进行实现":["16.43"],"countdownlatch中count":["16.43"],"down是倒着数数的意思":["16.43"],"countdownlatch是通过一个计数器来实现的":["16.43"],"每当一个线程完成了自己的":["16.43"],"任务后":["16.43"],"可以调用countdown":["16.43"],"方法让计数器":["16.43"],"当计数器到达0时":["16.43"],"调用countdownlatch的await":["16.43"],"方法的线程阻塞状态解除":["16.43"],"继续执行":["16.43"],"countdownlatch的相关方法":["16.43"],"cyclicbarrier的字面意思是可循环使用":["16.45"],"cyclic":["16.45"],"的屏障":["16.45"],"barrier":["16.45"],"它要做的事情是":["16.45"],"让一组线程到达一个屏障":["16.45"],"也可以叫同步点":["16.45"],"时被阻塞":["16.45"],"直到最后一个线程到达屏障时":["16.45"],"屏障":["16.45"],"才会开门":["16.45"],"所有被屏障拦截的线程才会继续运行":["16.45"],"公司召集5名员工开会":["16.45"],"等5名员工都到了":["16.45"],"会议开始":["16.45"],"我们创建5个员工线程":["16.45"],"1个开会线程":["16.45"],"使用场景":["16.46","16.50"],"cyclicbarrier可以用于多线程计算数据":["16.46"],"最后合并计算结果的场景":["16.46"],"现在存在两个文件":["16.46"],"这个两个文件中存储的是某一个员工两年的工资信息":["16.46"],"一年一个文件":["16.46"],"现需要对这两个文件中的数据进行汇总":["16.46"],"使用两个线程读取2个文件中的数据":["16.46"],"当两个文":["16.46"],"件中的数据都读取完毕以后":["16.46"],"进行数据的汇总操作":["16.46"],"分析":["16.46"],"要想在两个线程读取数据完毕以后进行数据的汇总":["16.46"],"那么我们就需要定义一个任务类":["16.46"],"该类需要实现runnable接口":["16.46"],"两个线程读取完数据以后再进行数据的汇总":["16.46"],"那么我们可以将":["16.46"],"两个线程读取到的数据先存储到一个集合中":["16.46"],"而多线程环境下最常见的线程集合类就是concurrenthashmap":["16.46"],"而这个集合需要被两个线程都可以进行使用":["16.46"],"那么我们可以将这个集":["16.46"],"合作为我们任务类的成员变量":["16.46"],"然后我们在这个任务类中去定义一个cyclicbarrier对象":["16.46"],"然后在定义一个方法":["16.46"],"count":["16.46","17.17","69.7"],"当调用这个count方法的时候需要去开启两个线程对象":["16.46"],"使用这两个线程对象读取数据":["16.46"],"把读取到的数据存储到concurrenthashmap对象":["16.46"],"当一个线程读取数据完毕以后":["16.46"],"调用cyclicbarrier的awit方法":["16.46"],"告诉cyclicbarrier我已经":["16.46"],"到达了屏障":["16.46"],"然后在任务类的run方法对concurrenthashmap的数据进行汇总操作":["16.46"],"semaphore":["16.47"],"semaphore字面意思是信号量的意思":["16.47"],"它的作用是控制访问特定资源的线程数目":["16.47"],"举例":["16.47","16.49"],"现在有一个十字路口":["16.47"],"有多辆汽车需要进经过这个十字路口":["16.47"],"但是我们规定同时只能有两辆汽车经过":["16.47"],"其他汽车处于等待状态":["16.47"],"只要某一个汽车经过了这个十字路口":["16.47"],"其他的汽车才可以经":["16.47"],"过":["16.47"],"但是同时只能有两个汽车经过":["16.47"],"如何限定经过这个十字路口车辆数目呢":["16.47"],"我们就可以使用semaphore":["16.47"],"semaphore的常用方法":["16.47"],"permits":["16.47"],"exchanger":["16.49"],"交换者":["16.49"],"是一个用于线程间协作的工具类":["16.49"],"exchanger用于进行线程间的数据交换":["16.49"],"比如男女双方结婚的时候":["16.49"],"需要进行交换结婚戒指":["16.49"],"exchanger常用方法":["16.49"],"构造方法":["16.49"],"exchange":["16.49"],"x":["16.49"],"进行交换数据的方法":["16.49"],"参数x表示本方数据":["16.49"],"返回值v表示对方数据":["16.49"],"这两个线程通过exchange方法交换数据":["16.49"],"可以做数据校对工作":["16.50"],"现在存在一个文件":["16.50"],"该文件中存储的是某一个员工一年的工资信息":["16.50"],"现需要将这个员工的工资信息录入到系统中":["16.50"],"采用ab岗两人进行录入":["16.50"],"录入到两个文件中":["16.50"],"系统需要加载这两":["16.50"],"个文件":["16.50"],"并对两个文件数据进行校对":["16.50"],"看看是否录入一致":["16.50"],"创建一个测试类":["16.50"],"exchangerusedemo":["16.50"],"通过匿名内部类的方法创建两个线程对象":["16.50"],"两个线程分别读取文件中的数据":["16.50"],"然后将数据存储到各自的集合中":["16.50"],"当每一个线程读取完数据以后":["16.50"],"就将数据交换给对方":["16.50"],"然后每个线程使用对方传递过来的数据与自己所录入的数据进行比对":["16.50"],"exchangerusedemo类":["16.50"],"线程是操作系统呢能够进行运算调度的最小单位":["17.1"],"程序的基本执行实体":["17.2"],"同一时刻有多个指令在单个cpu上交替执行":["17.3"],"同一时刻有多个指令在多个cpu上同时执行":["17.4"],"java采用抢占式调度":["17.5"],"当其他非守护线程执行完毕之后":["17.6"],"创建线程对象start":["17.8"],"新建":["17.8"],"有执行资格":["17.8"],"没有执行权":["17.8"],"不停地抢cpu":["17.8"],"在java中":["17.9"],"为了确保线程安全":["17.10"],"可以采取多种方式":["17.10"],"其中常见的方式包括":["17.10"],"使用互斥锁":["17.10"],"atomic":["17.11"],"operations":["17.11"],"是指在并发编程中不可分割的":["17.11"],"synchronized":["17.12","17.13","17.17"],"线程锁":["17.12"],"synchronized的锁对象一定是唯一的":["17.12"],"可以写当前类名的字节码文件":["17.12"],"直接写在方法上":["17.13"],"同步方法是锁住方法里的所有代码":["17.13"],"锁对象不能自己指定":["17.13"],"非静态":["17.13"],"this":["17.13","23.2","23.3","38.0","44.53","45.4","45.9","60.0","69.7","70.0","71.16","72.11","72.12","73.1","73.2","74.1"],"stringbuilder用于单线程":["17.14"],"lock实现提供比使用synchronized方法和语句可以获得更广泛的锁定操作":["17.15"],"嵌套锁":["17.16"],"等待唤醒机制":["17.17"],"wait和notifyall实现":["17.17"],"foodie":["17.17"],"while":["17.17","67.1","71.16"],"true":["17.17","19.4","19.42","20.22","24.2","71.16"],"desk":["17.17"],"lock":["17.17"],"if":["17.17","50.4","51.7","59.4","67.6","67.7","71.16","72.11","72.12"],"pool":["17.18"],"cpu密集型运算":["17.19"],"输出日志":["18.1"],"前端发请求会请求到":["18.3"],"通过一个外部类pagebean收集总条数和pagesize":["18.4"],"controller编写接口":["18.4"],"getmapping":["18.4"],"emps":["18.4"],"result":["18.4"],"page":["18.4"],"requestparam":["18.4"],"defaultvalue":["18.4"],"integer":["18.4"],"简单":["19.1"],"js数据类型判断":["19.4"],"typeof":["19.4","42.32","59.4"],"检测基础数据类型和函数很好用":["19.4"],"它能准确判断出的数据类型有":["19.4"],"undefined":["19.4","24.2"],"bigint":["19.4"],"function":["19.4","19.28","19.54","21.9","23.3","34.4","41.7","42.2","42.3","42.21","42.32","45.8","45.15","45.29","45.32","51.7","53.13","53.14","59.1","59.2","59.4","59.5","59.6","59.7","59.8","59.9","59.10","61.0","61.1","62.0","65.3","65.4","65.5","66.1","66.5","67.1","67.2","67.3","67.4","67.6","67.7","69.1","69.2","69.3","69.4","69.7","70.0","70.1","71.5","71.9","71.11","71.16","72.1","72.4","72.8","72.9","72.11","72.12","73.1","74.1","74.2","76.5","77.0","88.1"],"它的缺点就是不能准确判断":["19.4"],"null":["19.4","19.36","19.39","20.13","59.4","62.0","67.1","67.7","71.16","72.11","72.12"],"的类型":["19.4"],"而是返回":["19.4"],"对于数组":["19.4"],"日期":["19.4"],"普通对象等数据":["19.4"],"统一返回":["19.4"],"所以在判断基本数据类型":["19.4"],"除了":["19.4"],"和函数类型时":["19.4"],"都会使用它":["19.4"],"str":["19.4"],"func":["19.4"],"有":["19.6"],"如果一个script加了defer属性":["19.7"],"class类里的函数默认是严格模式":["19.10"],"执行机制":["19.11"],"js是单线程的":["19.11","53.4"],"为了解决耗时任务阻塞页面渲染":["19.11"],"同步任务执行完":["19.12"],"就会去任务队列中拿一个宏任务放到执行栈中执行":["19.12"],"执行完该宏任务中的所有微任务":["19.12"],"再到任务队列中拿宏任务":["19.12"],"同步任务":["19.13","56.14"],"指排队在主线程上依次执行的任务":["19.13"],"事件循环由宏任务和在":["19.14"],"settimeout的回调不一定在指定时间后能执行":["19.15"],"永远大于":["19.16"],"调用栈":["19.17"],"拷贝":["19.18"],"深拷贝是将一个对象从内存中完整的拷贝一份出来":["19.19"],"浅拷贝是将一个对象的第一层从内存中拷贝一份出来":["19.20"],"赋值":["19.21"],"新对象改变":["19.21"],"在javascript中":["19.22","56.13"],"closure":["19.22"],"是指能够访问外部函数作用域中变量的函数":["19.22"],"当一个内部函数引用了其外部函数的变量时":["19.22"],"就形成了一个闭包":["19.22"],"闭包使得函数可以保留对其定义时作用域内的变量和参数的引用":["19.22"],"标记清除":["19.25"],"标记为离开环境":["19.25"],"等待垃圾回收":["19.25"],"函数在执行时":["19.26"],"isnan的区别":["19.27"],"找到静态方法定义在实例对象上的属性":["19.28"],"找不到实例方法定义在原型对象上的属性":["19.28"],"person":["19.28","23.3","42.19"],"tostring":["19.30","20.30","75.32","76.2"],"把基本数据类型转化为对应的引用数据类型的操作":["19.33"],"将引用数据类型转化为对应的基本数据类型的操作":["19.34"],"通过valueof或者tostring方法实现拆箱操作":["19.34"],"objnum":["19.34"],"都是空变量":["19.35"],"都是假值":["19.35"],"的区别":["19.37","22.7"],"按照双等号左右两边的转换规则":["19.42"],"匿名函数":["19.44"],"三种":["19.45","56.8"],"第三个变量传一个布尔值":["19.46"],"函数声明":["19.47","42.2"],"享受函数提升":["19.47"],"函数表达式":["19.47"],"事件冒泡":["19.48","34.13"],"ready":["19.50"],"当所有子元素都需要绑定相同的事件的时候":["19.53"],"使用":["19.54","19.74","34.4","37.3","78.4"],"去重":["19.54"],"quchong1":["19.54"],"arr":["19.54","42.1","51.7","56.0","66.1","70.0","73.1","73.2","74.1","76.4","76.5","76.6","76.7"],"有什么特点":["19.55"],"参考":["19.56","19.70","22.7","42.0","85.2"],"否影响原数组":["19.58"],"方法":["19.58","19.59","22.5","34.2","56.0"],"是否影响原数组":["19.58"],"push":["19.58","51.7","70.0","73.2","75.19"],"在数组后添加元素":["19.58"],"math":["19.59"],"max":["19.59"],"在js中有三种类型的弹出框可用":["19.60"],"日期转换为iso标准":["19.61"],"toisostring":["19.61"],"encodeuri":["19.62"],"函数用于在js中对url进行编码":["19.62"],"它将url字符串作为参数并返回编码的字符串":["19.62"],"有哪些api":["19.63"],"bom就是browser":["19.63"],"model":["19.63","80.6"],"浏览器对象模型":["19.63"],"window":["19.63"],"location":["19.63"],"的关系":["19.64"],"bom全称browser":["19.64"],"和substring":["19.65"],"函数的形式为substr":["19.66"],"函数的形式为substring":["19.67"],"use":["19.68"],"类数组":["19.71"],"arguments":["19.71"],"是一个特殊的对象":["19.71"],"表示函数调用时传入的参数列表":["19.71"],"in和for":["19.73"],"in用key遍历":["19.73"],"用于遍历对象的可枚举属性":["19.73"],"遍历的顺序不保证与对象属性的添加顺序一致":["19.73"],"of用值遍历":["19.73"],"用于遍历可迭代对象":["19.73"],"iterable":["19.73","19.74"],"的元素":["19.73"],"有哪些":["19.74"],"for":["19.74","20.26","50.2"],"循环来遍历其元素":["19.74"],"要成为可迭代对象":["19.74"],"创建一个空对象":["19.75"],"关键字会创建一个空对象":["19.75"],"作为即将创建的对象实例":["19.75"],"将空对象绑定到构造函数的原型链上":["19.75"],"event":["19.76"],"target":["19.76","26.5","45.33"],"表示事件的目标元素":["19.76"],"即触发事件的":["19.76"],"具体元素":["19.76"],"执行上下文是一种对javascript代码执行环境的抽象概念":["19.77"],"全局执行上下文":["19.77"],"prototype":["20.0","20.4","20.13","20.14","20.15","20.20","20.28","20.30","20.31","59.8","69.2","69.3","69.4","69.7","70.0","71.5","71.7","71.8","71.9","71.10","71.11","71.16","72.2","72.4","72.5","72.6","72.7","72.8","72.9","72.11","73.1","74.1","75.1","75.2","75.3","75.4","75.5","75.6","75.7","75.8","75.9","75.10","75.11","75.12","75.13","75.14","75.17","75.18","75.19","75.20","75.21","75.22","75.23","75.24","75.25","75.26","75.27","75.28","75.29","75.30","75.31","75.32","85.3"],"在":["20.1","23.1","23.2","36.5","36.10","38.2","42.9","44.35","45.24"],"创建一个新的":["20.2"],"assign":["20.3"],"通过复制一个或多个对象来创建一个新的对象":["20.3"],"浅拷贝":["20.3"],"方法用于创建一个新的实例对象":["20.4"],"使用现有的对象来作为新创建实例对象的原型对象":["20.4"],"新创建实例对象":["20.4"],"proto":["20.4"],"defineproperty":["20.5","20.6","44.41","45.7","45.15"],"obj":["20.6","20.26","36.9","42.32","45.17","59.4","59.6"],"prop":["20.6","36.11","42.32"],"descriptor":["20.6"],"defineproperties":["20.7"],"给对象添加多个属性并分别指定它们的配置":["20.7"],"entries":["20.8","75.24"],"方法返回一个给定对象自身可枚举属性的键值对数组":["20.8"],"freeze":["20.9"],"fromentries":["20.10"],"getprototypeof":["20.11","20.12"],"要返回其原型的对象":["20.12"],"setprototypeof":["20.13"],"方法设置一个指定的对象的原型":["20.13"],"即":["20.13"],"内部":["20.13"],"属性":["20.13","37.8","44.18","45.4","45.21","79.8"],"到另一个对象或":["20.13"],"isprototypeof":["20.14"],"方法用于测试一个对象是否存在于另一个对象的原型链上":["20.14"],"针对对象本身":["20.14"],"不是":["20.14"],"对象":["20.14","36.16","45.19","45.21"],"prototypeobj":["20.14"],"运算符用于检测构造函数的":["20.15"],"属性是否出现在某个实例对象的原型链上":["20.15"],"在表达式":["20.15"],"getownpropertydescriptor":["20.16"],"方法返回指定对象上一个自有属性对应的属性描述符":["20.16"],"getownpropertynames":["20.17"],"getownpropertysymbols":["20.18"],"方法返回一个给定对象自身的所有":["20.18"],"属性的数组":["20.18"],"hasown":["20.19"],"如果指定的对象自身":["20.19"],"有指定的属性":["20.19"],"静态方法":["20.19","21.8","26.1"],"hasownproperty":["20.20"],"方法会返回一个布尔值":["20.20"],"指示对象自身属性中是否具有指定的属性":["20.20"],"也就是":["20.20"],"是否有指定的键":["20.20"],"is":["20.21","20.22"],"方法判断两个值是否为同一个值":["20.21"],"不同":["20.22"],"运算符在判断相等前对两边的变量":["20.22"],"如果它们不是同一类型":["20.22"],"进行强制转换":["20.22"],"这种行为将":["20.22"],"判断为":["20.22"],"而":["20.22"],"isextensible":["20.23"],"isfrozen":["20.24"],"keys":["20.25","34.25","45.9","75.22"],"values":["20.26","75.23"],"方法返回一个给定对象自身的所有可枚举属性值的数组":["20.26"],"值的顺序与使用":["20.26"],"in":["20.26"],"循环的顺序相同":["20.26"],"区别在于":["20.26"],"循环枚举原型链中的属性":["20.26"],"foo":["20.26"],"preventextensions":["20.27"],"seal":["20.29"],"方法返回一个表示该对象的字符串":["20.30"],"该方法旨在重写":["20.30"],"自定义":["20.30"],"派生类对象的类型转换的逻辑":["20.30"],"valueof":["20.31"],"的":["20.31","36.5","37.3","37.18","38.2"],"promise是es6处理异步的一种方式":["21.0"],"它的本质是一个对象":["21.0"],"一":["21.1","25.1"],"promise":["21.1","21.3","21.5","21.6","21.8","56.13"],"then":["21.1"],"res":["21.1"],"catch":["21.1"],"err":["21.1"],"它有三种状态分别为":["21.2"],"初始状态pending":["21.2"],"已完成fulfilled":["21.2"],"已失败rejected":["21.2"],"如果resolve传入一个普通的值或者对象":["21.3"],"只能传递接受一个参数":["21.3"],"那么这个值会作为then回调的参数":["21.3"],"resolve":["21.3","21.5","21.8","60.0"],"实例方法":["21.4","22.3"],"then方法可以接受参数":["21.5"],"一个参数为成功的回调":["21.5"],"另一个参数为失败的回调":["21.5"],"reject":["21.5","21.8"],"success":["21.5","79.1"],"catch的多次调用":["21.6"],"无论promise状态是fulfilled还是rejected都会执行一次finally方法":["21.7"],"ice":["21.8"],"等价于":["21.8"],"error":["21.8"],"all":["21.8"],"fulfilled状态":["21.8"],"promise1":["21.8"],"settimeout":["21.8","85.1"],"resolve里储存异步数据":["21.9"],"外部则还是同步的":["21.9"],"fn":["21.9","62.0"],"await":["21.10"],"acync里面没有await则不起作用相当于还是同步的":["21.10"],"await调用函数后":["21.10"],"当前函数后的所有代码":["21.10"],"集合":["22.1","22.7"],"是一种叫做集合的数据结构":["22.1"],"向":["22.1"],"加入值的时候":["22.1"],"不会发生类型转换":["22.1"],"实例属性":["22.2"],"constructor":["22.2","22.8","34.6","34.26","45.4","45.9","60.0","72.12","73.2"],"构造函数":["22.2","22.8"],"value":["22.3","28.2","36.9","45.9","45.26","60.0","69.2","73.2"],"存在即删除集合中value":["22.3"],"has":["22.3"],"from方法可以将":["22.4"],"set":["22.4","22.6","45.22","56.0","67.4"],"结构转为数组":["22.4"],"filter":["22.5","75.14"],"很容易实现交集":["22.6"],"intersect":["22.6"],"并集":["22.6"],"union":["22.6"],"差集":["22.6"],"difference":["22.6"],"字典":["22.7"],"转":["22.9","22.10"],"map的键值对可以使基本数据类型":["22.11"],"也可以是对象引用":["22.11"],"环境下":["23.1"],"全局的":["23.1"],"的值一般有以下几种情况":["23.2"],"全局作用域中的":["23.2"],"new操作符创建实例":["23.3"],"call":["23.4"],"bind三者的区别":["23.4"],"相等运算符":["24.1","24.2"],"最终转换为数字进行比较":["24.2"],"nan":["24.2"],"中一些常见运算符的优先级":["24.3"],"从高到低":["24.3"],"用户访问app系统":["25.1"],"app系统是需要登录的":["25.1"],"但用户现在没有登录":["25.1"],"跳转到sso登录系统":["25.1"],"sso系统也没有登录":["25.1"],"弹出用户登录页":["25.1"],"用户填写用户名":["25.1"],"从可迭代或者类数组对象创建一个浅拷贝的数组实例":["26.1"],"创建一个数组":["26.1"],"参数是数组的值":["26.1"],"通过使用迭代器和解构赋值把索引和值一起返回":["26.4"],"将指定位置的成员复制到其他位置":["26.5"],"会覆盖原有成员":["26.5"],"然后返回当前数组":["26.5"],"参数如下":["26.5"],"regular":["27.0"],"expression":["27.0"],"简称regexp":["27.0"],"是一种强大的文本匹配工具":["27.0"],"它可以用来查找":["27.0"],"替换":["27.0"],"分割文本等":["27.0"],"下面是一些基本的正则表达式语法和用法":["27.0"],"创建正则表达式对象":["27.0"],"表单输入框":["28.2"],"常规":["28.2"],"禁用":["28.2"],"尺寸":["28.2"],"一键清空":["28.2"],"密码显示隐藏":["28.2"],"带icon图标":["28.2"],"文本域自适应宽高":["28.2"],"复合型输入框":["28.2"],"input组件的核心功能":["28.2"],"双向数据绑定":["28.2"],"原生input的v":["28.2"],"model其实就是":["28.2"],"因为vite打包样式文件是会把所有的组件的样式合并到一个css文件中":["28.3"],"gulp很方便":["28.4"],"在组件库上ts主要用来写打包的配置文件":["28.5"],"把api放在一个文件":["28.6"],"pinia里存放了一个data是一个空数组":["28.7"],"js构建的后端服务器怎么写的":["28.8"],"并行开发":["28.9"],"前后端分离允许前端和后端团队并行开发":["28.9"],"不受彼此的依赖关系限制":["28.9"],"这可以显著加快整个开发过程":["28.9"],"2是http":["28.10"],"1的升级版本":["28.10"],"mitm":["28.11"],"在https通信中":["28.11"],"配置资源文件的缓存可以通过使用http响应头中的cache":["28.12"],"control和expires字段来实现":["28.12"],"这些字段可以告诉客户端":["28.12"],"浏览器":["28.12","30.10"],"如何缓存和重新获取资源文件":["28.12"],"使用cache":["28.12"],"shift":["28.13","73.1","73.2","75.20"],"布局偏移":["28.13"],"代码优化":["28.14"],"选择高效的框架和库":["28.14"],"选择经过优化和性能良好的框架和库":["28.14"],"以确保代码执行效率和响应速度":["28.14"],"减少重绘和回流":["28.14"],"避免频繁的dom操作":["28.14"],"合并多个操作":["28.14"],"webgpu是一种新兴的web标准":["28.15"],"而pnpm使用":["28.16"],"硬链接技术":["28.16"],"如何处理":["29.1"],"es6":["29.1","29.4","34.4"],"语法上面":["29.2"],"commonjs":["29.2","29.4"],"要求":["29.3"],"模块import命令":["29.4"],"可以":["29.4"],"是在package":["29.5"],"json文件的exports字段":["29.5"],"指明两种格式模块各自的加载入口":["29.5"],"可以直接在node中使用":["29.6"],"process表示控制当前node进程":["29.7"],"获取文件夹路径":["29.8"],"读取磁盘中的文件":["29.9"],"cookie":["30.4"],"cookie的创建":["30.4"],"修改和创建相同":["30.4"],"创建同样名称会覆盖之前的":["30.4"],"john":["30.4"],"使用token机制的身份验证方法":["30.8"],"客户端使用用户名和密码请求登录":["30.8"],"客户端":["30.8"],"cookie是一种在客户端":["30.10"],"存储数据的机制":["30.10"],"它允许服务器在浏览器中存储少量的数据":["30.10"],"并在需要时读取这些数据":["30.10"],"相较于webpack":["31.0"],"json":["31.1","32.5"],"pnpm":["31.2"],"config":["31.3","32.1"],"使用步骤":["32.0"],"单一入口":["32.3"],"打包成一个文件":["32.3"],"filename":["32.4"],"webpack":["32.5","32.7"],"只能理解":["32.5"],"文件":["32.5"],"这是":["32.5"],"兼容问题":["32.6"],"将新代码转为旧代码":["32.6"],"提高兼容性":["32.6"],"插件":["32.7"],"dev":["32.8"],"sourcemap":["32.9"],"这里是":["33.0"],"的面试题":["33.0"],"特性有很多":["34.1"],"在react":["34.2"],"类组件只要执行了setstate":["34.2"],"就一定会触发":["34.2"],"render":["34.2","34.5","34.26"],"vue是在组件实例创建之后dom挂载之前拿数据":["34.3"],"函数组件和类组件是":["34.4"],"react":["34.4","34.9","34.15","34.16","34.19","34.23","34.31","36.5","36.7","36.9","36.10","38.2","38.6","38.8","41.5"],"中两种主要的组件类型":["34.4"],"它们在语法和用法上有一些区别":["34.4"],"语法":["34.4","42.13"],"函数组件是以函数的形式定义的组件":["34.4"],"使用函数声明或函数表达式的方式创建":["34.4"],"而类组件是以":["34.4"],"类的形式定义的组件":["34.4"],"关键字创建":["34.4"],"functioncomponent":["34.4"],"return":["34.4","42.32","44.34","51.7","59.4","61.0","67.6","67.7","69.7","73.1","73.2"],"hello":["34.4","37.4"],"挂载阶段":["34.5","34.6"],"componentwillmount":["34.5"],"17废弃":["34.5"],"componentdidmount":["34.5"],"更新阶段":["34.5"],"componentwillreceiveprops":["34.5"],"shouldcomponentupdate":["34.5"],"componentwillupdate":["34.5"],"mounting":["34.6"],"phase":["34.6"],"组件被创建时调用":["34.6"],"用于初始化状态和绑定方法":["34.6"],"getderivedstatefromprops":["34.6","34.7","34.26"],"在组件实例化和更新时被调用":["34.6"],"nextprops":["34.7"],"prevstate":["34.7","34.8"],"prevprops":["34.8"],"在更新阶段":["34.8"],"有状态组件是指在其内部维护了状态":["34.9"],"state":["34.9","36.3","38.0","38.5","41.1","41.3","44.34","45.21","52.5","60.0"],"的组件":["34.9"],"这种组件通常是通过继承":["34.9"],"从底层实现来看修改数据":["34.10","40.1"],"在react中":["34.10","40.1","44.59"],"组件的状态是不能被修改的":["34.10","40.1"],"setstate没有修改原来那块内存中的变量":["34.10"],"fiber":["34.11"],"fiber使得diff的过程被分成一小段一小段的":["34.11"],"因为它有了":["34.11"],"保存工作进度":["34.11"],"的能力":["34.11"],"js会比较一部分虚拟dom":["34.11"],"react因为先天的不足":["34.12"],"react自身实现了一套自己的事件机制":["34.13"],"包括事件注册":["34.13"],"事件的合成":["34.13"],"注册过程要进行两件事":["34.14"],"事件注册":["34.14"],"事件存储":["34.14"],"react17废除":["34.14"],"syntheticevent":["34.15"],"这个对应关系存放在":["34.16"],"事件对象可能会被频繁创建和回收":["34.17"],"因此":["34.17"],"react16之前":["34.17"],"原生事件阻止冒泡肯定会阻止合成事件的触发":["34.18"],"所有事件都挂载在":["34.19"],"的事件机制":["34.20"],"hoc是一种用于组件重用逻辑的技术":["34.21"],"本质上是一个函数":["34.21"],"接受一个组件作为参数并返回一个新的增强组件":["34.21"],"hoc可以通过将一些通用的功能":["34.21"],"状态或行为添加到现有组件中":["34.21"],"从而提供一种灵活的复制方式":["34.21"],"它可以用于在不修改原始组的情况下件代码的情况添加新的功能或修改现有的功能":["34.21"],"使用hoc":["34.21"],"你可以将共享的逻辑从组件中提取出来":["34.21"],"createclass和extends":["34.22"],"component的区别":["34.22"],"语法区别":["34.22"],"三个阶段":["34.24"],"render阶段":["34.24"],"的作用":["34.25"],"父子组件初始化":["34.26"],"父组件":["34.26"],"接受一个或多个函数作为输入":["34.27"],"输出一个函数":["34.27"],"高阶组件的主要功能是封装并分离组件的通用逻辑":["34.27"],"区别":["34.28"],"在组件内直接使用":["34.28"],"csstransition":["34.29"],"在前端开发中":["34.29"],"结合":["34.29"],"来完成过渡动画效果":["34.29"],"每个功能模块对应一个目录":["34.30"],"错误边界是一种":["34.31"],"策略一":["35.1"],"树的diff":["35.1"],"diff":["35.1","35.4"],"层级控制":["35.1"],"对dom节点的跨层级操作不做优化":["35.1"],"只对两棵树同一层级进行比较":["35.1"],"即同一个父节点下的所有子节点":["35.1"],"当发现节点已经不存在":["35.1"],"则该节点及其子节点会被完全删除掉":["35.1"],"双端比较":["35.2"],"生成新的虚拟dom树":["35.2","44.50"],"在每次数据更新时":["35.2","44.50"],"vue":["35.2","39.1","39.2","39.3","39.4","43.3","44.17","44.18","44.22","44.50","46.0","46.1","56.11"],"js会重新构建一棵新的虚拟dom树":["35.2","44.50"],"四个指针":["35.3"],"使用旧列表的头一个节点oldstartnode与新列表的头一个节点newstartnode对比":["35.3"],"使用旧列表的最后一个节点oldendnode与新列表的最后一个节点newendnode对比":["35.3"],"最长递增子序列":["35.4"],"前置与后置的预处理":["35.4"],"前置节点的处理是定义了一个":["35.4"],"j":["35.4"],"分别指向新":["35.4"],"老两个组子节点":["35.4"],"新老两组的子节点都有剩余":["35.5"],"该状态下主要核心为3个部分":["35.5"],"构建source数组用于":["35.5"],"存放新的一组子节点每个节点在老的一组中存在的原来位置":["35.5"],"jsx转换成真实dom过程":["35.6"],"所有的":["35.6"],"限制":["36.1"],"不要在循环":["36.2"],"条件或嵌套函数中调用":["36.2"],"维护状态":["36.3"],"setstate":["36.4","36.5","38.1","38.2"],"函数实现中":["36.5","38.2"],"同步":["36.6","38.3"],"异步总结":["36.6","38.3"],"异步的情况":["36.6","38.3"],"完成副作用操作":["36.7"],"中的一个":["36.7"],"hook":["36.7"],"用于处理副作用操作":["36.7"],"side":["36.7"],"effects":["36.7"],"订阅事件":["36.7"],"获取数据":["36.7"],"useeffect":["36.8","38.8"],"使用共享状态":["36.9"],"可以使用":["36.9"],"来获取父级组件传递过来的":["36.9"],"context":["36.9"],"这个当前值就是最近的父级组件":["36.9"],"provider":["36.9","41.5"],"设置的":["36.9"],"只能用于函数组件中":["36.9"],"无法在类组件中使用":["36.9"],"objcontext":["36.9"],"createcontext":["36.9"],"它可以用来缓存函数":["36.10"],"以避免在每次渲染时都创建新的函数实例":["36.10"],"组件中":["36.10"],"每次渲染时都会":["36.10"],"创建新的函数实例":["36.10"],"只有当函数作为":["36.11"],"用于在函数组件中缓存":["36.12"],"计算结果":["36.12"],"usememo和usecallback用法差不多":["36.13"],"memo":["36.14"],"是一个用于优化性能的":["36.14"],"usememo":["36.15"],"usecallback":["36.15"],"父组件重新渲染":["36.15"],"没有被":["36.15"],"包裹的子组件也会重新渲染":["36.15"],"被":["36.15"],"包裹的组件":["36.15"],"只有在":["36.15"],"props":["36.15","37.12","38.5","42.23","44.27","44.51","52.4"],"可以用来在函数组件中":["36.16"],"保存和访问":["36.16"],"元素":["36.16","36.17"],"或其他可变的值":["36.16"],"而不需要触发组件的重新渲染":["36.16"],"返回一个可变的":["36.16"],"ref":["36.16","45.25","45.26"],"它的":["36.16"],"useref":["36.17"],"可以用于访问组件实例或":["36.17"],"具体取决于将":["36.17"],"关联到的目标":["36.17"],"访问":["36.17"],"当你将":["36.17"],"关联到一个":["36.17"],"它用于协调":["36.20"],"router":["37.0","37.2","37.17","43.0","43.1"],"路由的本质就是页面的url发生改变时":["37.1"],"hashrouter":["37.3"],"使用两者作为最顶层组件包裹其他组件":["37.3"],"html5":["37.3","43.5"],"history":["37.3"],"route组件是用于路径的匹配":["37.4"],"通过该组件将url地址和react组件进行映射":["37.4"],"映射后当url地址变为指定地址时指定的组件就会显示":["37.4"],"否则不显示":["37.4"],"通过props传进来的path与context传进来的pathname进行匹配":["37.4"],"用来设置要映射的路径":["37.4"],"可以是一个字符串或字符串数组":["37.4"],"字符串用来匹配单个路径":["37.4"],"数组可以匹配多个路径":["37.4"],"jsx":["37.4","37.9","37.15","38.8"],"route":["37.4"],"about":["37.4"],"用于路由的重定向":["37.5"],"swich组件的作用适用于当匹配到第一个组件的时候":["37.6"],"usehistory":["37.7"],"history对象":["37.8"],"用来读取和操作浏览器的历史记录":["37.8"],"页面跳转":["37.8"],"等功能":["37.8"],"length":["37.8","51.7","72.11","72.12"],"历史记录的数量":["37.8"],"设置动态参数后":["37.9"],"在组件的内部可以使用useparams":["37.9"],"钩子来读取参数":["37.9"],"student":["37.9"],"会返回当前":["37.10"],"url的":["37.10"],"location对象":["37.10"],"pathname":["37.10"],"router5的":["37.11"],"动态路由":["37.12"],"将path在route匹配时写成":["37.12"],"detail":["37.12"],"params参数":["37.12"],"match":["37.12"],"params":["37.12","43.15"],"xxx":["37.12","44.29"],"获取":["37.12"],"useparams":["37.12"],"和版本5不同":["37.13"],"并且route组件必须放到routes中":["37.14"],"在版本6中route组件是可以嵌套的":["37.15"],"可以通过嵌套route来构建出嵌套路由":["37.15"],"像这样":["37.15"],"只有一个功能":["37.16"],"挂钩在内部使用此函数来匹配相对于当前位置的路由路径":["37.16"],"的render和component和children的区别":["37.17"],"component使用react":["37.17"],"来创建该组件":["37.17"],"而render是直接运行赋值给render这个prop的函数并带上props参数来创建该组件":["37.17"],"link":["37.18"],"跳转":["37.18"],"navlink":["37.19"],"会对一个组件的":["38.0"],"对象安排一次更新":["38.0"],"当":["38.0"],"改变了":["38.0"],"该组件就会重新渲染":["38.0"],"调用":["38.0"],"其实是异步的":["38.0"],"在调用":["38.0"],"之后":["38.0"],"会立即映射为新的值":["38.0"],"异步的好处":["38.4"],"为什么要设计成异步的":["38.4"],"properties":["38.5"],"的缩写":["38.5"],"都是普通的":["38.5"],"为我们提供了":["38.6"],"proptypes":["38.6"],"组件第一次渲染时不会执行componentwillreceiveprops":["38.7"],"当props发生变化的时时候会执行componentwillreceiveprops":["38.7"],"在componentwillreceiveprops里面":["38.7"],"旧的属性可以通过this":["38.7"],"props来获取":["38.7"],"新的属性则可以通过参数nextprops来获取":["38.7"],"import":["38.8","41.5","41.8","44.34","78.2","79.2","79.3","82.2"],"usestate":["38.8"],"redux":["39.5","41.0"],"vue的响应式原理":["40.1"],"组件渲染生成一棵新的虚拟dom树":["40.2"],"是一个独立于框架的状态管理库":["41.0"],"最初是为":["41.0"],"状态":["41.1","41.3","52.5"],"是应用程序的中央数据存储库":["41.1","52.5"],"redux是一个可预测的状态容器":["41.3"],"createstore可以帮助创建":["41.4"],"store":["41.4","41.9","44.35","52.6"],"dispatch":["41.4"],"帮助派发":["41.4"],"一个复杂的reducer分成几个reducer":["41.5"],"最后用":["41.5"],"combinereducers":["41.5"],"合并":["41.5"],"创建reducer的参数state可以写默认值":["41.5"],"创建store后":["41.5"],"需要引入react":["41.5"],"redux中提供的provider组件":["41.5"],"将其设置到所有组件的最外层":["41.5"],"并且将刚刚创建的store设置为组件的store属性":["41.5"],"只有这样才能使得redux中的数据能被所有的组件访问到":["41.5"],"redux还为我们提供一个钩子函数useselector":["41.5"],"用于获取redux中存储的数据":["41.5"],"它需要一个回调函数作为参数":["41.5"],"回调函数的第一个参数就是当前的state":["41.5"],"回调函数的返回值":["41.5"],"会作为useselector的返回值返回":["41.5"],"reactdom":["41.5"],"client":["41.5"],"中间件的作用":["41.6"],"就是在":["41.6"],"源数据":["41.6"],"到":["41.6"],"目标数据":["41.6"],"中间做各种处理":["41.6"],"有利于程序的可拓展性":["41.6"],"applymiddleware":["41.7","41.8"],"export":["41.7"],"default":["41.7","44.34","79.1"],"createstore":["41.8"],"next":["41.9","67.1","72.11","72.12"],"action":["41.9","44.35"],"调用下一个中间件或":["41.9"],"reducer":["41.9"],"middleware1":["41.9"],"middleware":["41.9"],"currying":["41.10"],"嵌套函数":["41.10"],"相当于c":["41.10"],"a的返回值传给b":["41.10"],"b的返回值传给c":["41.10"],"ts":["42.1","42.2","42.6","42.10","42.13","42.17","42.19","42.20","42.21","42.25","42.32"],"let":["42.1","42.6","42.10","42.13","51.7","62.0","67.1","67.2","67.6","69.2","69.4","71.16","76.4","77.1","77.2","77.3","77.5"],"sun":["42.2"],"可选参数":["42.3"],"buildnmae":["42.3"],"firstname":["42.3"],"函数重载或方法重载是使用相同名称和不同参数数量或类型创建多个方法的一种能力":["42.4"],"方法就是为同一个函数提供多个函数类型定义来进行函数重载":["42.4"],"编译器会根据这个列表去处理函数的调用":["42.4"],"combinable":["42.4"],"元组是":["42.5"],"typescript":["42.5","42.16","42.17","42.24","42.32"],"中特有的类型":["42.5"],"void表示没有任何类型":["42.7"],"和其他类型是平等关系":["42.7"],"不能直接赋值":["42.7"],"never类型表示的是那些永不存在的值的类型":["42.8"],"值会永不存在的两种情况":["42.8"],"如果一个函数执行时抛出了异常":["42.8"],"那么这个函数永远不存在返回值":["42.8"],"因为抛出异常会直接中断程序运行":["42.8"],"这使得程序运行不到返回值那一步":["42.8"],"即具有不可达的终点":["42.8"],"也就永不存在返回了":["42.8"],"函数中执行无限循环的代码":["42.8"],"死循环":["42.8"],"unknown与any一样":["42.10"],"所有类型都可以分配给unknown":["42.10"],"unknown与any的最大区别是":["42.10"],"任何类型的值可以赋值给any":["42.10"],"同时any类型的值也可以赋值给任何类型":["42.10"],"任何类型的值都可以赋值给它":["42.10"],"但它只能赋值给unknown和any":["42.10"],"notsure":["42.10"],"小":["42.11"],"代表的是所有非原始类型":["42.11"],"也就是说我们不能把":["42.11"],"我们把":["42.12"],"尖括号":["42.13"],"在上下文中当类型检查器无法断定类型时":["42.14"],"一个新的后缀表达式操作符":["42.14"],"允许在实例属性和变量声明后面放置一个":["42.15"],"号":["42.15"],"从而告诉":["42.15"],"支持":["42.16"],"将":["42.17"],"定义为一个不可变更的常量":["42.17"],"在缺省类型注解的情况下":["42.17"],"推断出它的类型直接由赋值字面量的类型决定":["42.17"],"在面向对象语言中":["42.18"],"只读属性":["42.19"],"interface":["42.19","42.21","42.23"],"readonly":["42.19","45.25"],"有时候我们希望一个接口中除了包含必选和可选属性之外":["42.20"],"还允许有其他的任意属性":["42.20"],"这时我们可以使用":["42.20"],"索引签名":["42.20"],"的形式来满足上述要求":["42.20"],"所谓的鸭式辨型法就是像鸭子一样走路并且嘎嘎叫的就叫鸭子":["42.21"],"即具有鸭子特征的认为它就是鸭子":["42.21"],"也就是通过制定规则来判定对象是否实现这个接口":["42.21"],"labeledvalue":["42.21"],"label":["42.21","55.2"],"functions":["42.25"],"两者都可以用来描述对象或函数的类型":["42.25"],"但是语法不同":["42.25"],"types":["42.26"],"与接口不同":["42.26"],"类型别名还可以用于其他类型":["42.26"],"如基本类型":["42.26"],"原始值":["42.26"],"类型别名不可以":["42.27"],"与类型别名不同":["42.27"],"两者的扩展方式不同":["42.28"],"但并不互斥":["42.28"],"接口可以扩展类型别名":["42.28"],"同理":["42.28"],"类型别名也可以扩展接口":["42.28"],"接口的扩展就是继承":["42.28"],"通过":["42.28","44.64","45.17"],"用了一个":["42.29"],"类型":["42.29"],"t":["42.29","42.32"],"这个":["42.29"],"类型约束使用":["42.30"],"关键字":["42.30"],"的主要用途是在类型上下文中获取变量或者属性的类型":["42.32"],"keyof":["42.32"],"操作符是在":["42.32"],"版本引入的":["42.32"],"该操作符可以用于获取某种类型的所有键":["42.32"],"其返回类型是联合类型":["42.32"],"key":["42.32","45.33","69.2","69.4","71.3","71.5","71.11","71.16"],"在以上代码中":["42.32"],"我们使用了":["42.32"],"的泛型和泛型约束":["42.32"],"首先定义了":["42.32"],"类型并使用":["42.32"],"关键字约束该类型必须是":["42.32"],"router是什么":["43.2"],"描述一下它的原理":["43.2"],"即url中的":["43.4"],"以及后面部分":["43.4"],"mode是html5新增":["43.5"],"所以也称为history":["43.5"],"内置组件跳转":["43.6"],"为什么":["43.7"],"如果需要用户登陆":["43.7"],"我们来守卫页面":["43.7"],"强制用户跳转到登录页面":["43.7"],"路由守卫分为全局路由守卫":["43.7"],"路由独享守卫":["43.7"],"组件路由守卫":["43.7"],"全局路由守卫":["43.7"],"全局前置守卫beforeeach":["43.7"],"接收to":["43.7"],"导航被触发":["43.8"],"在失活的组件里调用":["43.8"],"beforerouteleave":["43.8"],"守卫":["43.8"],"调用全局的":["43.8"],"为给客户更好的客户体验":["43.9"],"router路由懒加载的方式":["43.11"],"router配置路由":["43.11"],"将任意信息附加到路由上":["43.12"],"有时候":["43.13"],"进入某个路由后":["43.13"],"动态路由参数":["43.14","43.15"],"传递方式":["43.15"],"是通过路由的路径进行传递的":["43.15"],"他是一个流行的前端框架":["44.1"],"单页应用":["44.2"],"vue2":["44.3","44.27","44.53","52.0","52.4"],"选项式api":["44.3","52.0"],"vue3":["44.3","44.27","44.53","52.0","52.4"],"setup":["44.3","44.5"],"setup函数是组件中的一个特殊函数":["44.4"],"beforecreate":["44.5"],"created":["44.5","46.3"],"常用于":["44.5"],"数据请求":["44.5"],"渲染过程":["44.6"],"父beforecreate":["44.6"],"如果子组件是异步组件的话它们的执行顺序会发生改变":["44.7"],"if和v":["44.8"],"for和v":["44.9"],"if优先级":["44.9"],"computed是计算属性":["44.10"],"当一个属性受一个或者多个属性影响的时候可以使用":["44.10"],"watch是侦听器":["44.10"],"当我们需要根据一个属性的变化而做出一些处理的时候":["44.10"],"computed和methods的差异是它具备缓存性":["44.11"],"computed属性可以":["44.12"],"computed计算属性不支持异步":["44.13"],"计算属性computed常用场景是":["44.14"],"computed":["44.15","44.19"],"一种是方法":["44.16"],"在创建":["44.17","44.18"],"watch":["44.20"],"写法上的区别":["44.21","51.3"],"vue2使用的是options":["44.21","51.3"],"选项":["44.21","51.3"],"模板":["44.22"],"应用程序的入口是一个":["44.22"],"其中包含":["44.22"],"的标识符和指令":["44.22"],"在初始化阶段":["44.22"],"实现响应式的核心是通过":["44.23"],"数据劫持":["44.23","45.7"],"响应式数组":["44.24"],"将组件实例挂载到全局":["44.25"],"插槽slot可以理解为占坑":["44.26"],"当使用一个组件的时候":["44.26"],"在组件标签里的对应的":["44.26"],"内容就会替换":["44.26"],"掉这个组件中的":["44.26"],"slot标签":["44.26"],"插槽分为默认插槽":["44.26"],"具名插槽":["44.26","44.57"],"作用域插槽":["44.26","44.32"],"默认插槽":["44.26"],"子组件中用slot标签来确定渲染位置":["44.26"],"方式":["44.27","52.4"],"父传子":["44.27","44.51","52.4"],"props定义在子组件里":["44.28"],"子组件通过自定义事件往父组件里传值":["44.29"],"父组件调用子组件通过v":["44.29"],"on接收":["44.29"],"父组件里给子组件自定义事件":["44.29"],"在vue中":["44.31"],"使用ref可以在组件中引用子组件或dom元素":["44.31"],"可以传递数据的插槽":["44.32"],"子组件可以将数据传给父组件":["44.32"],"vuex是vue中的全局状态管理框架":["44.33"],"它可以管理应用的所有组件的状态":["44.33"],"并不是每个项目都需要引入vuex的":["44.33"],"创建store":["44.34"],"definestore":["44.34"],"exporet":["44.34"],"mystore":["44.34"],"ljt":["44.34"],"孙悟空":["44.34"],"里调用其他":["44.35"],"里的":["44.35"],"也比较简单":["44.35"],"引入对应的":["44.35"],"alive":["44.37"],"keepalive":["44.37"],"是一个内置组件":["44.37"],"它的功能是在多个组件间动态切换时缓存被移除的组件实例":["44.37"],"首次执行执行顺序":["44.38"],"mixin":["44.40"],"混入":["44.40"],"proxy":["44.41","45.17","45.19"],"vue3新增了两个内置组件分别是teleport和suspense":["44.42"],"可以称之为传送门":["44.43"],"作用将其插槽内容渲染到":["44.43"],"suspense":["44.44"],"在下次":["44.46"],"diff算法":["44.47"],"每当我们用原生js或者jq操作dom时":["44.48"],"对比两棵vdom":["44.49"],"树":["44.49"],"找到有差异的部分":["44.49"],"表示新的ui结构":["44.50"],"透传":["44.51"],"在父组件里引用的子组件上使用":["44.51"],"bind":["44.51","60.0"],"定义一个方法":["44.52"],"将参数hide传递给父组件":["44.52"],"父组件通过":["44.52"],"nexttick":["44.53"],"for的key":["44.54"],"suspense是一种用于在异步组件加载期间显示占位符内容的特性":["44.55"],"ref适合基础类型的值将其包装为响应式对象":["44.56"],"父":["44.57"],"template":["44.57"],"指的是view层和model层之间的映射关系":["44.59"],"当view层发生更改时":["44.59"],"vs":["44.60"],"双向数据流":["44.60"],"网络延时问题":["44.61"],"减小入口文件积":["44.62"],"路由懒加载":["44.62"],"如果是大型项目你该怎么划分结构和划分组件呢":["44.63"],"文件夹和文件夹内部文件的语义一致性":["44.63"],"的响应式":["45.0"],"当对象之间存在一对多的依赖关系时":["45.2"],"其中一个对象的状态发生改变":["45.2"],"基于一个事件":["45.3"],"主题":["45.3"],"通道":["45.3"],"希望接收通知的对象":["45.3"],"大意":["45.4"],"通过observe里的definereactive方法里面的object":["45.4"],"defineproperty方法的get":["45.4"],"读取数据触发":["45.4"],"收集依赖":["45.4"],"和set":["45.4"],"修改数据触发":["45.4"],"派发更新依赖":["45.4"],"进行响应式的绑定":["45.4"],"在set里数据变了":["45.4"],"监听到了就去更新视图":["45.4"],"details":["45.4","72.11","72.12"],"显示代码":["45.4"],"响应式数据处理":["45.4"],"构造一个响应式对象":["45.4"],"observer":["45.4","45.9"],"data":["45.4","45.8","72.4","72.9","72.11","72.12"],"walk":["45.4","45.9"],"遍历对象的每个":["45.4"],"已定义":["45.4"],"分别执行":["45.4"],"响应系统":["45.5"],"其核心有三点":["45.5"],"observe":["45.5","45.6"],"响应式":["45.5"],"watcher":["45.5","45.11"],"数据代理":["45.7"],"被object":["45.7"],"defineproperty绑定过的对象":["45.7"],"我们需要一个全局的变量来保存这个属性的值":["45.8"],"value使用了参数默认值":["45.8"],"如果obj有多个属性呢":["45.9"],"我们可以新建一个类observer来遍历该对象":["45.9"],"vue中用observer类来管理上述响应式化object":["45.9"],"defineproperty的过程":["45.9"],"改写了array":["45.10"],"dep收集的依赖就是watcher":["45.11"],"watcher订阅一个或多个数据":["45.12"],"直接渲染render":["45.13"],"有通过computed计算属性改变":["45.13"],"常见的场景有下面这几个":["45.13"],"数据变":["45.13"],"使用数据的视图变":["45.13"],"使用数据的计算属性变":["45.13"],"使用计算属性的视图变":["45.13"],"dep":["45.14"],"使用发布订阅者模式":["45.14"],"每个属性拥有自己的消息订阅器":["45.14"],"dep类里的this":["45.14"],"subs":["45.14"],"我们如何知道data中的某个属性被使用了":["45.15"],"答案就是object":["45.15"],"因为读取某个属性就会触发get方法":["45.15"],"可以将代码进行如下改造":["45.15"],"的响应式原理":["45.16"],"因为":["45.16"],"的响应式原理依赖了":["45.17"],"这个核心":["45.17"],"api":["45.17","51.3"],"可以劫持对象的某些操作":["45.17"],"get时":["45.18"],"收集不同代理对象不同属性所依赖的副作用函数":["45.18"],"set时":["45.18"],"取出当前属性所依赖的所有副作用函数":["45.18"],"重新执行":["45.18"],"内部的执行过程":["45.18"],"reactive":["45.19","45.25"],"会返回如下一个":["45.19"],"effect":["45.20","45.21","62.0"],"首先定义全局的":["45.20"],"activeeffect":["45.20","62.0"],"它永远指向当前正在执行的":["45.20"],"track":["45.21"],"会建立一个":["45.21"],"counter":["45.21"],"的一个依赖关系":["45.21"],"trigger":["45.22"],"数据变化的时候就会触发代理对象的":["45.22"],"如果函数依赖于外部的状态":["45.23"],"3的响应式原理比较":["45.24"],"响应式数据声明的核心api":["45.25"],"shallowref":["45.25"],"shallowreactive":["45.25"],"shallowreadonly":["45.25"],"shallow浅层作用形式":["45.25"],"虽然常常有文章说一般只用来":["45.26"],"声明基础数据的响应式":["45.26"],"但是其实所有的数据类型声明响应式时都可以使用ref":["45.26"],"只是内部为了同时实现基础数据的响应式处理":["45.26"],"封装成了一个具有":["45.26"],"activeeffect自动把effect函数收集起来放进对应的dep里":["45.27"],"track函数用来把effect函数收集起来放进dep里":["45.28"],"dep为什么用set呢":["45.28"],"因为set可以自动去重":["45.28"],"搜集起来之后":["45.28"],"以后只要变量一改变":["45.28"],"就执行trigger函数通知dep里所有依赖money变量的effect函数执行":["45.28"],"对象里每一个属性都有一个dep":["45.30"],"来存储每个对象对应的map":["45.31"],"receiver相当于proxy代理的对象":["45.32"],"替代原对象target":["45.32"],"在receiver上访问和修改":["45.32"],"vue中指令的注册和组件的注册一样":["46.2"],"提供了全局注册和局部注册两种方式":["46.2"],"全局注册就是指我们定义的指令可以在项目中任意地方都可以使用":["46.2"],"局部注册则意味着只能在注册的当前组件中使用":["46.2"],"接下来我们就来学习这两种注册指令的方式":["46.2"],"我们通过app":["46.2"],"directive的方式全局注册指令":["46.2"],"它有两个参数":["46.2"],"directive的第二个参数是钩子函数对象":["46.3"],"mydirective":["46.3"],"在绑定元素的":["46.3"],"attribute":["46.3"],"前":["46.3"],"或事件监听器应用前调用":["46.3"],"el":["46.3","47.0","63.0","79.1"],"binding":["46.3","47.0","63.0"],"vnode":["46.3"],"prevvnode":["46.3"],"下面会介绍各个参数的细节":["46.3"],"在元素被插入到":["46.3"],"前调用":["46.3"],"beforemount":["46.3","47.0","63.0"],"当在组件上使用自定义指令时":["46.4"],"中引入指令文件":["46.6"],"copy":["47.0","63.0"],"vcopy":["47.0","63.0"],"copycontent":["47.0","63.0"],"debounce":["48.0","64.0"],"grid":["50.1"],"grid的slots插槽内容":["50.1"],"row行信息就是data的数据":["50.1"],"rowindex行索引":["50.1"],"input是jsx语法":["50.1"],"不能用v":["50.2"],"只能用map来循环":["50.2"],"field":["50.2"],"inspectionlevel":["50.2"],"当checkbox选中时":["50.3"],"对应行的input为必填":["50.3"],"思考":["50.3"],"没有用到required":["50.3"],"判断当checkbox选中时":["50.3"],"对应行的input的inputvalue是否为空":["50.3"],"if包起来":["50.4"],"这样不用了的话就会销毁":["50.4"],"addandeditmodal":["50.4"],"组件库":["51.0"],"你认为一个组件都需要具备什么":["51.0"],"丰富的组件集合":["51.0"],"你是怎么管理的":["51.1"],"vue3的是composition":["51.3"],"vite是es6模块":["51.5"],"利用了浏览器原生支持的":["51.5"],"axios的请求可以通过创建了一个":["51.6"],"数组转树结构":["51.7"],"arraytotree":["51.7"],"pid":["51.7"],"isarray":["51.7"],"newarr":["51.7","56.0"],"foreach":["51.7","75.10"],"item":["51.7"],"看实际情况":["52.1"],"其实就是一个作用域的问题":["52.2"],"拦截":["52.3"],"watch适用于需要在属性变化时执行异步或开销较大的操作的场景":["52.7"],"系统学过吗":["52.10"],"js基本":["53.1"],"栈":["53.2"],"堆":["53.2"],"设为0怎样":["53.3"],"三次握手":["53.6"],"抓过包没":["53.7"],"状态可以改变吗":["53.8"],"xss攻击是恶意注入脚本":["53.9"],"文本编辑器":["53.10"],"实例链式调用":["53.12"],"如let":["53.12"],"遍历dom树打印每个元素的tagname":["53.13"],"traversedomtree":["53.13"],"打印数组全排列":["53.14","59.9"],"打印":["53.14","59.9"],"解决方案":["53.15","53.31"],"svg的区别":["53.16"],"todataurl转base64":["53.17"],"对应的使用场景":["53.18"],"强缓存":["53.19"],"强缓存是通过设置http响应头来实现的":["53.19"],"让浏览器在一定时间内直接使用本地缓存而不发送请求到服务器":["53.19"],"虚拟内存通过":["53.20"],"localstorage":["53.22"],"线程":["53.23"],"chrome内核分别有哪些进程":["53.23"],"怎么实现settimeout的准时执行":["53.25"],"keep":["53.26"],"alive的作用和实现原理":["53.26"],"keepalive缓存组件":["53.26"],"后端返回的64位大数":["53.27"],"画0":["53.28"],"发布订阅模式实现event":["53.29"],"数组拍平":["53.30"],"flat":["53.30","75.11"],"协商缓存字段":["53.35"],"短连接":["53.36"],"同一个程序在不同客户端上运行结果不同":["53.37"],"连续子数组的最大和":["53.38","59.10"],"组件库还需再加":["54.0"],"https":["55.0"],"chinese":["55.1"],"npm":["55.3","55.4","81.0"],"使用set数据结构":["56.0"],"使用filter":["56.0"],"方法和indexof":["56.0"],"用途不同":["56.2"],"watch用于监听数据的变化并执行相应的操作":["56.2"],"watch可以在以下几个方面使用":["56.3"],"数据监听":["56.3"],"watch最常见的用途是监听数据的变化":["56.3"],"当数据发生变化时":["56.3"],"vue2在created中vue3在onmounted中":["56.5"],"flex布局":["56.6"],"默认值":["56.10"],"元素按照其在文档流中的顺序进行布局":["56.10"],"不进行任何特殊的定位":["56.10"],"此时":["56.10"],"top":["56.10"],"避免阻塞":["56.12"],"代码在执行这些操作期间将无法进行其他任务":["56.12"],"承诺":["56.13"],"是按照代码顺序依次执行的任务":["56.14"],"有事件触发就清空定时器":["59.1"],"开始下一个定时":["59.1"],"在一定时间内执行一次":["59.2"],"deepcopy":["59.4","59.5"],"gettype":["59.6"],"lengthoflis":["59.7"],"nums":["59.7"],"dp":["59.7"],"mybind":["59.8"],"动态规划":["59.10"],"maxsubarray":["59.10"],"mypromise":["60.0"],"reason":["60.0"],"rescallbacks":["60.0"],"rejcallbacks":["60.0"],"executor是一个函数参数":["60.0"],"用于执行一个异步操作":["60.0"],"并在操作完成时调用resolve或reject方法":["60.0"],"constructor方法被调用时":["60.0"],"会传入一个executor函数作为参数":["60.0"],"该函数立即执行并传入两个回调函数resolve和reject":["60.0"],"这些回调函数被绑定到this上":["60.0"],"以便在异步操作完成后调用它们":["60.0"],"executor":["60.0"],"promises":["61.0"],"race":["61.1"],"promiserace":["61.1"],"targetmap":["62.0"],"weakmap":["62.0"],"createperson2":["65.4"],"待定":["65.6"],"不多说闭着眼也写得出来":["66.1"],"bubblesort":["66.1"],"从":["66.2"],"i":["66.2"],"开始从后面挑一个比":["66.2"],"小的且是最小的数与":["66.2"],"默认第一个元素被排好序":["66.3"],"从第二个元素开始依次与之前的元素比较":["66.3"],"指到比较到如果大于当前的的元素则退出循环":["66.3"],"插入到当前的的元素的下一位":["66.3"],"取一个增量gap":["66.4"],"然后将所有距离为gap的元素分在同一组":["66.4"],"并对每一组的元素进行直接插入排序":["66.4"],"然后再取一个比第一增量小的整数作为第二增量":["66.4"],"重复上述操作":["66.4"],"当增量的大小减到1时":["66.4"],"就相当于整个序列被分到一组":["66.4"],"找到一个主元pivot的key和value":["66.5"],"一般是中间的":["66.5"],"让数组形成左边是小于key右边是大于key":["66.5"],"然后左边的和右边的递归继续排序":["66.5"],"quicksort":["66.5"],"头插法":["67.1"],"reverselist":["67.1"],"head":["67.1","67.2","67.3","67.6","72.11","72.12"],"temp":["67.1"],"listnode":["67.1"],"放入数组":["67.2"],"双指针一前一后判断判断":["67.2"],"ispalindrome":["67.2"],"在head指针前造一个节点":["67.3"],"removeelements":["67.3"],"val":["67.3"],"set集合当有重复时return当前节点":["67.4"],"getintersectionnode":["67.4"],"heada":["67.4"],"headb":["67.4"],"这种找重复值的第一时间要想到set":["67.5"],"链表值不同":["67.5"],"用快慢指针":["67.5"],"慢指针和快指针相同时则是回形链表":["67.5"],"指针":["67.6"],"deleteduplicates":["67.6"],"递归":["67.7"],"mergetwolists":["67.7"],"list1":["67.7"],"list2":["67.7"],"hashfunc":["69.1","69.4"],"hashtable":["69.2","69.3","69.4","69.5","69.7"],"index":["69.2","69.4"],"isempty":["69.7"],"普通构造函数封装":["70.0"],"stack":["70.0"],"十进制转二进制":["70.1"],"dec2bin":["70.1"],"二叉搜索树":["71.1"],"bst":["71.1"],"向树中插入一个新的键":["71.3"],"封装binaryserachtree的构造函数":["71.4"],"还需要封装一个用于保存每一个结点的类node":["71.4"],"插入叶子结点":["71.5"],"binaryserachtree":["71.5","71.7","71.8","71.9","71.10","71.11","71.16"],"从根节点开始":["71.7"],"preordertraversal":["71.7"],"从左子树开始":["71.8"],"根节点在中间":["71.8"],"根节点在最后":["71.9"],"postordertraversal":["71.9"],"min":["71.10"],"search":["71.11"],"递归法":["71.11"],"删除节点要从查找要删的节点开始":["71.12"],"找到节点后":["71.12"],"需要考虑三种情况":["71.12"],"该节点是也结点":["71.12"],"没有子节点":["71.12","71.13"],"比较简单":["71.12"],"该节点有一个子节点":["71.12"],"也相对简单":["71.12"],"这种情况相对比较简单":["71.13"],"我们需要检测current的left以及right是否都为null":["71.13"],"都为null之后还要检测一个东西":["71.13"],"一个子节点":["71.14"],"warning":["71.14","79.1"],"caution":["71.14"],"tip":["71.14"],"danger":["71.14"],"这种情况也不是很难":["71.14"],"要删除的current结点":["71.14"],"只有2个连接":["71.14"],"两个子节点":["71.15"],"又分三种情况":["71.15"],"如果我们要删除的节点有两个子节点":["71.15"],"甚至子节点还有子节点":["71.15"],"这种情况下我们需要从下面的子节点中找到一个节点":["71.15"],"来替换当前的节点":["71.15"],"但是找到的这个节点有什么特征呢":["71.15"],"应该是current节点下面所有节点中最接近current节点的":["71.15"],"要么比current节点小一点点":["71.15"],"要么比current节点大一点点":["71.15"],"总结你最接近current":["71.15"],"你就可以用来替换current的位置":["71.15"],"比current小一点点的节点":["71.15"],"一定是current左子树的最大值":["71.15"],"删除":["71.16"],"remove":["71.16"],"current":["71.16","72.11","72.12"],"root":["71.16"],"parent":["71.16"],"isleftchild":["71.16"],"查找删除的节点current":["71.16"],"append":["72.2","72.11","72.12"],"linkedlist":["72.2","72.3","72.4","72.5","72.6","72.7","72.8","72.9","72.11","72.12"],"完整代码":["72.11"],"newnode":["72.11","72.12"],"第一个节点为空":["72.11","72.12"],"把新节点放在第一个节点":["72.11","72.12"],"最后一个节点":["72.11","72.12"],"else":["72.11","72.12"],"当current":["72.11","72.12"],"next不为空时":["72.11","72.12"],"让current指到下一个data":["72.11","72.12"],"直到current":["72.11","72.12"],"next为空":["72.11"],"最后把新节点赋值给current":["72.11"],"全部代码":["72.12"],"queue":["73.1","73.2","74.1","74.2"],"dequeue":["73.1","73.2"],"front":["73.1","73.2"],"enqueue":["73.2"],"myqueue":["74.2"],"numlist":["74.2"],"every":["75.1"],"判断是否符合条件":["75.1","75.2"],"有一个不符合就不行":["75.1"],"some":["75.2"],"有一个符合就行":["75.2"],"find":["75.3"],"找到符合条件的第一个数":["75.3"],"findlast":["75.4"],"findindex":["75.5"],"找到":["75.5"],"indexof":["75.6"],"lastindexof":["75.7"],"方法对数组的每个元素执行一次给定的函数":["75.10"],"flatmap":["75.12"],"方法对数组中的每个元素应用给定的回调函数":["75.12"],"然后将结果展开一级":["75.12"],"返回一个新数组":["75.12"],"fill":["75.13","82.1"],"用一个固定值填充一个数组中从起始索引":["75.13"],"默认为":["75.13"],"静态方法从可迭代或类数组对象创建一个新的浅拷贝的数组实例":["75.15"],"方法通过可变数量的参数创建一个新的":["75.16"],"实例":["75.16"],"而不考虑参数的数量或类型":["75.16"],"join":["75.17"],"方法用于将数组中的元素连接成字符串":["75.17"],"pop":["75.18"],"方法用于删除数组中的最后一个元素":["75.18"],"方法用于添加一个或多个元素到数组的末尾":["75.19"],"方法从数组中删除第一个元素":["75.20"],"并返回该元素的值":["75.20"],"unshift":["75.21"],"方法将一个或多个元素添加到数组的开头":["75.21"],"方法返回一个包含数组中每个索引键的":["75.22"],"方法返回一个新的":["75.23"],"返回一个新的数组迭代器对象":["75.24"],"reduceright":["75.26"],"方法接受一个函数作为累加器":["75.26"],"reverse":["75.27"],"方法将数组中元素的位置颠倒":["75.27"],"slice":["75.28"],"方法返回一个新的数组对象":["75.28"],"sort":["75.29"],"方法用原地算法对数组的元素进行排序":["75.29"],"并返回数组":["75.29"],"splice":["75.30","85.7"],"tolocalestring":["75.31"],"返回一个字符串表示数组中的元素":["75.31"],"方法返回一个字符串":["75.32"],"flatten2":["76.5"],"eachflatten":["76.6"],"deep":["76.6"],"reduceflat":["76.7"],"arr2":["77.4"],"flowing":["78.1"],"createapp":["78.2","79.2","82.2"],"disabled":["78.4","79.7","80.2"],"给按钮添加禁用功能":["78.4"],"按钮":["79.0"],"普通按钮":["79.1"],"row":["79.1","85.2"],"mb":["79.1"],"button":["79.1"],"primary":["79.1"],"info":["79.1"],"可以选择想要的类型":["79.4"],"给按钮添加":["79.5","79.6","79.7","79.8"],"plain":["79.5"],"round":["79.6"],"icon":["79.8"],"选择自己喜欢的":["79.8"],"linput":["80.1","80.3","80.4","80.5","80.6","80.7"],"medium":["80.3","80.5","80.6"],"small":["80.3"],"mini":["80.3"],"不传则默认":["80.3"],"当输入框有值时可一键清空":["80.4"],"upfile":["80.7","84.2"],"设置":["80.8"],"autosize":["80.8"],"minrows":["80.8"],"licon":["82.1","82.7","82.8","82.9","82.10","82.11","82.12","82.13","82.14","82.15","82.16"],"apple":["82.1"],"line":["82.1"],"apps":["82.1","82.9"],"我们可以设置dot属性后":["82.4"],"我们可以设置color属性更改你想要的颜色":["82.5"],"dianzan":["82.10"],"xiala2":["82.12"],"bianji":["82.15"],"shezhi":["82.16"],"underline属性添加下划线":["83.1"],"disabled属性禁用":["83.2"],"multiple可以上传多个文件":["84.1"],"accept设置只允许上传文件类型":["84.1"],"lupload":["84.1"],"multiple":["84.1"],"添加drag属性":["84.2"],"宏任务的定时器谁先到时间谁先执行":["85.1"],"table标签":["85.2"],"类似于":["85.2"],"别再错了指向的是obj的上下文":["85.4"],"指不到里面的":["85.4"],"输入类型":["85.5"],"promise的catch只会执行第一个":["85.9"],"和then不同不会传递到最后":["85.9"],"情况一转为字符串后相当于重复赋值":["85.11"],"object对象转换为字符串和判断数据类型都是直接调用":["85.12"],"let块级作用域输出0":["85.13"],"若过渡起始值或过渡开始值为auto":["85.14"],"top属性规定内部元素的顶部边缘":["85.16"],"flex方法时":["85.18"],"箭头函数后面有":["86.1"],"就需要return来返回里面的数据":["86.1"],"不写return会undefined":["86.1"],"箭头函数后面没有":["86.1"],"不需要return":["86.1"],"构造函数里的箭头函数方法挂载在对象自身里":["86.2"],"普通函数放在原型上":["86.2"],"你可上点心吧":["87.0"],"快乐数":["88.1"],"ishappy":["88.1"],"通过vitepress和github":["90.0"],"从这里开始你的":["91.0"]},{"0":["0.6","1.7","9.9","16.16","16.23","17.17","20.22","20.26","53.14","59.7","59.9","59.10","66.1","67.3","69.7","72.4","72.8","73.2","74.2","85.13","88.1"],"1":["0.4","1.19","1.30","2.1","3.6","3.9","6.9","6.10","8.1","9.9","9.34","11.7","11.8","11.9","14.4","14.10","16.14","16.38","16.40","16.47","17.19","19.4","19.27","19.50","19.73","22.5","22.6","28.16","36.16","38.0","38.5","41.9","43.2","44.8","44.37","44.41","45.9","45.17","45.18","51.1","51.2","53.11","59.7","60.0","70.0","75.12","76.4","76.6","76.7","86.1"],"2":["0.8","3.5","5.7","6.14","6.19","9.17","9.25","10.2","14.3","16.2","16.47","16.49","19.4","19.13","19.15","19.43","19.69","19.73","19.76","21.0","21.2","21.5","22.6","22.11","23.3","24.3","26.1","28.2","30.4","30.8","32.3","32.4","34.4","34.22","35.2","35.4","41.1","41.2","41.3","43.6","43.11","44.1","44.10","44.24","44.33","44.34","44.44","44.60","45.9","45.11","45.14","45.26","45.27","52.5","53.34","55.1","56.2","56.3","56.10","56.14","71.15","76.4","77.4","82.8","85.2","85.17","86.1"],"3":["2.10","4.0","5.17","6.13","11.19","16.10","16.12","16.28","16.44","16.49","17.18","19.73","22.6","24.3","30.4","41.3","42.32","45.14","52.6","76.4","77.4"],"4":["2.10","4.0","8.2","16.19","16.20","16.46","25.1","42.10","42.32","43.8"],"5":["16.16","16.28","16.29","16.31","22.1","38.7","43.8","80.8"],"6":["9.23","16.34","16.46","17.18","76.4"],"7":["9.23"],"8":["34.4"],"10":["5.13","18.4"],"14":["16.16"],"16":["34.4","75.29"],"18":["41.5"],"20":["11.14"],"22":["21.3"],"33":["11.24"],"42":["20.26"],"51":["16.39"],"100":["16.5"],"123":["19.34","34.28"],"127":["0.6"],"150":["50.2"],"200":["0.2"],"205":["9.23"],"206":["9.23"],"300":["9.23"],"301":["9.23"],"1000":["16.22","21.8"],"2000":["21.8"],"3000":["21.8"],"8888":["0.6"],"a":["0.1","6.5","19.73","20.18","20.26","42.4","42.7","42.32","45.9","53.12"],"send":["0.2"],"设置响应体类型":["0.2"],"responsetype":["0.2"],"json":["0.2","59.5"],"因为是异步请求":["0.2"],"所以要在加载完成后读数据":["0.2"],"onload":["0.2"],"if":["0.2","9.19","42.3","45.4","45.21","47.0","53.14","59.8","59.9","60.0","62.0","63.0","69.2","69.4","71.5","72.4","72.5","72.7","72.8","76.7"],"status":["0.2","13.3"],"json转文本":["0.2"],"goodslist":["0.2"],"js":["0.3","5.14","19.22","19.26","19.45","19.62","19.72","20.3","20.4","20.7","20.10","20.13","20.14","20.16","20.18","20.20","20.25","21.10","22.2","22.4","22.9","27.0","29.4","29.5","29.10","31.3","32.1","32.4","32.6","42.8","44.26","44.32","44.35","45.7","45.28","50.3","53.30","65.2","66.2","66.4","71.12","71.15","75.1","75.2","75.3","75.7","75.10","75.11","75.15","75.18","75.19","75.21","75.22","75.23","75.24","75.26","75.29","75.30","75.32","76.1","77.0","79.4","79.5","79.6","79.7","82.5","85.4","85.9","85.13","86.1","86.2"],"字符串转对象":["0.3"],"不常用copy":["0.4"],"head":["0.4","0.6","1.10","5.19","67.5","72.9"],"link等等":["0.4"],"原因":["0.5"],"http":["0.5","0.6"],"src":["0.6","44.35"],"index":["0.6","56.0","56.10","69.3"],"php":["0.6"],"callback":["0.6","60.0"],"jsonpcallback":["0.6"],"插入到页面":["0.6"],"appendchild":["0.6"],"在以上代码中":["0.6"],"我们定义了一个名为":["0.6"],"的函数作为回调函数":["0.6"],"在请求的url中添加":["0.6"],"参数":["0.6"],"使得服务端返回的数据可以作为该函数的参数传递到客户端":["0.6"],"并在控制台中输出数据":["0.6"],"function":["0.6","19.22","19.51","19.52","20.4","20.13","20.14","21.10","22.9","22.10","34.21","38.8","42.4","42.8","42.29","45.21","52.3","53.30","65.6","66.2","66.3","66.4","67.5","69.5","71.7","71.8","71.10","71.12","72.2","72.3","72.5","72.6","72.7","72.10","76.2","76.6","85.1"],"canceltoken":["0.7","51.6"],"可以提供更好的用户体验":["0.8"],"token刷新":["0.8"],"如果你的应用使用了token进行身份验证":["0.8"],"你可以在响应拦截器中":["0.8"],"检查响应的状态码":["0.8"],"并根据特定的状态码来刷新token":["0.8"],"这样可以确保token始终处于有效状态":["0.8"],"并且在过期时自动刷新":["0.8"],"请求拦截":["0.8"],"添加":["0.8","2.6"],"请求头":["0.8","0.9","9.38"],"你可以在请求拦截器中设置请求头":["0.8"],"例如添加身份验证的":["0.8"],"token添加到请求头":["0.8"],"设置请求的内容类型等":["0.8"],"这样可以确保每个请求都携带所需的头部信息":["0.8"],"请求参数处理":["0.8"],"你可以在请求拦截器中对":["0.8"],"请求的参数进行处理":["0.8"],"例如添加通用的参数":["0.8"],"生产环境的不同":["0.9"],"前缀需要加以区分":["0.9"],"调用":["0.10","41.6","45.18"],"cancel":["0.10"],"主动取消请求":["0.10"],"flex":["1.1"],"justify":["1.1"],"content":["1.1","1.26","2.3","5.2"],"center":["1.1","1.25","1.26","50.2"],"align":["1.1","50.2"],"items":["1.1","22.4"],"style":["1.2","8.2","34.28","44.64"],"clear":["1.2","22.3"],"both":["1.2"],"bfc":["1.3"],"块级格式化上下文":["1.3"],"属于普通流":["1.3"],"隐藏元素的属性有哪些":["1.4"],"触发回流重绘":["1.5"],"性能消耗较大":["1.5"],"非继承属性":["1.5"],"子孙节点消失由于元素从渲染树消失造成":["1.5"],"通过修改子孙节点属性无法显示":["1.5"],"visibility":["1.5"],"left":["1.6","16.42","56.10","71.16"],"top":["1.6","1.19"],"利用绝对定位":["1.6"],"scale":["1.7"],"skew":["1.7"],"和":["1.8","1.9","1.21","4.0","34.6","34.22","37.3","38.4","42.11","56.10","75.16","75.28"],"em":["1.8"],"是":["1.9","5.26","9.20","34.25","38.5"],"实现不同屏幕尺寸下的自适应布局":["1.10"],"在html的":["1.10"],"标签中设置基准字体大小":["1.10"],"flexible":["1.11"],"box":["1.11","2.8"],"的缩写":["1.11"],"意为":["1.11"],"弹性布局":["1.11"],"指定容器display":["1.11"],"felx是哪些属性的缩写":["1.12"],"对应的属性代表什么含义":["1.12"],"布局是一维布局":["1.17"],"grid":["1.17"],"布局是二维布局":["1.17"],"css":["1.18","1.22","1.35","2.7","5.18"],"或":["1.18","11.26","34.9","44.51"],"属于合成属性":["1.19"],"composite":["1.19"],"中的":["1.20"],"值是":["1.20"],"css3":["1.20","2.1"],"新增的":["1.20"],"between":["1.21"],"过渡动画":["1.22"],"property":["1.22","45.17"],"指定过渡的":["1.22"],"属性":["1.22","19.4","20.3"],"属性使用裁剪方式创建元素的可显示区域":["1.23"],"其宽度默认为父元素的100":["1.24"],"块级元素可以设置宽度":["1.24"],"高度":["1.24"],"居中":["1.25"],"p":["1.25","42.32","45.17"],"date":["1.25","19.4"],"space":["1.26"],"name":["1.27","5.20","13.3","19.28","21.3","37.10","41.5","42.20","42.23","65.3","65.4","65.5","82.11"],"duration":["1.27"],"即html元素":["1.28"],"id选择器的权重为100":["1.29","56.16"],"type":["1.30","5.2","8.2","41.5","42.26","42.32","59.6","79.4"],"checkbox":["1.30"],"checked":["1.30"],"background":["1.30"],"color":["1.30","82.7"],"yellow":["1.30"],"常见伪类选择器":["1.30"],"链接伪类选择器":["1.30"],"而无需修改html结构":["1.31"],"这些内容可以用于添加装饰":["1.31"],"family":["1.32"],"规定元素的字体系列":["1.32"],"weight":["1.32"],"设置字体的粗细":["1.32"],"size":["1.32","16.9","22.2","69.1","69.7","73.1","73.2","80.3","80.4"],"百分比":["1.33"],"内联首屏关键css":["1.34"],"内联css使浏览器在下载完html后就能立刻渲染":["1.34"],"解析":["1.35","9.25"],"如何用":["2.0"],"利用":["2.1","5.16"],"添加空div法":["2.2"],"在浮动元素下方添加空div":["2.2"],"并给该元素写css样式":["2.2"],"填充":["2.3"],"padding":["2.3"],"边框":["2.3"],"border":["2.3","2.8","85.2"],"w3c盒模型":["2.4"],"标准盒模型":["2.4"],"sizing属性来指定盒模型的类型":["2.5"],"重绘":["2.6","6.11"],"删除":["2.6"],"尽量不用图片":["2.7"],"因为这类修饰图片完全可以用":["2.7"],"去代替":["2.7"],"盒子模型属性":["2.8"],"radius":["2.8"],"shadow":["2.8"],"分辨率":["2.9"],"方向等条件来为不同的设备或浏览器设置不同的css样式":["2.9"],"通过媒体查询":["2.9"],"圣杯布局":["2.10"],"核心思想":["2.10"],"利用浮动":["2.10"],"外边距负值和相对定位来实现":["2.10"],"父级元素设置左右的padding":["2.10"],"三列均设置向左浮动":["2.10"],"中间一列放在最前面":["2.10"],"宽度设置为父级元素的宽度":["2.10"],"因此后面两列都被挤到了下一行":["2.10"],"再通过设置margin负值将其移动到上一行":["2.10"],"什么是es6模块化":["3.1"],"每个":["3.2","43.7"],"默认导出与默认导入":["3.3"],"每个模块中":["3.4"],"每个模块中可以使用多次按需导出":["3.5"],"var允许重复声明":["3.6"],"let":["3.6","4.0","22.5","22.6","42.7","42.21","45.15","45.28","45.29","53.14","59.1","59.4","59.6","59.7","59.9","59.10","61.0","65.1","65.2","65.4","66.3","66.4","66.5","67.3","67.4","67.5","69.1","69.3","71.5","71.10","71.12","72.6","72.9","74.2","75.1","75.2","75.3","75.10","75.15","75.17","75.19","75.21","75.22","75.24","75.32","76.0","76.5","77.0","88.1"],"const不允许":["3.6"],"函数作用域":["3.7"],"块状作用域":["3.7"],"动态作用域":["3.7"],"对象":["3.7","3.15","5.25","23.2","38.5","75.22","75.23"],"新增的解构赋值":["3.8"],"解构赋值针对数组或者对象进行模式匹配":["3.8"],"箭头函数和普通函数的区别":["3.9"],"js新增简单数据类型symbol":["3.10"],"新增了class关键字":["3.11"],"与node":["3.12"],"js的commonjs不同":["3.12"],"es6新增esmoudule":["3.12"],"新增promise":["3.13"],"es6":["3.14","29.3","33.0"],"中引入的一种特殊函数":["3.14"],"它可以被暂停和恢复":["3.14"],"场景":["3.14"],"数组新增方法":["3.15"],"find":["3.15"],"findindex":["3.15"],"includes":["3.15","75.8"],"fill":["3.15","59.7","82.9"],"keys":["3.15","22.3","42.32","45.4"],"values":["3.15","14.4"],"entires":["3.15"],"copywithin":["3.15"],"里面的参数a又是怎么回事呢":["4.0"],"字符串a表示一种修饰":["4.0"],"对你当前创建的symbol类型的一种修饰":["4.0"],"作为区分使用":["4.0"],"与其他数据类型之间的转换":["4.0"],"symbol不能用四则运算进行操作":["4.0"],"否则报错":["4.0"],"它只能用显示的方式转为字符串和布尔值":["4.0"],"string":["4.0","11.10","11.12","11.21","16.3","16.4","16.11","16.15","16.46","16.50","19.34","42.6","42.8","42.17","42.19","42.20","42.23","53.1"],"boolean":["4.0","16.17","16.42","20.14"],"作为对象的属性":["4.0"],"msmymbol":["4.0"],"第一种写法":["4.0"],"html":["5.1","5.19"],"文件字节流是无法直接被渲染引擎理解的":["5.1"],"所以要将其转化":["5.1"],"会根据请求头中的":["5.2"],"type字段来判断文件的类型":["5.2"],"比如":["5.2","11.5"],"的值是":["5.2"],"text":["5.2","46.0","85.15"],"那么浏览器就会判断这是一个":["5.2"],"类型的文件":["5.2"],"然后为该请求选择或者创建一个渲染进程":["5.2"],"渲染进程准备好之后":["5.2"],"网络进程和渲染进程之间会建立一个共享数据的管道":["5.2"],"网络进程接收到数据后就往这个管道里面放":["5.2"],"而渲染进程则从管道的另外一端不断地读取数据":["5.2"],"css不会阻塞dom树的解析":["5.3"],"但是会阻塞dom树的渲染":["5.3"],"标签时":["5.4"],"暂停整个":["5.4"],"dom":["5.4","5.9","5.10","34.8","34.15","34.19","36.7","36.8","44.43"],"脚本设置为异步加载":["5.5"],"文档解析完毕dom树构建完成":["5.6"],"解析html结构":["5.7"],"外部":["5.8"],"文件的下载是":["5.8"],"异步的":["5.8"],"即浏览器会继续加载后续内容而不必等待":["5.8"],"文件加载完成":["5.8"],"的代价":["5.12"],"原生":["5.12"],"如前":["5.13"],"若一次操作中有":["5.13"],"次更新":["5.13"],"的动作":["5.13"],"用":["5.14"],"树":["5.16"],"element":["5.17","37.15","53.13","74.1"],"表示一个元素节点":["5.17"],"提供了操作和访问元素的方法和属性":["5.17"],"node":["5.17","51.7","71.5","71.10","71.11","72.2","72.4"],"queryselector":["5.18"],"selector":["5.18"],"根据":["5.18"],"选择器选择匹配的第一个元素节点":["5.18"],"通常是":["5.19"],"获取指定属性名对应的属性值":["5.20"],"可以用于添加":["5.21"],"删除和切换类名":["5.21"],"id":["5.21","13.3","14.2","14.4","37.9","51.7"],"获取或设置元素的唯一标识符":["5.21"],"tagname":["5.21"],"获取元素的标签名":["5.21"],"以大写形式表示":["5.21"],"innerhtml":["5.21"],"获取或设置元素的html内容":["5.21"],"createtextnode":["5.22"],"创建一个文本节点":["5.22"],"对象是浏览器中的顶级对象":["5.23"],"显示一个带有消息":["5.24"],"确定和取消按钮的对话框":["5.24"],"并返回用户的选择结果":["5.24"],"prompt":["5.24"],"用于访问和操作文档的内容":["5.25"],"location":["5.25"],"获取或设置当前窗口的":["5.25"],"javascript":["5.26","20.1","29.1"],"keydown":["5.27"],"等":["5.27","36.7"],"target":["5.27","20.3","45.17","45.19","45.21","45.29","45.32","62.0"],"触发事件的元素":["5.27"],"stoppropagation":["5.28"],"停止事件的传播":["5.28"],"doctype":["6.1"],"有何作用":["6.1"],"的区别":["6.2"],"b":["6.2","19.29","19.73","42.1","42.4","42.32","45.9"],"strong":["6.2"],"form":["6.3"],"ul":["6.3"],"li":["6.3"],"ol":["6.3"],"table":["6.3","16.41"],"h1":["6.3"],"h2":["6.3"],"它为鼠标用户改进了可用性":["6.4"],"当我们在label元素内点击文本时就会触发此控件":["6.4"],"也就是说":["6.4","23.1","29.3"],"当用户选择该标签时":["6.4"],"浏览器就会自动将焦点转到和标签相关的表单控件上":["6.4"],"href属性中的url可以是浏览器支持的任何协议":["6.5"],"所以a标签可以用来手机拨号":["6.5"],"你知道seo中的tdk吗":["6.6"],"主要有两种方式":["6.7"],"实现标签被识别":["6.7"],"通过document":["6.7"],"存储":["6.8","30.0"],"多任务等功能的增加":["6.8"],"语义化标签":["6.8"],"如":["6.8","9.19"],"article":["6.8"],"加载js然后html和css":["6.9"],"设置defer和acync时js和html异步加载":["6.9"],"从根元素开始检查哪些元素可见":["6.10"],"以及样式":["6.10"],"回流":["6.11"],"不可避免":["6.12"],"documentfragment":["6.13"],"提升为合成层":["6.13"],"合成层的位图":["6.13"],"会交由":["6.13"],"合成就是将页面的各个部分分成多个层":["6.14"],"最后把它们合成为一个页面的技术":["6.14"],"合成层拥有单独的图层":["6.14"],"filter":["6.15","56.0"],"will":["6.15"],"change等":["6.15"],"浏览器会自动将这些元素创建为单独的合成层":["6.15"],"设置":["6.15"],"可能简单的重叠就会产生大量的合成层":["6.16"],"这样会占用很多无辜的":["6.16"],"cpu":["6.16"],"虽然有浏览器的层压缩机制":["6.17"],"但是也有很多无法进行压缩的情况":["6.17"],"语义元素可以清楚地向浏览器和开发者描述其意义":["6.18"],"即元素本身传达了关于标签所包含内容类型的一些信息":["6.18"],"例如":["6.18","10.1","17.10","20.22","20.30","43.13","79.5","79.6","79.7","82.5"],"也能够":["6.19"],"呈现出很好的内容结构":["6.19"],"可以在页面中嵌入另一个html文档或者网页":["6.20"],"iframe元素可以用来在当前页面中显示来自其他网站或者服务器的内容":["6.20"],"也可以用来实现一些特殊的功能":["6.20"],"如打印预览":["6.20"],"search":["7.1","37.10","71.1","71.3"],"engine":["7.1"],"标题":["7.2"],"如果主体比较多":["7.3"],"简单理解就是关键词在所有文字内容中出现的比例":["7.4"],"给用户看的":["7.5"],"这个属性表明了这张图的内容":["7.5"],"其实搜索引擎在分析页面的时候":["7.5"],"也会根据这个词去判断图片的内容":["7.5"],"所以要给页面上有意义的图片都加上alt属性":["7.5"],"表现和行为":["8.1"],"javascript定义":["8.2"],"script":["8.2"],"css定义":["8.2"],"搜索引擎优化":["8.3"],"很有帮助":["8.3"],"http是一个客户端终端":["9.1"],"用户":["9.1"],"和服务器端":["9.1"],"网站":["9.1"],"请求和应答的标准":["9.1"],"客户向服务器请求服务时":["9.2"],"只需要传送请求方法和路径":["9.2"],"由于http协议简单":["9.2"],"使得通信速度比较快":["9.2"],"transmission":["9.3"],"control":["9.3","28.12","53.19"],"protocol":["9.3","9.35","9.37"],"在客户端请求建立连接时":["9.4"],"如果":["9.4","38.4","79.8"],"服务器没有及时响应":["9.4"],"sockets":["9.5"],"layer":["9.5"],"协议对http协议传输的数据进行加密":["9.5"],"ssl":["9.5"],"依靠证书来验证服务器的身份":["9.5"],"并为浏览器和服务器之间的通信加密":["9.5"],"用于在计算机网络上保证通信安全":["9.6"],"它通过使用对称加密和非对称加密的组合来实现数据的机密性":["9.6"],"完整性和身份验证":["9.6"],"ssl的工作原理":["9.6"],"客户端请求":["9.6"],"使用":["9.7","9.16"],"使用一对密钥":["9.8"],"的出现":["9.9"],"相比于":["9.9"],"从而提高性能并减少延迟":["9.10"],"它采用了动态表和静态表的方式来减少头部信息的大小":["9.11"],"动态表和静态表":["9.11"],"在":["9.11","34.4","45.5"],"客户端和服务器之间维护了一个动态表和一个静态表":["9.11"],"当前请求和之前的请求历史预测":["9.12"],"一个":["9.13","53.21"],"节点":["9.13","53.21"],"术语叫边缘节点":["9.13","53.21"],"主机名":["9.14"],"显示":["9.16"],"请求":["9.16","9.23"],"方法应该只用在读取数据上":["9.16"],"而不应该用于产生":["9.16"],"副作用":["9.16"],"的操作中":["9.16"],"post":["9.17","9.20"],"一般用于提交数据":["9.17"],"参数不可见":["9.17"],"传递参数数量无限制":["9.17"],"注意":["9.17","11.17","38.0"],"更新服务器上的文件或数据库":["9.18"],"get能请求缓存":["9.18"],"agent":["9.19","9.23"],"用户标识":["9.19"],"os":["9.19"],"和浏览器的类型和版本":["9.19"],"modified":["9.19"],"since":["9.19"],"值为上一次服务器返回的last":["9.19"],"modified值":["9.19"],"用于确定某个资源是否被更改过":["9.19"],"没有更改过就从缓存中读取":["9.19"],"none":["9.19"],"响应状态行":["9.21"],"1xx":["9.22"],"提示信息":["9.22"],"表示请求已接收":["9.22"],"但没有返回任何内容":["9.23"],"重置内容":["9.23"],"部分内容":["9.23"],"服务器成功处理了部分":["9.23"],"get":["9.23","44.16","45.17","45.19","45.32","62.0"],"3xx":["9.23"],"重定向":["9.23"],"多种选择":["9.23"],"针对请求":["9.23"],"服务器可执行多种操作":["9.23"],"服务器可根据请求者":["9.23"],"user":["9.23","14.2"],"选择一项操作":["9.23"],"或提供操作列表供请求者选择":["9.23"],"永久移动":["9.23"],"dns":["9.25"],"地址解析":["9.26"],"首先判断你输入的是一个合法的":["9.26"],"浏览器缓存":["9.27"],"浏览器会先检查是否在缓存中":["9.27"],"没有则调用系统库函数进行查询":["9.27"],"负责传输数据的物理媒介":["9.28"],"如电缆":["9.28"],"光纤等":["9.28"],"数据链路层":["9.28"],"data":["9.28","44.19","72.2","72.6","72.7"],"link":["9.28"],"将数据返回至浏览器":["9.29"],"如果响应可以缓存":["9.30"],"而断开连接是四次挥手":["9.32"],"其实就是指建立一个tcp连接时":["9.33"],"需要客户端和服务器总共发送3个包":["9.33"],"进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常":["9.33"],"指定自己的初始化序列号为后面的可靠性传送做准备":["9.33"],"刚开始客户端处于":["9.33"],"客户端或服务器均可主动发起挥手动作":["9.34"],"第一次挥手":["9.34"],"客户端发送一个":["9.34"],"fin":["9.34"],"报文":["9.34"],"internet":["9.35"],"可靠性":["9.36"],"连接性等方面存在一些区别":["9.36"],"连接性":["9.36"],"是面向":["9.36"],"连接":["9.36"],"的协议":["9.36"],"通过三次握手建立可靠的连接":["9.36"],"确保数据的可靠传输":["9.36"],"是无连接的协议":["9.36"],"transfer":["9.37"],"是一种无状态的协议":["9.37"],"设置并发送给客户端":["9.38"],"浏览器会在后续的请求中将":["9.38"],"自动包含在":["9.38"],"中发送给服务器":["9.38"],"主要用于在客户端存储有":["9.38"],"关用户的一些状态信息或标识符":["9.38"],"以便服务器在后续请求中进行识别和处理":["9.38"],"可以设置过期时间":["9.38"],"进程":["9.39"],"攻击通常发生在搜索引擎等":["10.1"],"web":["10.1"],"应用程序中":["10.1"],"攻击者会利用":["10.1"],"搜索表单等功能":["10.1"],"向服务器提交恶意代码":["10.1"],"服务器将恶意代码作为响应返回给用户的浏览器":["10.1"],"浏览器解释执行该代码":["10.1"],"导致攻击成功":["10.1"],"攻击者可以构造包含恶意代码的链接":["10.1"],"引诱用户点击该链接":["10.1"],"web应用程序必须对用户进行身份认证和授权":["10.2"],"以确保只有授权的用户才能访问敏感信息和功能":["10.2"],"输入验证和过滤":["10.2"],"web应用程序必须对用户输入进行验证和过滤":["10.2"],"以确保输入数据符合预期格式和范围":["10.2"],"并且不包含恶意代码或攻击负载":["10.2"],"输入验证和过滤可以有效地防止sql注入":["10.2"],"request":["10.3"],"forgery":["10.3"],"和xss":["10.3"],"csrf令牌":["10.5"],"在每个用户请求中包含一个随机生成的csrf令牌":["10.5"],"并在服务器端进行验证":["10.5"],"进行输入验证和过滤":["10.6"],"确保只接受符合预期格式的数据":["10.6"],"输出转义":["10.6"],"在将用户输入的数据输出到网页时":["10.6"],"注入攻击":["10.7"],"java":["11.1","11.12","11.17","11.18","11.22","11.25","16.1","16.18","16.21","16.25","16.27","16.28","16.30","16.32","16.45","16.46","16.50","17.13","18.1"],"virtual":["11.1"],"machine":["11.1"],"就是我们耳熟能详的":["11.1"],"减少耦合":["11.2"],"继承是从已有的类中派生出新的类":["11.2"],"新的类继承父类的属性和行为":["11.2"],"char":["11.3"],"short":["11.3"],"int":["11.3","11.14","14.2","16.9","16.16","16.23","16.39","16.41","16.42","16.45","17.12","17.13"],"long":["11.3","16.36"],"并不是准确值":["11.4"],"是一种面向对象语言":["11.5"],"很多地方都需要使用对象而不是基本数据类型":["11.5"],"进行加减乘除混合运算":["11.6"],"进行":["11.6"],"比较运算":["11.6"],"调用equals进行比较":["11.6"],"arraylist":["11.6","16.50"],"hashmap等集合类添加基础类型数据时":["11.6"],"因此value不可以指向其他对象":["11.7"],"string类内部所有的字段都是私有的":["11.7"],"也就是被private修饰":["11.7"],"而且string没有对外提供修改内部状态的方法":["11.7"],"因此value数组不能改变":["11.7"],"线程安全":["11.7","17.9"],"可变性":["11.8"],"会创建几个对象":["11.9"],"使用这种方式会创建两个字符串对象":["11.9"],"pool":["11.10","16.9","16.11","16.16"],"equals":["11.11"],"是否也一定为":["11.11"],"随着类的加载而加载":["11.12"],"优先于对象存在":["11.12"],"用类名调用时不需要先创建类":["11.12"],"public":["11.12","11.18","11.25","16.1","16.3","16.11","16.21","16.25","16.27","16.28","16.30","16.32","16.45","16.46","16.50","17.13"],"class":["11.12","11.18","11.21","16.1","16.3","16.11","16.21","16.25","16.30","16.43","16.46","16.50","17.12","17.13","86.2"],"student":["11.12"],"被jvm调用":["11.13"],"extends":["11.14","17.12","34.4","42.28"],"person":["11.14","20.4","42.20","65.5"],"age":["11.14","21.3","28.12","41.5","42.19","42.20","42.23","65.3","65.4","65.5"],"double":["11.14"],"salary":["11.14"],"void":["11.14","11.21","11.24","16.3","16.15","16.21","16.22","16.23","16.43","16.47","16.50"],"methods":["11.14"],"private":["11.15","16.17","16.23","16.33","16.46"],"default":["11.15","12.1","16.9"],"父类重要的方法final修饰":["11.16"],"不能被子类继承":["11.16"],"就可以设计为抽象方法":["11.17"],"抽象类的子类要强制重写父类的抽象方法":["11.17"],"或者子类也是抽象类":["11.17"],"意义不大":["11.17"],"抽象类不能实例化":["11.17"],"找类来实现接口":["11.18"],"interfacetest1":["11.18"],"static":["11.18","11.21","16.3","16.9","16.11","16.15","16.21","16.36","16.50","17.12"],"类和接口之间":["11.19"],"单实现":["11.19"],"多实现":["11.19"],"可以在继承的同时实现多个接口":["11.19"],"接口和接口之间":["11.19"],"可以单继承":["11.19"],"成员方法":["11.20"],"构造方法":["11.20"],"polymorphismtest1":["11.21"],"main":["11.21","16.3","16.4","16.11","16.15","16.21","16.50"],"args":["11.21","16.3","16.4","16.11","16.15","16.50"],"dog":["11.21"],"new":["11.21","16.1","16.9","16.13","16.46","16.50","17.17","21.6","21.7","21.9","22.4","22.5","22.6","23.3","27.0","45.9","45.17","45.19","45.21","45.28","53.12","61.0","61.1","67.3","67.4","70.1","71.5","72.2","72.4","74.2"],"子类引用指向子类对象":["11.21"],"animal":["11.21"],"fu":["11.22"],"比类的方法优先制性":["11.23"],"静态代码块":["11.23"],"在构造代码块前加static":["11.23"],"类只加载一次":["11.23"],"在最开始执行且只执行一次":["11.23"],"可以对数据初始化":["11.23"],"method":["11.24"],"system":["11.24","16.3","16.4","16.5","16.11","16.16","16.22","16.39"],"out":["11.24","16.3","16.4","16.11","16.16","16.22","16.39"],"println":["11.24","16.3","16.4","16.11","16.16","16.39"],"inner":["11.24","14.12"],"复选集定义":["11.26"],"匹配字母":["11.26"],"vz":["11.26"],"后面跟着":["11.26"],"v":["11.26","44.57","50.1","50.4","80.4","80.5"],"z":["11.26","56.10"],"当插入符":["11.26"],"在中括号中以第一个字符开始显示":["11.26"],"一出上一次构建生成的文件":["12.1"],"负责管理分配数据库连接":["13.1"],"xml文件的名称与接口名称一致":["13.2"],"namespace":["13.3"],"com":["13.3","16.16"],"usermapper":["13.3"],"sql":["13.3","14.11"],"commonselect":["13.3"],"select":["13.3"],"category":["13.3"],"price":["13.3"],"image":["13.3","84.1","84.2"],"description":["13.3"],"create":["13.3","14.0","31.2"],"time":["13.3"],"update":["13.3","28.2"],"from":["13.3","14.5","14.14","34.21","38.8","41.8","43.7","79.3"],"dish":["13.3"],"更新":["13.3","36.16"],"update2":["13.3"],"由多张相互连接的二维表组成的数据库":["14.0"],"创建":["14.0","44.22"],"数据定义语言":["14.1"],"comment":["14.2"],"唯一表示":["14.2"],"smallint":["14.3"],"mediumint":["14.3"],"sst":["14.4"],"吕江涛":["14.4"],"now":["14.4"],"表名列表":["14.5"],"as":["14.6"],"姓名":["14.6"],"入职日期":["14.6"],"姓":["14.6"],"名":["14.6"],"distinct":["14.6"],"筛选掉重复的":["14.6"],"where":["14.6"],"where是分组之前进行过滤":["14.7"],"聚合函数":["14.8"],"emp":["14.9"],"order":["14.9"],"by":["14.9"],"entrydate":["14.9"],"起始索引从0开始":["14.10"],"起始索引":["14.10"],"查询页码":["14.10"],"每页显示记录数":["14.10"],"mysql是limit":["14.10"],"不同的数据库不同":["14.10"],"constraint":["14.11"],"fk":["14.11"],"e":["14.12","16.5","16.22","16.39","17.17"],"d":["14.12"],"隐式内连接":["14.12"],"c":["14.13","19.73","41.10","42.32"],"and":["14.13"],"查询价格在10":["14.13"],"50之间起售的商品":["14.13"],"begin":["14.14","75.28"],"执行删除操作":["14.14"],"delete":["14.14"],"结构组织索引":["14.15"],"为什么不用二叉树或者红黑树":["14.15"],"大数据量情况下":["14.15"],"层级深":["14.15"],"检索速度越慢":["14.15"],"bean的声明":["15.2"],"要把某个对象交给ioc容器管理":["15.2"],"需要在对应的类上加上如下注解之一":["15.2"],"注解":["15.2"],"说明":["15.2"],"位置":["15.2"],"面向特定方法编程":["15.3"],"连接点":["15.3"],"joinpoint":["15.3"],"在目标方法前后执行":["15.4"],"before":["15.4","41.9"],"和类名自动排序有关":["15.5"],"项目启动时":["15.6"],"springbootapplication":["15.7"],"工程引导类":["15.7"],"三部分组成":["15.7"],"springbootconfiguration":["15.7"],"线程状态":["16.0"],"enum":["16.1"],"state":["16.1","34.6","36.5","38.2","41.5","52.6"],"新建":["16.1"],"可运行状态":["16.1"],"runnable":["16.1","16.13","16.23","16.33","16.43","16.45","16.50","17.13"],"阻塞状态":["16.1"],"blocked":["16.1"],"无限等待状态":["16.1"],"waiting":["16.1"],"threadstatedemo01":["16.3"],"throws":["16.3","16.4","16.11","16.43","16.47"],"interruptedexception":["16.3","16.4","16.11","16.22","16.39","16.43","16.47","17.17"],"定义一个内部线程":["16.3","16.4"],"thread":["16.3","16.4","16.5","16.11","16.16","16.17","16.50","17.9","17.12"],"定义一个对象":["16.4"],"用来加锁和解锁":["16.4"],"object":["16.4","45.4","45.15"],"obj":["16.4","19.4","19.73","20.7","20.13","20.18","20.24","22.10","45.4","45.9","45.15","59.5"],"thread1":["16.4"],"定义一个线程":["16.5"],"先抢占了obj2对象的锁":["16.5"],"synchronized":["16.5"],"try":["16.5","16.22","16.39","16.50","17.17"],"sleep":["16.5","16.22","16.39"],"第一个线程要持有锁100毫秒":["16.5"],"wait":["16.5","17.17"],"然后通过wait":["16.5"],"方法进行等待状态":["16.5"],"并释放obj2的对象锁":["16.5"],"catch":["16.5","16.22","16.39","17.17"],"printstacktrace":["16.5","16.22","16.39"],"start":["16.5","16.39","26.5"],"定义目标线程":["16.5"],"获取等待获取obj2的锁":["16.5"],"大家应该能想到的就是水池":["16.6"],"水池就是一个容器":["16.6"],"在该容器中存储了很多的水":["16.6"],"那么什么是线程池呢":["16.6"],"线程池的设计思路":["16.8"],"线程池的思路和生产者消费者模型是很接近的":["16.8"],"准备一个任务容器":["16.8"],"final":["16.9","16.36","16.42"],"poolsize":["16.9"],"linkedblockingqueue":["16.9","16.13"],"无参构造方法":["16.9"],"this":["16.9","16.22","16.46","19.28","20.31","23.1","36.5","38.2","42.13","42.17","59.8","69.2","69.3","69.4","71.5","71.7","71.8","71.9","71.10","71.11","72.4","72.8","72.9"],"initthread":["16.9"],"有参构造方法":["16.9"],"案例1":["16.11"],"演示newcachedthreadpool方法所获取到的线程池的特点":["16.11"],"测试类":["16.11","16.49"],"executorsdemo01":["16.11"],"演示executors中的newcachedthreadpool返回的线程池的特点":["16.11"],"获取线程池对象":["16.11"],"threadpool":["16.11"],"提交任务":["16.11"],"currentthread":["16.11","16.16"],"getname":["16.11","16.16"],"执行了任务":["16.11","16.16"],"不使用线程池了":["16.11"],"还可以将线程池关闭":["16.11"],"控制台输出结果":["16.11","16.16"],"针对每一个任务":["16.11"],"线程池为其分配一个线程去执行":["16.11"],"我们可以在第二次提交任务的时候":["16.11"],"让主线程休眠一小会儿":["16.11"],"看程序的执行结果":["16.11"],"executorsdemo02":["16.11"],"然后直接返回":["16.13"],"return":["16.13","16.17","16.22","18.4","21.9","36.9","37.9","41.5","41.7","42.3","45.4","45.17","45.19","47.0","53.14","56.0","59.5","59.9","60.0","61.1","62.0","63.0","70.0","71.7","71.8","71.9","71.11","71.16","72.11","72.12","76.2"],"threadpoolexecutor":["16.13","16.15"],"0l":["16.13"],"timeunit":["16.13","16.39"],"milliseconds":["16.13"],"那么也可以使用threadpoolexecutor去创建线程池":["16.13"],"threadpoolexecutor最完整的构造方法":["16.13"],"客户端每次提交一个任务":["16.14"],"线程池就会在核心线程池中创建一个工作线程来执行这个任务":["16.14"],"当核心线程池中的线程已满时":["16.14"],"则进入下一步操作":["16.14"],"把任务试图存储到工作队列中":["16.14"],"核心线程数量为1":["16.15"],"最大线程池数量为3":["16.15"],"任务容器的容量为1":["16.15"],"空闲线程的最大存在时间为20s":["16.15"],"executors":["16.16"],"defaultthreadfactory":["16.16"],"提交5个任务":["16.16"],"而该线程池最多可以处理4个任务":["16.16"],"当我们使用abortpolicy这个任务处理策略的时候":["16.16"],"就会抛出异常":["16.16"],"for":["16.16","16.39","20.8","53.14","59.4","59.7","59.9","66.1","66.2","66.3","74.2","76.5","85.13"],"x":["16.16","16.39","30.4","42.2","42.25"],"submit":["16.16"],"exception":["16.16"],"in":["16.16","20.8","42.32"],"util":["16.16"],"concurrent":["16.16"],"rejectedexecutionexception":["16.16"],"task":["16.16"],"futuretask":["16.16"],"566776ad":["16.16"],"not":["16.16"],"completed":["16.16"],"runnableadapter":["16.16"],"edf4efb":["16.16"],"wrapped":["16.16"],"itheima":["16.16"],"javase":["16.16"],"demo04":["16.16"],"lambda":["16.16"],"定义成员变量":["16.17","16.46"],"flag":["16.17"],"false":["16.17","19.40","20.4","24.2","71.16","72.11","72.12"],"isflag":["16.17"],"memory":["16.18"],"model":["16.18","19.64","50.1","80.5","80.7"],"java内存模型":["16.18"],"是java虚拟机规范中所定义的一种内存模型":["16.18"],"将flag的值更改为true":["16.19","16.22"],"但是这个时候flag的值还没有回写主内存":["16.19"],"此时main线程读取到了flag的值并将其放入到自己的工作内存中":["16.19"],"此时flag的值为false":["16.19"],"volatilethread线程将flag的值写回到主内存":["16.19"],"但是main函数里面的while":["16.19"],"true":["16.19","16.22","19.39","20.19"],"调用的是系统比较底层的代码":["16.19"],"volatilethreaddemo03":["16.21"],"override":["16.22","16.23","16.50"],"run":["16.22","16.23","16.50"],"线程休眠1秒":["16.22"],"定义一个int类型的变量":["16.23","16.33"],"count":["16.23","16.24","16.41","16.43","38.0","88.1"],"对该变量进行":["16.23"],"操作包含3个步骤":["16.24"],"从主内存中读取数据到工作内存":["16.24"],"对工作内存中的数据进行":["16.24"],"操作":["16.24","45.22"],"将工作内存中的数据写回到主内存":["16.24"],"测试的思想":["16.25"],"就是使用volatile修饰count":["16.25"],"线程类":["16.25","16.27"],"volatileatomicthread":["16.25","16.33"],"这个变量就相当于一个标志":["16.27"],"当这个变量的值为true的时候":["16.27"],"线程一直执行":["16.27"],"10秒以后我们把这个变量的值更改为false":["16.27"],"此时结束该线程的执行":["16.27"],"为了保证一个线程对这个变量的修改":["16.27"],"另外一个线程立马可以看到":["16.27"],"这个变量就需要通过volatile关键字进行修饰":["16.27"],"传感器的类型":["16.28"],"temperature变量需要被volatile修饰":["16.28"],"定义一个读取温度传感器的线程的任务类":["16.28"],"readtemperaturerunnable":["16.28"],"该类需要定义一个temperaturesensor类型的成员变量":["16.28"],"该线程需要读取温度传感器的数据":["16.28"],"定义一个定时采集温度的线程任务类":["16.28"],"gathertemperaturerunnable":["16.28"],"该线程需要将读到的温度设置给传感器":["16.28"],"创建测试类":["16.28","16.47"],"temperaturesensordemo":["16.28"],"创建temperaturesensor对象":["16.28"],"创建readtemperaturerunnable类对象":["16.28"],"把temperaturesensor作为构造方法的参数传递过来":["16.28"],"创建gathertemperaturerunnable类对象":["16.28"],"创建2个thread对象":["16.28"],"并启动":["16.28"],"把第二步所创建的对象作为构造方法参数传递过来":["16.28"],"这两个线程负责读取temperaturesensor中的温度数据":["16.28"],"创建1个thread对象":["16.28"],"把第三步所创建的对象作为构造方法参数传递过来":["16.28"],"这个线程负责读取定时采集数据中的温度数据":["16.28"],"temperaturesensor类":["16.28"],"操作就是临界区中的代码":["16.30"],"临界区中的代码一次只能被一个线程去执行":["16.30"],"所以count":["16.30"],"就变成了原子操作":["16.30"],"线程任务类":["16.30"],"字段":["16.32"],"本次我们只讲解":["16.32"],"使用原子的方式更新基本类型":["16.32"],"使用原子的方式更新基本类型atomic包提供了以下3个类":["16.32"],"atomicboolean":["16.32"],"原子更新布尔类型":["16.32"],"原子更新整型":["16.32"],"atomiclong":["16.32"],"原子更新长整型":["16.32"],"以上3个类提供的方法几乎一模一样":["16.32"],"所以本节仅以atomicinteger为例进行讲解":["16.32"],"atomicinteger的常用方法如下":["16.32"],"初始化一个默认值为0的原子型integer":["16.32"],"implements":["16.33","16.43","16.46","17.13"],"atomicinteger":["16.33"],"swap":["16.35"],"比较再交换":["16.35"],"是现代cpu广泛支持的一种对内存中的共享数据进行操作的一种特殊指令":["16.35"],"cas可以将read":["16.35"],"modify":["16.35"],"write转换为原子操作":["16.35"],"这个原子操作":["16.35"],"直接由处理器保证":["16.35"],"cas有3个操作数":["16.35"],"内存值v":["16.35"],"旧的预期值a":["16.35"],"jdk":["16.36"],"internal":["16.36"],"misc":["16.36"],"unsafe":["16.36"],"u":["16.36"],"getunsafe":["16.36"],"表示变量值在内存中的偏移量地址":["16.36"],"unsafe类就是根据内存偏移量地址获取数据值":["16.36"],"cas和synchronized都可以保证多线程环境下共享数据的安全性":["16.37"],"那么他们两者有什么区别":["16.37"],"synchronized是从悲观的角度出发":["16.37"],"put":["16.39"],"valueof":["16.39"],"线程t2":["16.39"],"t2":["16.39"],"启动线程":["16.39"],"主线程休眠2s":["16.39"],"seconds":["16.39","28.12"],"transient":["16.41"],"volatile":["16.41"],"segment中元素的数量":["16.41"],"由volatile修饰":["16.41"],"支持内存可见性":["16.41"],"modcount":["16.41"],"对table的大小造成影响的操作的数量":["16.41"],"比如put或者remove操作":["16.41"],"threshold":["16.41"],"扩容阈值":["16.41"],"hashentry":["16.41"],"链表数组":["16.41"],"数组中的每一个元素代表了一个链表的头部":["16.41"],"float":["16.41"],"loadfactor":["16.41"],"负载因子":["16.41"],"segment中的元素是以hashentry的形式存放在数组中的":["16.41"],"其结构与普通hashmap的hashentry基本一致":["16.41"],"不同的是segment的hashentry":["16.41"],"其value由":["16.41"],"volatile修饰":["16.41"],"以支持内存可见性":["16.41"],"即写操作对其他读线程即时可见":["16.41"],"hash":["16.41","16.42","69.1"],"当前key的hashcode值":["16.42"],"key":["16.42","22.8","45.4","45.8","45.9","45.15","45.21","45.29","62.0","69.3","71.12"],"键":["16.42"],"val":["16.42","45.4","45.15","67.7"],"值":["16.42"],"next":["16.42","19.54","19.74","67.3","67.6"],"下一个节点":["16.42","67.1"],"treenode类的定义":["16.42"],"treenode":["16.42"],"parent":["16.42","38.4"],"父节点":["16.42"],"左子节点":["16.42"],"right":["16.42","56.10","71.16"],"右子节点":["16.42"],"prev":["16.42","67.3","67.6"],"needed":["16.42"],"to":["16.42","37.12"],"unlink":["16.42"],"upon":["16.42"],"deletion":["16.42"],"red":["16.42"],"节点的颜色状态":["16.42"],"对应的结构如下图":["16.42"],"1571901607504":["16.42"],"初始化一个指定计数器的countdownlatch对象":["16.43"],"await":["16.43","16.45"],"让当前线程等待":["16.43"],"countdown":["16.43"],"计数器进行减1":["16.43"],"案例演示":["16.43","16.45","16.47","16.49"],"使用countdownlatch完成上述需求":["16.43"],"我们在主线程需要开启2个其他线程":["16.43"],"实现思路":["16.43"],"在main方法中创建一个countdownlatch对象":["16.43"],"把这个对象作为作为参数传递给其他的两个任务线程":["16.43"],"线程任务类1":["16.43"],"countdownlatchthread01":["16.43"],"countdownlatch类型成员变量":["16.43"],"几乎同时启动":["16.45"],"使用cyclicbarrier保证5名员工线程全部执行后":["16.45"],"再执行开会线程":["16.45"],"cyclicbarrier的相关方法":["16.45"],"cyclicbarrier":["16.45","16.46"],"parties":["16.45"],"barrieraction":["16.45"],"用于在线程到达屏障时":["16.45"],"优先执行barrieraction":["16.45"],"方便处理更复杂的业务场景":["16.45"],"每个线程调用await方法告诉cyclicbarrier我已经到达了屏障":["16.45"],"然后当前线程被阻塞":["16.45"],"模拟员工开会":["16.45"],"实现步骤":["16.45","16.47","16.49"],"定义一个任务类cyclicbarrierthreaduse":["16.46"],"实现了runnable接口":["16.46"],"concurrenthashmap":["16.46"],"integer":["16.46"],"定义一个方法count方法":["16.46"],"在count方法中开启两个线程对象":["16.46"],"可以使用匿名内部类的方式实现":["16.46"],"在run方法中对concurrenthashmap中的数据进行汇总":["16.46"],"编写测试类cyclicbarrierthreadusedemo":["16.46"],"创建cyclicbarrierthreaduse对象":["16.46"],"调用count方法":["16.46"],"任务类代代码":["16.46"],"cyclicbarrierthreaduse":["16.46"],"表示许可线程的数量":["16.47"],"acquire":["16.47"],"表示获取许可":["16.47"],"release":["16.47"],"表示释放许可":["16.47"],"模拟汽车通过十字路口":["16.47"],"创建一个汽车的线程任务类":["16.47"],"carthreadrunnable":["16.47"],"在该类中定义一个semaphore类型的成员变量":["16.47"],"如果第一个线程先执行exchange":["16.49"],"方法":["16.49","19.74","45.22","85.12"],"它会一直等待第二个线程也执行exchange方法":["16.49"],"当两个线程都到达同步点时":["16.49"],"这两个线程就可以交换数据":["16.49"],"将本线程生产出来的数据传递给对方":["16.49"],"模拟交互结婚戒指":["16.49"],"创建一个男方的线程类":["16.49"],"manthread":["16.49"],"定义一个exchanger类型的成员变量":["16.49"],"创建一个女方的线程类":["16.49"],"womanthread":["16.49"],"创建一个exchanger对象":["16.49"],"创建一个manthread对象":["16.49"],"把第一步所创建的exchanger作为构造方法参数传递过来":["16.49"],"创建一个womanthread对象":["16.49"],"创建exchanger对象":["16.50"],"exchanger":["16.50"],"被包含在进程之中":["17.1"],"优先级也不是绝对的":["17.5"],"守护线程也会陆续结束":["17.6"],"就绪":["17.8"],"有执行资格和执行权":["17.8"],"运行代码":["17.8"],"运行":["17.8"],"虚拟机没有这个状态":["17.8"],"mutex":["17.10"],"或同步机制来保护共享资源":["17.10"],"确保同一时间只有一个线程可以访问该资源":["17.10"],"可以使用":["17.10"],"不可中断的单个操作":["17.11"],"原子操作要么完全执行":["17.11"],"要么不执行":["17.11"],"不存在执行过程中被其他线程干扰的情况":["17.11"],"synchronizeddemo":["17.12"],"当前类名的字节码文件":["17.13"],"runnabledemo":["17.13"],"多线程不安全":["17.14"],"lock提供了获得锁和释放锁的方法":["17.15"],"break":["17.17"],"else":["17.17","67.7","71.16"],"foodflag":["17.17"],"让当前线程跟锁进行绑定":["17.17"],"throw":["17.17"],"runtimeexception":["17.17"],"核心线程数量":["17.18"],"最大线程数量":["17.18"],"最大并行数":["17.19"],"getmapping":["18.2"],"depts":["18.2"],"restcontroller这个方法":["18.3"],"这个方法中首先会通过":["18.3"],"pagesize":["18.4"],"log":["18.4","20.26","21.3","21.5","21.8","41.10","42.21","44.34","45.17","53.13","85.1","85.10"],"info":["18.4"],"查询全部的数据":["18.4"],"pagebean":["18.4"],"empservice":["18.4"],"多线程编程涉及到线程间的同步和竞争条件处理":["19.1"],"避免复杂的并发问题":["19.1"],"js的基础类型":["19.2"],"基础类型有":["19.2"],"typeof和instanceof的区别":["19.3"],"arr":["19.4","19.59","19.72","19.73","66.2","66.3","66.4","66.5","75.1","75.2","75.3","75.17","76.2","77.1","77.2","77.3"],"不能准确判断":["19.4"],"reg":["19.4"],"error":["19.4","21.5"],"constructor":["19.4"],"返回实例对象的构造函数":["19.4"],"构造函数的原型对象上会有一个":["19.4"],"指向了构造函数自身":["19.4"],"所以实例对象通过原型链访问":["19.4"],"就能找到自己的构造函数":["19.4"],"也就是自己的类型了":["19.4"],"instanceof":["19.4"],"沿着原型链去找":["19.4"],"它的作用是检测实例对象是不是属于某个构造函数":["19.4"],"可以用来做数据类型的检测":["19.4"],"缺点":["19.4"],"不能检测基本数据类型":["19.4"],"原型链可能被修改":["19.4"],"导致检测结果不准确":["19.4"],"只要能在原型链上找到构造函数":["19.4"],"就返回":["19.4"],"所以类型可能不准确":["19.4"],"没有":["19.5","85.5"],"defer":["19.5"],"即使放在head里面":["19.7"],"defer是html4的async是html5新增的":["19.8"],"因为立即执行":["19.9"],"类中的方法的this不是固定的":["19.10"],"实现单线程非阻塞方法就是事件循环":["19.11"],"分为同步任务和异步任务":["19.11"],"同步任务进入主线程":["19.11"],"即一个宏任务":["19.12"],"所有微任务":["19.12"],"渲染":["19.12"],"一个宏任务":["19.12"],"异步任务":["19.13"],"不进入主线程":["19.13"],"而进入任务队列的任务":["19.13"],"执行宏任务期间产生的所有微任务":["19.14"],"组成":["19.14"],"而是在指定时间后":["19.15"],"将回调函数放入事件循环的队列中":["19.15"],"promise":["19.16","21.7","21.9","61.0","85.9"],"tick队列":["19.17"],"新旧对象不共享同一地址":["19.18"],"如果属性值是对象或数组":["19.20"],"会影响":["19.21"],"原对象":["19.21"],"即使外部函数已经执行完毕":["19.22"],"这些变量和参数仍然可以被内部函数访问":["19.22"],"任何闭包的使用场景都离不开这两点":["19.22"],"创建私有变量":["19.22"],"延长变量的生命周期":["19.22"],"意外的全局变量":["19.23"],"分配内存":["19.24"],"引用计数":["19.25"],"如果一个值的引用次数是0":["19.25"],"就表示这个值不再用到了":["19.25"],"引擎会创建执行上下文":["19.26"],"除了判断nan为true":["19.27"],"方法用于返回":["19.30"],"指定对象的原始值":["19.30"],"若对象没有原始值":["19.30"],"则将返回对象本身":["19.30"],"基本数据类型":["19.31"],"number":["19.34","20.30","42.2","42.4","42.6","42.19","42.20","70.1"],"objstr":["19.34"],"转布尔值都是false":["19.35"],"null":["19.35","20.12","24.2","42.11","42.14","67.2","67.4","67.6","72.9"],"undefined":["19.35","19.39","42.11"],"是object":["19.36"],"在比较过程中会存在隐式转换":["19.37"],"转成string类型":["19.38"],"字符串连接符":["19.38"],"为":["19.39","45.20"],"为什么是":["19.40","19.41"],"优先级高于":["19.42"],"不是假值":["19.42"],"所以先转换成":["19.42"],"就是没有函数名的函数":["19.44"],"xxx":["19.45","34.29","45.26"],"需不需要阻止冒泡":["19.46"],"归类于变量声明":["19.47"],"享受变量提升":["19.47"],"函数提升优先级":["19.47"],"由最具体的元素接收":["19.48"],"fetch有啥区别":["19.49"],"domcontentloaded的区别":["19.50"],"dom文档加载的步骤为":["19.50"],"stopbubble":["19.51"],"stopdefault":["19.52"],"可以把事件绑定在父元素上":["19.53"],"const":["19.54","19.73","20.3","20.4","20.10","20.16","20.20","22.4","23.3","38.8","41.5","41.7","41.10","44.30","44.34","44.35","44.51","45.8","45.9","45.21","45.32","51.7","53.14","59.9","70.1","85.4"],"newarr":["19.54"],"创建一个空数组存储去重后的元素":["19.54"],"reduce":["19.54","75.25","77.3"],"pre":["19.54","34.24"],"nan不等于自身":["19.55"],"也就是":["19.55"],"关键字用于在子类中访问和调用父类的构造函数":["19.57"],"返回数组长度":["19.58"],"pop":["19.58","37.8","70.0","75.20"],"删除数组最后一项":["19.58"],"返回被删除项":["19.58"],"shift":["19.58"],"删除数组第一项":["19.58"],"并返回被删除项":["19.58"],"unshift":["19.58"],"取arr中的最大值":["19.59"],"min":["19.59"],"分别是":["19.60"],"方法用于将js日期转换为iso标准":["19.61"],"它使用iso标准将js":["19.61"],"date对象转换为字符串":["19.61"],"不会编码类似这样字符":["19.62"],"如果需要编码这些字符":["19.62"],"请使用encodeuricomponent":["19.62"],"用法":["19.62"],"var":["19.62","19.72","20.7","20.18","27.0","30.4","66.1","72.2"],"navigator":["19.63"],"history":["19.63","43.5"],"api":["19.63","37.3","44.21"],"作用":["19.63"],"代表方法或属性":["19.63"],"即浏览器对象模型":["19.64"],"主要处理浏览器窗口和框架":["19.64"],"没有统一遵循的标准":["19.64"],"dom全称document":["19.64"],"函数有什么区别":["19.65"],"startindex":["19.66","19.67"],"length":["19.66","53.14","59.7","59.9","66.5","67.2","70.0","72.8","73.1","73.2","75.13"],"endindex":["19.67"],"strict":["19.68","37.4"],"标签规定了用户可以在其中输入数据的输入字段":["19.69"],"它是一个类数组对象":["19.71"],"可以通过数字索引获取其中的参数":["19.71"],"对象可以在函数内部访问":["19.71"],"对象必须实现":["19.74"],"symbol":["19.74","20.6"],"iterator":["19.74","75.22","75.23"],"该方法返回一个迭代器对象":["19.74"],"迭代器对象必须包含一个":["19.74"],"关键字会将空对象的原型链指向构造函数的原型对象":["19.75"],"这样":["19.75","38.0"],"新创建的对象就可以访问构造函数原型对象中定义的方法和属性":["19.75"],"构建函数中的this绑定到新建的对象obj上":["19.75"],"执行构造函数代码块":["19.75"],"关键字会调用构造函数":["19.75"],"currenttarget":["19.76"],"表示事件的当前目标元素":["19.76"],"即当前":["19.76"],"正在处理事件的元素":["19.76"],"只有一个":["19.77"],"浏览器中的全局对象就是":["19.77"],"也叫调用栈":["19.78"],"具有":["19.78"],"方法将所有可枚举":["20.3"],"从一个或多个源对象复制到目标对象":["20.3"],"返回修改后的对象":["20.3"],"传入的对象":["20.4"],"ishuman":["20.4"],"printintroduction":["20.4"],"console":["20.4","20.26","21.3","21.5","21.8","21.9","41.10","42.21","44.34","45.17","53.13","85.1","85.10"],"要定义属性的对象":["20.6"],"要定义或修改的属性的名称或":["20.6"],"其排列与使用":["20.8"],"循环遍历该对象时返回的顺序一致":["20.8"],"区别在于":["20.8"],"方法可以冻结一个对象":["20.9"],"方法把键值对列表转换为一个对象":["20.10"],"entries":["20.10"],"返回值":["20.12","20.14"],"给定对象的原型":["20.12"],"如果没有继承属性":["20.12"],"则返回":["20.12"],"要设置其原型的对象":["20.13"],"该对象的新原型":["20.13"],"一个对象或":["20.13"],"human":["20.13"],"在该对象的原型链上搜寻":["20.14"],"表示调用对象是否在另一个对象的原型链上":["20.14"],"foo":["20.14"],"bar":["20.14","20.26"],"afunction":["20.15"],"中":["20.15"],"的原型链是针对":["20.15"],"自有属性指的是直接赋予该对象的属性":["20.16"],"不需要从原型链上进行查找的属性":["20.16"],"返回":["20.19","75.6"],"如果属性是继承的或者不存在":["20.19"],"该方法返回":["20.19"],"属性值为null或undefind时也会返回true":["20.20"],"有值就会返回true":["20.20"],"object1":["20.20"],"property1":["20.20"],"返回一个布尔值":["20.21"],"value1":["20.21"],"value2":["20.21"],"不会强制转换两边的值":["20.22"],"也不相同":["20.22"],"差别是它们对待有符号的零和":["20.22"],"nan":["20.22"],"运算符":["20.22"],"也包括":["20.22"],"将数字":["20.22"],"视为相等":["20.22"],"而将":["20.22"],"方法会返回一个由一个给定对象的自身可枚举属性组成的数组":["20.25"],"数组中属性名的排列顺序和正常循环遍历该对象时返回的顺序一致":["20.25"],"baz":["20.26"],"array":["20.26","42.1","59.4"],"like":["20.26"],"propertyisenumerable":["20.28"],"不接受任何参数":["20.30"],"然而":["20.30"],"继承自":["20.30"],"的对象可能用它们自己的实现重写它":["20.30"],"这些实现可以接受参数":["20.30"],"方法将":["20.31"],"值转换为一个对象":["20.31"],"此方法旨在用于自定义类型转换的逻辑时":["20.31"],"当我们new一个promise":["21.0"],"此时我们需要传递一个回调函数":["21.0"],"方法可以捕获到":["21.1"],"之前整条":["21.1"],"链路上所有抛出的异常":["21.1"],"二":["21.1"],"pending":["21.2"],"待定":["21.2"],"执行了executor":["21.2"],"状态还在等待中":["21.2"],"没有被兑现":["21.2"],"也没有被拒绝":["21.2"],"reject":["21.3","21.6","60.0","61.0"],"ice":["21.3"],"then":["21.3","21.5","21.8"],"res":["21.3","21.5","21.8","21.9"],"存放在promise":["21.4"],"prototype上的方法":["21.4"],"也就是promise的原型对象上":["21.4"],"rej":["21.5"],"resolve":["21.6","43.7","61.0"],"hi":["21.8"],"promise2":["21.8"],"panda":["21.8"],"promise3":["21.8"],"grizzly":["21.8"],"all方法的参数传入为一个可迭代对象":["21.8"],"返回一个promise":["21.8"],"只有":["21.8"],"三个都为resolve状态的时候才会调用":["21.8"],"then方法":["21.8"],"会被放进微任务队列":["21.10"],"async":["21.10"],"fn2":["21.10"],"所以5和":["22.1"],"是两个不同的值":["22.1"],"内部判断两个值是否不同":["22.1"],"使用的算法叫做":["22.1"],"same":["22.1"],"元素数量":["22.2"],"判断集合中是否存在":["22.3"],"清空集合":["22.3"],"set":["22.5","22.8","41.5","62.0"],"set1":["22.6"],"set2":["22.6"],"共同点":["22.7"],"可以储存不重复的值":["22.7"],"不同点":["22.7"],"返回字典中所包含的元素个数":["22.8"],"value":["22.8","45.8","47.0","63.0"],"map2obj":["22.9"],"obj2map":["22.10"],"weakmap只能是对象引用":["22.11"],"map中的键值对在不再被引用时不会被垃圾回收":["22.11"],"除非map对象本身被垃圾回收":["22.11"],"指向的是一个空对象":["23.1"],"如果在":["23.1"],"在全局作用域中调用":["23.2"],"时":["23.2"],"它的值指向全局对象":["23.2"],"即在浏览器中指向":["23.2"],"window":["23.2"],"this指向当前person实例对象":["23.3"],"ljt":["23.3"],"指向window":["23.3"],"fn":["23.3","59.1","59.2"],"三者都可以改变函数的this对象指向":["23.4"],"三者第一个参数都是this要指向的对象":["23.4"],"检查其两个操作数是否相等":["24.1"],"转换为布尔值":["24.2"],"括号":["24.3"],"成员访问":["24.3"],"将cookie的domain属性设置为父域的域名":["25.0"],"主域名":["25.0"],"密码":["25.1"],"sso系统进行认证后":["25.1"],"将登录状态写入sso的session":["25.1"],"浏览器中写入":["25.1"],"sso域下的cookie":["25.1"],"sso系统登录完成后会生成一个":["25.1"],"token":["25.1"],"然后跳转到app系统":["25.1"],"同时将":["25.1"],"作为参数传递给app系统":["25.1"],"参数是数组的长度":["26.1"],"值为0":["26.1"],"遍历":["26.1"],"map":["26.1","32.9","51.7","75.12"],"将数组中的元素映射到另一个数组返回一个新数组":["26.1"],"foreach":["26.1","45.4","45.9","60.0"],"将元素依次执行操作":["26.1"],"不产生新数组":["26.1"],"不影响原数组":["26.1"],"flatmap":["26.1"],"words":["26.4"],"apple":["26.4","82.7"],"banana":["26.4"],"必需":["26.5"],"从该位置开始替换数据":["26.5"],"如果为负值":["26.5"],"表示倒数":["26.5"],"可选":["26.5"],"您可以使用regexp构造函数来创建正则表达式对象":["27.0"],"regex":["27.0"],"regexp":["27.0"],"pattern":["27.0"],"flags":["27.0"],"其中pattern是正则表达式模式字符串":["27.0"],"flags是一个可选的标志字符串":["27.0"],"先把组件样式写好":["28.1"],"然后为每个组件配置一个公共代码":["28.1"],"结合的语法糖":["28.2"],"而在":["28.2"],"vue3":["28.2"],"组件中使用v":["28.2"],"model则表示的是":["28.2"],"modelvalue":["28.2"],"的语法糖":["28.2"],"子组件通过父组件定义的":["28.2"],"接收值传给原生input的":["28.2"],"通过原生input的":["28.2"],"每次都要全部引入所有的样式文件":["28.3"],"不仅仅是打包css文件":["28.4"],"执行命令的函数":["28.5"],"把请求的地址放在一个文件":["28.6"],"用来存放从服务器拿到的数据":["28.7"],"用的express写的一些get":["28.8"],"提高团队的效率":["28.9"],"更好的扩展性":["28.9"],"由于前后端分离的松耦合性":["28.9"],"您可以更容易地扩展和升级应用程序的不同部分":["28.9"],"于2015年发布":["28.10"],"它引入了一些重要的改进":["28.10"],"其中最显著的是多路复用":["28.10"],"multiplexing":["28.10"],"功能":["28.10","32.7"],"多路复用允许在单个tcp连接上同时发送多个请求和响应":["28.10"],"中间人攻击":["28.11"],"man":["28.11"],"control字段":["28.12"],"cache":["28.12","53.19"],"max":["28.12","59.10"],"指定资源文件在被认为是新鲜":["28.12"],"是指在网页加载过程中":["28.13"],"元素的位置发生了突然而意外的变化":["28.13"],"可能会导致用户体验的不良影响":["28.13"],"这种突然的变化可能会使用户点击错位或产生其他交互问题":["28.13"],"减少页面重绘和回流":["28.14"],"提高性能":["28.14"],"优化网络请求":["28.14"],"减少网络请求次数":["28.14"],"使用压缩和缓存等技术来优化网络传输":["28.14"],"懒加载和按需加载":["28.14"],"只在需要时加载资源":["28.14"],"旨在为web开发者提供直接访问图形硬件的低级别图形编程接口":["28.15"],"跳过了解压的过程":["28.16"],"速度":["28.16"],"单一代码仓库":["28.17"],"模块":["29.1","29.4","51.5"],"学习":["29.1"],"模块使用require":["29.2"],"加载一个模块对象和module":["29.2"],"exports输出一个模块对象":["29.2"],"模块采用":["29.3"],"mjs后缀文件名":["29.3"],"但是只能整体加载":["29.4"],"不能只加载单一的输出项":["29.4"],"但是可以这样写":["29.4"],"import":["29.4","34.21","46.6","78.3","82.3"],"exports":["29.5"],"require":["29.5"],"exit":["29.7"],"cookie的有效期是可以设置的":["30.1"],"cookie的存储是4kb左右":["30.2"],"cookie会参与到与服务端的通信中":["30.3"],"doe":["30.4"],"cookie的读取":["30.4"],"cookie的删除":["30.4"],"cookie出现的时间较早":["30.5"],"什么是token":["30.6"],"令牌":["30.7"],"服务端":["30.8"],"服务端收到请求":["30.8"],"验证用户名和密码":["30.8"],"服务端验证":["30.8"],"存localstorage里":["30.9"],"常见的使用场景包括用户认证":["30.10"],"购物车":["30.10"],"网站偏好设置等":["30.10"],"cookie是由服务器发送给浏览器的一个小的文本文件":["30.10"],"浏览器会将它保存在本地":["30.10"],"以备将来使用":["30.10"],"vite采用不同方式":["31.0"],"scripts":["31.1"],"dev":["31.1"],"初始化项目":["32.0"],"pnpm":["32.0"],"init":["32.0","55.3"],"production生产模式":["32.2"],"数组":["32.3"],"形式里写多个入口":["32.3"],"boundle":["32.4"],"文件名不一样之前打包的不会删除":["32.4"],"开箱可用的自带能力":["32.5"],"让":["32.5"],"能够去处理其他类型的文件":["32.5"],"并将它们转换为有效":["32.5"],"配置":["32.6"],"rules":["32.6"],"test":["32.6"],"的":["32.7","44.53","75.12"],"支柱":["32.7"],"server":["32.8","55.1"],"启动一个本地开发服务器":["32.8"],"inline":["32.9"],"source":["32.9","51.6"],"jvavscript":["33.0"],"vue":["33.0","44.23","44.40","44.46","45.24","48.0","64.0","78.2","79.2","82.2"],"jsx":["34.1","34.21","35.6","37.12","37.17","38.0","38.7"],"函数执行":["34.2"],"函数组件usestate会":["34.2"],"判断当前值有无发生改变确定是否执行render方法":["34.2"],"一旦父组件发生渲染":["34.2"],"子组件也会渲染":["34.2"],"在一个组件中":["34.2"],"created":["34.3","44.38"],"setup":["34.3","52.0"],"world":["34.4"],"classcomponent":["34.4"],"component":["34.4","34.9","35.1","37.17","43.11","44.57"],"render":["34.4","34.6","34.8"],"组件状态管理":["34.4"],"版本之前":["34.4"],"函数组件只能是无状态的":["34.4"],"componentdidupdate":["34.5"],"卸载阶段":["34.5"],"componentwillunmount":["34.5"],"componentwillmount发生在render之前":["34.5"],"此时还没有挂载dom":["34.5"],"有可能会被执行多次":["34.5"],"接收":["34.6"],"props":["34.6","34.27","38.6"],"并返回一个新的状态":["34.6"],"根据组件的状态和属性":["34.6"],"返回要渲染的元素结构":["34.6"],"componentdidmount":["34.6","34.26"],"该生命周期在":["34.7"],"render方法之前调用":["34.7"],"在初始化和后续更新都会被调用":["34.7"],"后挂载到真实":["34.8"],"前进行的操作":["34.8"],"purecomponent":["34.9"],"来创建的":["34.9"],"而是去":["34.10"],"新开辟一块内存":["34.10"],"而vue则是直接修改保存状态的那块":["34.10"],"原始内存":["34.10"],"然后让渡主线程":["34.11"],"给浏览器去做其他工作":["34.11"],"然后继续比较":["34.11"],"依次往复":["34.11"],"等到最后比较完成":["34.11"],"一次性更新到视图上":["34.11"],"fiber使得diff阶段有了被保存工作进度的能力":["34.11"],"无法精确更新":["34.12"],"所以需要react":["34.12"],"事件派发":["34.13"],"react":["34.13","34.21","41.0"],"的所有事件并没有绑定到具体的dom节点上而是绑定在了document":["34.13"],"上":["34.13"],"虚拟dom阶段":["34.14"],"处理组件的props是否有声明为事件":["34.14"],"得到事件类型":["34.14"],"click":["34.14","44.29","47.0","63.0"],"change":["34.14"],"和对应的事件处理程序":["34.14"],"模拟原生":["34.15"],"事件所有能力的一个事件对象":["34.15"],"即在react中":["34.15"],"我们绑定的事件onclick等":["34.15"],"并不是原生事件":["34.15"],"事件插件中eventplugin":["34.16"],"17废除":["34.17"],"引入事件池":["34.17"],"在事件池中获取或释放事件对象":["34.17"],"合成事件的阻止冒泡不会影响原生事件":["34.18"],"document":["34.19"],"对象上当真实":["34.19"],"事件统一绑定container上":["34.20"],"reactdom":["34.20"],"以便在多个组件之间共享":["34.21"],"这样可以避免重复代码":["34.21"],"净化代码更加可维护和可扩展":["34.21"],"创建一个高阶组件":["34.21"],"component是es6语法":["34.22"],"用constructor构造器来构造默认的属性和状态":["34.22"],"proptype":["34.22"],"getdefaultprops":["34.22"],"组件在组件的状态":["34.23"],"commit阶段":["34.24"],"用于追踪哪些列表中元素被修改":["34.25"],"子组件":["34.26","44.26","44.52"],"让通用逻辑在组件间更好地被复用":["34.27"],"保持一致":["34.27"],"div1":["34.28"],"in属性置为true时":["34.29"],"csstransition首先会给其子组件加上xxx":["34.29"],"enter":["34.29"],"每个目录下包含同样的角色文件":["34.30"],"组件":["34.31"],"这种组件可以捕获发生在其子组件树任何位置的":["34.31"],"不会进一步的比较":["35.1"],"策略二":["35.1"],"组件diff":["35.1"],"dom节点组件的比较":["35.1"],"如果是同一个类的组件":["35.1"],"则会继续往下diff运算":["35.1"],"更新节点属性":["35.1"],"如果不是同一个类的组件":["35.1"],"那么直接删除这个组件的所有子节点":["35.1"],"表示新的ui结构":["35.2"],"比较新旧虚拟dom树的根节点":["35.2","44.50"],"js会比较新旧虚拟dom树的根节点":["35.2","44.50"],"判断它们是否相同类型的节点":["35.2","44.50"],"使用旧列表的头一个节点oldstartnode与新列表的最后一个节点newendnode对比":["35.3"],"使用旧列表的最后一个节点oldendnode与新列表的头一个节点newstartnode对比":["35.3"],"移动":["35.3"],"比较指向的新":["35.4"],"老节点是否相同":["35.4"],"如果相同指针":["35.4"],"直到两个节点不同时结束前置节点的处理":["35.4"],"后置节点的处理是定义了索引":["35.4"],"oldend":["35.4"],"指向旧的一组子节点的最后一个节点和索引":["35.4"],"newend":["35.4"],"索引":["35.5"],"首先是定义一个长度为剩余新的一组子节点的长度的数组source":["35.5"],"初始值都为":["35.5"],"代码最后都会":["35.6"],"组件之间难以":["36.1"],"复用状态逻辑":["36.1"],"hook":["36.2"],"依赖顺序来判断":["36.2"],"setstate":["36.3","38.7"],"initialstate":["36.3"],"通过钩子函数usestate":["36.3"],"函数的第二个参数的作用是什么":["36.4","38.1"],"会根据一个变量":["36.5","38.2"],"isbatchingupdates":["36.5","38.2"],"判断是直接更新":["36.5","38.2"],"由react控制的":["36.6","38.3"],"事件处理函数":["36.6","38.3"],"以及生命周期函数":["36.6","38.3"],"调用setstate时表现为异步":["36.6","38.3"],"修改":["36.7"],"它在":["36.7"],"组件渲染后":["36.7"],"执行":["36.7"],"并可以根据指定的依赖项进行条件触发":["36.7"],"对于":["36.7"],"处理逻辑是采用异步调用":["36.7"],"不同的地方是采用了同步执行":["36.8"],"是在":["36.8"],"obj2context":["36.9"],"app":["36.9","44.35","78.2","79.2","82.2"],"childcomp":["36.9"],"子级":["36.9"],"childchildcomp":["36.9"],"孙级或更多级":["36.9"],"如果这些函数作为":["36.10"],"prop":["36.10"],"传递给子组件":["36.10","36.11"],"可能会导致子组件的不必要重新渲染":["36.10"],"尤其在使用":["36.10"],"memo":["36.10"],"进行性能优化时更容易发生":["36.10"],"并且子组件使用了":["36.11"],"它可以在函数组件的渲染过程中缓存计算的值":["36.12"],"并在":["36.12"],"依赖项未发生变化时直接返回缓存的值":["36.12"],"都是在第一次渲染的时候执行一次":["36.13"],"高阶组件":["36.14"],"它会将":["36.14"],"子组件进行缓存":["36.14"],"以避免不必要的渲染":["36.14"],"它默认使用":["36.14"],"改变后":["36.15"],"才会重新渲染":["36.15"],"只会对新旧":["36.15"],"做浅比较":["36.15"],"所以对于引用类型的数据如果发生了更改":["36.15"],"需要返回一个新的地址":["36.15"],"并不是用的越多越好":["36.15"],"因为缓存本身也是需要开销的":["36.15"],"如果每一个组件都用":["36.15"],"current":["36.16","36.17","53.14","59.9","71.12","71.14","72.9"],"属性可以用来存储和访问任何值":["36.16"],"与":["36.16"],"usestate":["36.16"],"不同":["36.16"],"属性并不会引起组件的重新渲染":["36.16"],"访问":["36.16"],"元素上时":["36.17"],"将提供对该":["36.17"],"元素的引用":["36.17"],"你可以通过":["36.17"],"ref":["36.17","50.4"],"来访问":["36.17"],"元素的属性和方法":["36.17"],"访问组件实例":["36.17"],"可以配合":["36.18"],"能够让":["36.19"],"suspense":["36.20"],"的实现效果也类似于":["36.21"],"版本5":["37.0"],"页面的显示结果可以根据url的变化而变化":["37.1"],"dom的常用api":["37.2"],"通过修改":["37.3"],"url":["37.3","37.16","43.5"],"的路径来实现路由导航":["37.3"],"基于浏览器的":["37.3"],"pushstate":["37.3"],"popstate":["37.3"],"exact":["37.4"],"exact属性用来设置路由地址是否完整匹配":["37.4"],"它需要一个布尔值":["37.4"],"默认为false":["37.4"],"home":["37.4"],"布尔值":["37.4"],"当这个组件出现时":["37.5"],"后面的组件就不应该继续匹配":["37.6"],"useparams":["37.7"],"action":["37.8","41.4","41.5"],"当前历史记录的状态":["37.8"],"前进":["37.8"],"后退":["37.8"],"新记录创建":["37.8"],"索引发生变化":["37.8"],"push":["37.8","53.14","59.9","67.2","74.1","85.7"],"div":["37.9","44.26"],"学生id":["37.9"],"请求的路径":["37.10"],"查询字符串":["37.10"],"获取查询参数":["37.10"],"钩子来读取参数":["37.12"],"navlink":["37.12"],"abc123":["37.12"],"详情":["37.12"],"switch":["37.12","41.5"],"其他route":["37.12"],"route":["37.12","37.15","37.18","43.15"],"path":["37.12","37.15"],"6中的route组件不能单独使用":["37.13"],"当浏览器的地址发生变化时":["37.14"],"会自动对routes中的所有route进行匹配":["37.14"],"students":["37.15"],"matchpath":["37.16"],"将路由路径模式与":["37.16"],"路径名匹配":["37.16"],"这个用的最多":["37.17"],"设置需要渲染组件":["37.17"],"不过千万不要当成函数使用":["37.17"],"不然会消耗性能":["37.17"],"不断创建销毁组件":["37.17"],"行为只会触发相匹配的":["37.18"],"对应的页面内容更新":["37.18"],"通常路径的跳转是使用link组件":["37.19"],"最终会被渲染成a元素":["37.19"],"如果你需要基于当前的":["38.0"],"来计算出新的值":["38.0"],"那你应该传递一个函数":["38.0"],"而不是一个对象":["38.0"],"incrementcount":["38.0"],"不会":["38.0"],"像预期的那样工作":["38.0"],"它们都是用来保存信息的":["38.5"],"这些信息可以控制组件的渲染输出":["38.5"],"而它们的几个重要的不同点就是":["38.5"],"以供验证使用":["38.6"],"当我们向":["38.6"],"传入":["38.6"],"此函数可以通过调用this":["38.7"],"来更新组件状态":["38.7"],"并且不会引起第二次的渲染":["38.7"],"也可在此函数内根据需要调用自己的自定义函数":["38.7"],"来对prop的改变做出一些响应":["38.7"],"componentwillreceiveprops":["38.7"],"nextprops":["38.7"],"mycomponent":["38.8"],"进行数据拦截":["39.1"],"vue则是直接修改保存状态的那块原始内存":["39.2"],"vue用defineproperty和proxy对数据进行劫持":["39.2"],"模板语法":["39.3"],"双端比较":["39.4"],"数据不可变":["39.5"],"setstate没有修改原来那块内存中的变量":["40.1"],"而是去新开辟一块内存":["40.1"],"而vue则是直接修改保存状态的那块原始内存":["40.1"],"数据修改了":["40.1"],"新旧虚拟dom树对比":["40.2"],"设计的":["41.0"],"但可以在其他框架中使用":["41.0"],"它的核心概念包括单一的全局状态树":["41.0"],"纯函数来处理状态变化以及通过":["41.0"],"代表了应用程序的整体状态":["41.1","52.5"],"mutation":["41.1","52.5"],"变更":["41.1","52.5"],"是修改":["41.1","52.5"],"store":["41.2","41.7"],"容器":["41.3"],"container":["41.3"],"会传递给":["41.4"],"getstate":["41.4"],"usedispatch":["41.5"],"useselector":["41.5"],"redux":["41.5","41.8"],"createstore":["41.5","41.7"],"stureducer":["41.5"],"孙悟空":["41.5"],"gender":["41.5"],"男":["41.5"],"address":["41.5"],"花果山":["41.5"],"case":["41.5"],"通常情况下":["41.6"],"一个中间件就是一个函数":["41.6"],"且一个中间件最好只做一件事情":["41.6"],"dispatch":["41.6"],"触发":["41.6"],"reducer之前":["41.6"],"middlewares":["41.7"],"reducer":["41.7"],"preloadedstate":["41.7"],"enhancer":["41.7"],"thunkmiddleware":["41.8"],"is":["41.9","42.13","42.17"],"dispatched":["41.9"],"fun":["41.10"],"arr2":["42.1"],"y":["42.2"],"lastname":["42.3"],"add":["42.4","67.4"],"元组最重要的特性是可以限制数组元素的个数和类型":["42.5"],"它特别适合用来实现多值返回":["42.5"],"ts":["42.5","42.26","42.27","42.28","42.29","44.35"],"employee":["42.6"],"使得程序永远无法运行到函数返回值那一步":["42.8"],"永不存在返回":["42.8"],"异常":["42.8"],"err":["42.8"],"msg":["42.8"],"ok":["42.8","42.10"],"typescript":["42.9","42.12","42.15","42.19"],"uncertain":["42.10"],"any":["42.10","42.13","42.32"],"symbol等":["42.11"],"原始类型赋值给":["42.11"],"在严格模式下":["42.11"],"类型也不能赋给":["42.11"],"这种基于赋值表达式推断类型的能力称之为类型推断":["42.12"],"somevalue":["42.13"],"可以用于断言操作对象是非":["42.14"],"该属性会被明确地赋值":["42.15"],"为了更好地理解它的作用":["42.15"],"我们来看个具体的例子":["42.15"],"种字面量类型":["42.16"],"字符串字面量类型":["42.16"],"数字字面量类型":["42.16"],"布尔字面量类型":["42.16"],"str":["42.17","69.1","72.11","72.12","77.5"],"interfaces":["42.18"],"是一个很重要的概念":["42.18"],"只读属性用于限制只能在对象刚刚创建的时候修改其值":["42.19"],"此外":["42.19"],"interface":["42.20","42.25"],"printlabel":["42.21"],"labeledobj":["42.21"],"myobj":["42.21"],"鸭式辨型法":["42.22"],"的核心原则之一是对值所具有的结构进行类型检查":["42.24"],"而接口的作用就是为":["42.24"],"这些类型命名":["42.24"],"point":["42.25"],"联合类型":["42.26"],"元组":["42.26"],"primitive":["42.26"],"会被自动合并为单个接口":["42.27"],"来实现":["42.28"],"类型别名的扩展就是交叉类型":["42.28"],"接口扩展接口":["42.28"],"是一个抽象类型":["42.29"],"只有在调用的时候才确定它的值":["42.29"],"这就不用我们复制粘贴无数份代码了":["42.29"],"简单来说就是你定义一个类型":["42.30"],"然后让":["42.30"],"t":["42.30","88.1"],"类型的子类型":["42.32"],"然后使用":["42.32"],"操作符获取":["42.32"],"类型的所有键":["42.32"],"最后利用":["42.32"],"关键字约束":["42.32"],"类型必须为":["42.32"],"联合类型的子类型":["42.32"],"用来遍历枚举类型":["42.32"],"infer":["42.32"],"在条件类型语句中":["42.32"],"官方文档":["43.0"],"router是vue官方的路由管理器":["43.2"],"有hash和history两种模式":["43.2"],"hash模式是通过监听hashchange事件来实现更新页面部分内容的操作":["43.2"],"router中有个监听器":["43.3"],"用来监听history的变化":["43.3"],"相当于一个锚点":["43.4"],"后面的内容就是锚点值":["43.4"],"当监听锚点值的变化就会改变局部的页面数据":["43.4"],"模式":["43.5"],"模式改变":["43.5"],"router":["43.6"],"next三个参数":["43.7"],"路由跳转前都会触发":["43.7"],"登录验证时用的比较多":["43.7"],"当一个导航触发时":["43.7"],"全局前置守卫按照创建顺序调用":["43.7"],"守卫是异步解析执行":["43.7"],"此时导航在所有守卫":["43.7"],"完之前一直处于等待中":["43.7"],"beforeeach":["43.8"],"在渲染该组件的路由被确认前访问组件实例":["43.8"],"beforerouteenter":["43.8"],"在路由配置里调用":["43.8"],"beforeenter":["43.8"],"首屏组件加载速度更快一些":["43.9"],"懒加载实现的前提":["43.10"],"es6的动态加载模块":["43.10"],"使用vue的异步组件技术":["43.11"],"可以实现懒加载":["43.11"],"此时一个组件会生成一个js文件":["43.11"],"如过渡名称":["43.12"],"需要从服务器获取数据":["43.13"],"在渲染用户信息时":["43.13"],"可以在路由定义中使用冒号":["43.14"],"来定义动态的路由参数":["43.14"],"参数直接嵌入在路由路径中":["43.15"],"在路由组件中可以通过":["43.15"],"来获取传递的参数":["43.15"],"提供组件化开发":["44.1"],"spa":["44.2"],"描述":["44.3","52.0"],"beforecreate":["44.3","52.0"],"实例创建前":["44.3"],"用于在组件实例创建之前进行一些初始化操作":["44.4"],"事件监听":["44.5"],"定时器":["44.5"],"开启等":["44.5"],"beforemount":["44.5"],"onbeforemount":["44.5"],"阶段准备数据或执行一些初始化操作":["44.5"],"父created":["44.6"],"父beforemount":["44.6"],"子beforecreate":["44.6"],"会先执行完父组件的生命周期然后再执行子组件的生命周期":["44.7"],"show":["44.8"],"开发过程中一般不建议同时将v":["44.9"],"if放在一个标签中使用":["44.9"],"可以使用watch来对这个属性进行监听":["44.10"],"computed具有缓存的特点":["44.10"],"即当它所依赖的属性发生改变的时候它才会重新执行内部逻辑":["44.10"],"如下代码":["44.10"],"如果依赖项不变时不会重新计算":["44.11"],"依赖于其他响应式数据":["44.12"],"watch用来进行异步操作":["44.13"],"在计算属性中进行异步操作可能会导致":["44.13"],"简化在template模板中的复杂表达式":["44.14"],"模板中出现太多逻辑判断会造成模板不易维护":["44.14"],"的实现是基于":["44.15"],"另一种是":["44.16"],"computed":["44.17"],"属性时候":["44.17","44.18"],"遍历computed属性":["44.17"],"会循环所有计算属性":["44.18"],"每一个计算属性会创建一个":["44.18"],"watcher":["44.18","45.13"],"收集时机和":["44.19"],"那样接收一个明确的数据源":["44.20"],"watcheffect":["44.20"],"vue3的是composition":["44.21"],"当然vue3也兼容composition":["44.21","51.3"],"会解析模板":["44.22"],"识别其中的指令和数据绑定":["44.22"],"实例":["44.22"],"会根据解析后的模板创建一个":["44.22"],"该实例充当应用程序的根实例":["44.22"],"并管理整个应用程序的状态和行为":["44.22"],"数据响应式处理":["44.22"],"观察者模式":["44.23"],"来实现的":["44.23"],"vue3数组可以直接使用":["44.24"],"reactive和readonly":["44.24"],"vue实例会有一个use函数":["44.25"],"它接受的是一个带有install函数的对象和一个可选的选项对象":["44.25"],"父组件使用它时直接在子组件的标签内写入内容即可":["44.26"],"template":["44.26","80.7"],"slot":["44.26"],"父组件":["44.26"],"child":["44.26","44.57"],"attrs":["44.27"],"父传子孙":["44.27"],"provide":["44.27"],"父组件通过v":["44.28"],"func":["44.29"],"func是写在父组件中的函数":["44.29"],"子组件通过某种方式比如":["44.29"],"子组件的ref":["44.31"],"当在父组件中使用ref引用子组件时":["44.31"],"ref会被赋值为子组件实例":["44.31"],"父组件在自己的模板中使用该数据":["44.32"],"父接收一个参数slotprops":["44.32"],"它是一个包含了插槽数据的对象":["44.32"],"当我们的项目有很多个页面":["44.33"],"并且这些页面共享着多个数据状态":["44.33"],"此时我们可以引入vuex":["44.33"],"获取":["44.34"],"地址":["44.34"],"pinia解构方法":["44.34"],"storetorefs":["44.34"],"响应式解构":["44.34"],"后即可访问其内部的方法了":["44.35"],"export":["44.35"],"useappstore":["44.35"],"通常我们切换组件的时候":["44.37"],"上一个组件就会被销毁":["44.37"],"而当我们使用":["44.37"],"mounted":["44.38","46.3"],"使用了keep":["44.39"],"提供了一种非常灵活的方式":["44.40"],"来分发":["44.40"],"组件中的可复用功能":["44.40"],"区别":["44.41"],"中的另一个位置":["44.43"],"接收两个参数to":["44.43"],"组件用于协调对组件树中嵌套的异步依赖的处理":["44.44"],"更新循环结束之后执行延迟回调":["44.46"],"它的作用是在":["44.46"],"浏览器会从头开始进行dom树的构建":["44.48"],"频繁的操作dom开销是很大的":["44.48"],"在vue中是当状态发生改变":["44.49"],"用来计算改变后的虚拟dom与改变前的虚拟dom之间的差异的算法":["44.49"],"diff算法的本质是找出两个对象之间的差异":["44.49"],"目的是尽可能复用节点":["44.49"],"如果根节点相同":["44.50"],"进入下一步":["44.50"],"比较其子节点":["44.50"],"传给子组件":["44.51"],"子组件用":["44.51"],"defineprops":["44.51"],"isshow":["44.51"],"hide监听并接收参数":["44.52"],"可透传":["44.52"],"children":["44.52","51.7"],"组件的更新是异步执行":["44.53"],"这意味着当您修改组件的数据或状态时":["44.53"],"vue并不会立即对dom进行更新":["44.53"],"相反":["44.53"],"vue会将更新操作推入一个更新队列":["44.53"],"并缓冲在同一事件循环中发生的所有数据变更":["44.53"],"为了配合diff算法更加高效":["44.54"],"有两个插槽":["44.55"],"储存在value中":["44.56"],"header":["44.57","67.2"],"用户通过发出actions进行处理":["44.59"],"actions中通过setstate对state进行更新":["44.59"],"state更新后触发view更新":["44.59"],"可以看出":["44.59"],"数据流指的是组件之间的数据流动":["44.60"],"vue与react都是单向数据流的模型":["44.60"],"虽然vue有双向绑定v":["44.60"],"资源文件体积是否过大":["44.61"],"动态路由":["44.62"],"静态资源本地缓存":["44.62"],"就近原则":["44.63"],"紧耦合的文件应该放到一起":["44.63"],"且应以相对路径引用":["44.63"],"所有依赖它的对象都会收到通知":["45.2"],"这就是观察者模式":["45.2"],"subscriber":["45.3"],"通过自定义事件订阅主题":["45.3"],"被激活事件的对象":["45.3"],"publisher":["45.3"],"definereactive":["45.4","45.9","45.15"],"typeof":["45.4","59.6","59.8"],"为对象的每个属性重新设置":["45.4"],"getter":["45.4"],"setter":["45.4"],"每个属性都有单独的":["45.4"],"dep":["45.4","45.5","45.8","45.15"],"依赖管理":["45.4","45.5"],"依赖":["45.5"],"响应式":["45.6","45.7"],"会变成":["45.7"],"化":["45.7"],"也就是改变这个对象的时候会触发get和set事件":["45.7"],"进而触发一些视图更新":["45.7"],"prototype叫arraymothods":["45.10"],"observe中在数据被读的时候":["45.11"],"触发getter方法":["45.11"],"执行dep来收集watcher":["45.11"],"数据称为wacther的依赖":["45.12"],"数据变化时":["45.12"],"开发者主动注册的watch回调函数执行":["45.13"],"常见三个场景":["45.13"],"对应三种watcher":["45.13"],"负责敦促视图更新的render":["45.13"],"执行敦促计算属性更新的computed":["45.13"],"用户注册的普通watcher":["45.13"],"watch":["45.13"],"api或watch属性":["45.13"],"watcher就是类似中介的角色":["45.13"],"数组里存放所有订阅了该属性的观察者对象watcher":["45.14"],"我们通过definereactive方法将data中的数据进行响应式后":["45.14"],"dep就是帮我们收集watcher究竟要通知到哪里":["45.14"],"依赖收集":["45.14"],"data的属性变化":["45.14"],"依赖集合":["45.15"],"defineporperty":["45.16"],"只能对":["45.16"],"对象的已知属性":["45.16"],"进行操作":["45.16"],"receiver":["45.17","45.33"],"reactive":["45.18"],"返回一个":["45.18"],"proxy":["45.18","45.24"],"代理对象":["45.18"],"并劫持对象的":["45.18"],"副作用函数":["45.20"],"targetmap":["45.21","45.28"],"weakmap":["45.21","45.28"],"activeeffect":["45.21"],"从而调用":["45.22"],"无法保证输出相同":["45.23"],"就会带来副作用":["45.23"],"中体现最为明显的一点就是":["45.24"],"代理对象之后不仅可以拦截对象属性的读取":["45.24"],"整个定义":["45.25"],"类似深拷贝与浅拷贝的区别":["45.25"],"即只处理首层数据":["45.25"],"代表假设使用":["45.25"],"shadowref":["45.25"],"声明的对象":["45.25"],"如果对象的某个属性也是对象":["45.25"],"则":["45.25"],"只有当这个属性的引用地址发生改变时才会触发更新":["45.25"],"属性的对象":["45.26"],"所以我们访问时必须通过":["45.26"],"的形式访问":["45.26"],"函数内部执行时会创建一个":["45.26"],"effect副作用函数":["45.27"],"实现依赖变量的更新":["45.28"],"用map用来存储dep":["45.30"],"handler":["45.32","71.7","71.8","71.9"],"个人理解就是":["45.33"],"访问target的key属性":["45.33"],"但是this是指向receiver":["45.33"],"proxy和reflect的方法都是一一对应的":["45.34"],"官方提供了v":["46.0"],"允许开发者自定义指令":["46.1"],"一个是指令名称":["46.2"],"一个是钩子函数对象":["46.2"],"指令名称":["46.2"],"短横线":["46.2"],"my":["46.2"],"focus":["46.2"],"驼峰式":["46.2"],"myfocus":["46.2"],"在绑定元素的父组件及他自己的所有子节点都挂载完成后调用":["46.3"],"绑定元素的父组件更新前调用":["46.3"],"beforeupdate":["46.3"],"在绑定元素的父组件及他自己的所有子节点都更新后调用":["46.3"],"updated":["46.3"],"绑定元素的父组件卸载前调用":["46.3"],"beforeunmount":["46.3"],"它会始终应用于组件的根节点":["46.4"],"和透传":["46.4"],"全局挂载":["46.6"],"createapp":["46.6"],"addeventlistener":["47.0","63.0"],"row":["50.1"],"inputvalue":["50.1"],"用来":["50.1"],"title":["50.2"],"检查级别":["50.2"],"minwidth":["50.2"],"slots":["50.2"],"解决":["50.3"],"vxe":["50.3"],"grid有一个":["50.3"],"函数用于拿到选取行的信息":["50.3"],"循环遍历如果里面inputvalue为空或者undefined就弹出弹框":["50.3"],"operflag":["50.4"],"gettablelist":["50.4"],"这包括但不限于按钮":["51.0"],"表单输入":["51.0"],"模态框":["51.0"],"导航栏":["51.0"],"表格":["51.0"],"回滚":["51.2"],"options":["51.3"],"api中methods":["51.3"],"compute":["51.3"],"data等api都是分散的":["51.3"],"wabpack区别":["51.4"],"es":["51.5"],"webpack":["51.5"],"需要使用自己的模块系统和构建过程":["51.5"],"tree":["51.7"],"step":["51.7"],"构建节点的id到节点对象的映射":["51.7"],"方便后续查找":["51.7"],"一般在created":["52.1"],"在自己的组件中可以访问":["52.2"],"interceptors":["52.3"],"response":["52.3"],"use":["52.3"],"子传父":["52.4"],"emit":["52.4"],"emits":["52.4"],"状态":["52.6"],"你可以监视一个或多个属性":["52.7"],"boolen":["53.1"],"栈堆那个访问快":["53.2"],"const都是有块作用域的":["53.2"],"settimeout函数会尽可能快地将任务放入任务队列中":["53.3"],"为了避免耗时任务阻塞队列":["53.4"],"有了同步任务和异步任务":["53.4"],"面向链接":["53.5"],"可以修改吗":["53.7"],"常用的静态方法":["53.8"],"盗取存储在客户端的cookie或者有用户敏感信息":["53.9"],"打印当前元素的tagname":["53.13"],"permutearray":["53.14","59.9"],"nums":["53.14","59.9","59.10"],"result":["53.14","59.9","76.5","76.6","77.5"],"backtrack":["53.14","59.9"],"remaining":["53.14","59.9"],"slice":["53.14","59.9"],"i":["53.14","59.4","59.7","59.9","66.1","74.2","76.5","85.13"],"canvas是基于位图的绘图技术":["53.16"],"图形缩放可能会导致图像模糊":["53.16"],"expires":["53.19"],"指定一个绝对过期时间":["53.19"],"指定一个相对过期时间或最大缓存时间":["53.19"],"将部分进程的数据和代码存储在磁盘上":["53.20"],"浏览器存储":["53.22"],"不和服务端进行交互":["53.22"],"chrome内核把浏览器多标签设计的进程还是线程":["53.23"],"为什么这么设计":["53.23"],"进程是运行的程序":["53.23"],"裁剪时间戳":["53.25"],"判断是否缓存":["53.26"],"如果name不在inlcude中或者存在于exlude中则表示不缓存":["53.26"],"直接返回vnode":["53.26"],"前端怎么处理精度丢失的问题":["53.27"],"5px的线":["53.28"],"bus":["53.29"],"代表拍平三层":["53.30"],"解析url":["53.34"],"通过http":["53.35"],"让浏览器在一定时间内直接使用本地缓存而不想服务器发送请求":["53.35"],"设置expires设置一个绝对过期时间和cache":["53.35"],"长链接":["53.36"],"运行环境相同":["53.37"],"除了暴力写三种做法":["53.38"],"code":["55.0"],"live":["55.1"],"以管理员身份打开vscode终端":["55.2"],"install":["55.4","81.0"],"item":["56.0"],"self":["56.0"],"indexof":["56.0"],"而computed用于根据数据的变化动态计算衍生出的属性值":["56.2"],"触发时机不同":["56.2"],"watch是在数据变化时立即执行相应的操作":["56.2"],"可以执行相应的操作":["56.3"],"如发送网络请求":["56.3"],"更新其他数据":["56.3"],"触发其他函数等":["56.3"],"这对于需要在数据变化时执行一些异步或复杂的操作非常有用":["56.3"],"flex弹性布局":["56.6"],"通过在父设置display":["56.6"],"bottom":["56.10"],"属性无效":["56.10"],"的单向数据流是指数据在":["56.11"],"导致程序停滞":["56.12"],"通过使用异步操作":["56.12"],"可以在等待这些操作完成的同时":["56.12"],"是一种用于处理异步操作的对象":["56.13"],"它被广泛用于处理网络请求":["56.13"],"文件读写":["56.13"],"数据库操作等需要等待一段时间才能获取结果的任务":["56.13"],"会阻塞主线程的执行":["56.14"],"直到任务完成":["56.14"],"负责协调同步任务和异步任务和任务队列之间的关系的机制":["56.15"],"debounce":["59.1"],"delay":["59.1","59.2"],"throottle":["59.2"],"copy":["59.4"],"isarray":["59.4"],"context":["59.8"],"判断调用对象是否为函数":["59.8"],"queuemicrotask":["60.0"],"promises":["61.1"],"track":["62.0"],"depsmap":["62.0"],"createperson":["65.3"],"person2":["65.6"],"交换位置":["66.2"],"selectsort":["66.2"],"insertsort":["66.3"],"进行一次直接插入排序":["66.4"],"排序完成":["66.4"],"shellsort":["66.4"],"gap":["66.4"],"pivotindex":["66.5"],"math":["66.5"],"floor":["66.5"],"head接在temp的后面":["67.1"],"head向后移动一位":["67.1"],"while":["67.2","67.4","67.6","72.11","72.12"],"listnode":["67.3"],"temp":["67.4"],"hascycle":["67.5"],"slow":["67.5"],"fast":["67.5"],"hashfunc":["69.2","69.3"],"limit":["69.2","69.4"],"bucket":["69.2","69.4"],"storage":["69.2","69.4"],"prototype":["69.5","69.6","71.12","72.3","72.10"],"isprime":["69.5"],"num":["69.5"],"hashtable":["69.6"],"peek":["70.0"],"stack":["70.1"],"binary":["71.1"],"二叉搜索树的特点就是相对较小的值总是保存在左结点上":["71.2"],"在树中查找一个键":["71.3"],"该类包含三个属性":["71.4"],"结点对应的key":["71.4"],"指向的左子树":["71.4"],"newnode":["71.5","72.2","72.4"],"root":["71.5","71.9","71.10","71.11"],"preordertraversalnode":["71.7"],"inordertraversal":["71.8"],"inordertraversalnode":["71.8"],"postordertraversalnode":["71.9"],"searchnode":["71.11"],"该节点有两个子节点":["71.12"],"情况比较复杂":["71.12"],"查找删除的节点current":["71.12"],"binaryserachtree":["71.12","71.15"],"remove":["71.12"],"就是是否current就是根":["71.13"],"都为null":["71.13"],"并且为跟根":["71.13"],"那么相当于要清空二叉树":["71.13"],"当然":["71.13"],"如果有两个子结点":["71.14"],"就是三个连接了":["71.14"],"一个连接父节点":["71.14"],"一个连接唯一的子节点":["71.14"],"需要从这三者之间":["71.14"],"爷爷":["71.14"],"自己":["71.14"],"儿子":["71.14"],"将自己":["71.14"],"称为current节点的前驱":["71.15"],"比current大一点点的节点":["71.15"],"一定是current右子树的最小值":["71.15"],"称为current节点的后继":["71.15"],"也就是为了能够删除有两个子节点的current":["71.15"],"要么找到它的前驱":["71.15"],"要么找到它的后继":["71.15"],"删除的树":["71.15"],"寻找后继的代码实现":["71.15"],"寻找后继":["71.15"],"delnode要删除的节点":["71.15"],"successor后继节点":["71.15"],"successorparent后继节点的父节点":["71.15"],"操作删除的节点的父节点parent":["71.16"],"情况1":["71.16"],"叶子结点":["71.16"],"linkedlist":["72.1","72.10"],"position":["72.5","72.7","72.11","72.12","79.8"],"previous":["72.9"],"新节点就加入到了最后":["72.11","72.12"],"tostring":["72.11","72.12","73.1","73.2","85.3"],"insert":["72.11","72.12"],"情况一":["72.11"],"把插入的data放在首位":["72.11"],"next为空":["72.12"],"最后把新节点赋值给current":["72.12"],"isempty":["73.1","73.2"],"class类js构造函数继承":["73.2"],"enqueue":["74.1"],"返回true或false":["75.1","75.2"],"不改变原数组":["75.3","75.4","75.9","75.14"],"反方向查找":["75.4"],"找到符合条件的第一个数":["75.4"],"符合条件":["75.5"],"的第一个数的索引":["75.5"],"里面为回调函数":["75.5"],"某个元素":["75.6"],"的第一个索引":["75.6"],"方法返回指定元素在数组中的最后一个的索引":["75.7"],"判断是否包含某个元素":["75.8"],"将数组中的每个元素映射到另一个数组中":["75.9"],"产生一个新的数组":["75.9"],"不产生数组":["75.10"],"对原数组也没影响":["75.10"],"方法创建一个新的数组":["75.11"],"并根据指定深度递归地将所有子数组元素拼接到新的数组中":["75.11"],"它等价于在调用":["75.12"],"方法后再调用深度为":["75.12"],"flat":["75.12","76.1","76.6"],"到终止索引":["75.13"],"内的全部元素":["75.13"],"返回一个过滤后的新数组":["75.14"],"arrfrom":["75.15"],"构造函数之间的区别在于对单个参数的处理":["75.16"],"result18":["75.17"],"返回删除后的元素":["75.18"],"改变原数组":["75.18","75.19","75.20","75.21"],"并返回该数组的新长度":["75.19","75.21"],"该对象包含数组每个索引的值":["75.23"],"类似generater函数":["75.24"],"accumulator":["75.26"],"和数组的每个值":["75.26"],"从右到左":["75.26"],"将其减少为单个值":["75.26"],"并返回该数组":["75.27"],"数组的第一个元素会变成最后一个":["75.27"],"数组的最后一个元素变成第一个":["75.27"],"该方法会改变原数组":["75.27"],"这一对象是一个由":["75.28"],"end":["75.28"],"决定的原数组的浅拷贝":["75.28"],"默认排序顺序是在将元素转换为字符串":["75.29"],"然后比较它们的":["75.29"],"utf":["75.29"],"代码单元值序列时构建的":["75.29"],"方法通过删除或替换现有元素或者原地添加新的元素来修改数组":["75.30"],"并以数组形式返回被修改的内容":["75.30"],"此方法会改变原数组":["75.30"],"数组中的元素将使用各自的":["75.31"],"方法转成字符串":["75.31"],"这些字符串将使用一个特定语言环境的字符串":["75.31"],"表示指定的数组及其元素":["75.32"],"arr3":["76.0"],"flatten":["76.2"],"递归":["76.3"],"deep":["76.7"],"result1":["77.1"],"result2":["77.2"],"result3":["77.3"],"wolder":["77.5"],"button":["78.1","78.3","78.4"],"flowing":["78.4"],"el":["79.0"],"danger":["79.1"],"l":["79.1"],"默认":["79.1"],"朴素按钮":["79.1"],"lbutton":["79.3"],"primary":["79.4"],"变为朴素按钮":["79.5"],"变为圆角按钮":["79.6"],"变为不可选中状态":["79.7"],"就可以在按钮上添加":["79.8"],"想放在右侧只需要添加":["79.8"],"placeholder":["80.1","80.3","80.6","80.7"],"linput":["80.2"],"请输入内容":["80.3","80.6","80.7"],"br":["80.3"],"medium":["80.4"],"tel":["80.5","80.6","80.7"],"clearable":["80.6"],"prefixicon":["80.6"],"bianji":["80.6"],"prepend":["80.7"],"maxrows":["80.8"],"最小行数为2":["80.8"],"最大行数为5":["80.8"],"arrow":["82.1"],"up":["82.1"],"down":["82.1"],"artboard":["82.1"],"attachment":["82.1","82.8"],"licon":["82.3"],"让我们图标右上角展示一个小红点":["82.4"],"设置badge属性后":["82.4"],"line":["82.7"],"shaixuan":["82.9"],"shandian":["82.10"],"shengyinguanbi":["82.11"],"jinru":["82.12"],"dianhua":["82.13"],"shanchu":["82.14"],"bofangjilu":["82.15"],"pinglun":["82.15"],"saoyisao":["82.16"],"llink":["83.1","83.2"],"href":["83.1","83.2"],"accept":["84.1","84.2"],"getfileslist":["84.1","84.2"],"lupload":["84.2"],"multiple":["84.2"],"table可设置宽高":["85.2"],"margin":["85.2"],"padding等属性":["85.2"],"属性值的单位可以使用px":["85.2"],"百分比值":["85.2"],"table的宽度默认由内容的宽高撑开":["85.2"],"如果table设置了宽度":["85.2"],"宽度默认被它里面的td平均分":["85.2"],"如果给某一个td设置宽度":["85.2"],"请求中的方法不允许使用":["85.6"],"情况二symbol是唯一的b和c不一样":["85.11"],"情况三":["85.11"],"tostirng":["85.12"],"得到的结果都是":["85.12"],"则浏览器不会自己计算成具体数字值":["85.14"],"而是不发生过渡效果":["85.14"],"定义了一个定位元素的上外边距与其包含块的上内边距":["85.16"],"display":["85.18"],"直接返回":["86.1"],"sum":["86.1"],"n":["88.1"],"pages在这里记录我的学习blog":["90.0"],"这里有什么":["90.0"],"面试题":["91.0"],"之旅":["91.0"]},{"0":["1.16","2.2","2.10","6.15","16.9","16.22","16.30","17.12","17.13","26.5","38.0","59.4","61.0","67.1","67.2","69.1","69.4","70.0","70.1","72.5","72.7","72.9","72.10","76.5","76.7","85.9"],"1":["6.11","6.18","11.6","11.26","14.13","16.15","19.12","19.30","19.63","20.22","20.26","21.9","21.10","22.4","41.0","42.6","42.17","43.13","45.7","46.2","50.2","51.4","56.13","66.3","66.5","67.1","75.1","75.2","75.3","75.10","75.11","75.18","75.19","75.21","75.26","75.27","75.29","75.30","75.32","76.0","77.0","85.1"],"2":["0.4","1.30","2.7","3.3","3.9","5.3","6.9","6.10","7.2","7.5","9.18","9.27","9.34","10.1","11.7","11.8","11.16","15.7","16.31","16.35","16.40","16.45","17.10","19.1","19.8","19.24","19.27","19.38","19.39","19.42","19.50","19.72","20.26","21.3","22.4","22.5","23.2","27.0","28.16","32.0","34.14","35.5","36.1","41.9","42.22","43.2","43.7","43.14","44.9","44.14","44.17","44.31","44.37","44.38","44.41","44.59","45.18","45.25","46.3","51.0","51.1","51.3","51.5","56.12","60.0","66.4","66.5","67.1","71.2","75.1","75.2","75.3","75.10","75.18","75.19","75.21","75.26","75.29","75.30","75.32","76.0","82.1"],"3":["2.7","3.5","5.7","5.8","6.19","7.5","10.2","14.3","16.14","19.43","19.76","21.2","22.4","22.5","23.3","26.1","28.2","30.8","34.14","34.22","41.1","43.7","44.1","44.14","44.24","44.34","44.44","44.50","45.11","52.5","53.34","55.1","56.10","71.4","75.1","75.2","75.3","75.29","75.32","85.2","85.13"],"4":["16.5","16.49","19.76","22.6","24.3","28.2","44.24","52.6","75.1","75.2","75.3","76.4"],"5":["4.0","8.2","11.14","14.6","24.3","25.1","28.2","42.32","76.4","77.4"],"6":["8.2","25.1","43.8","77.4"],"7":["11.26","43.8","75.16","86.1"],"10":["42.21"],"18":["37.10"],"20":["14.2","16.15"],"23":["19.28"],"25":["20.22"],"42":["20.16","20.20"],"50":["14.13"],"60":["17.18"],"100":["16.3","16.4","16.23"],"110":["6.5"],"123":["85.11"],"302":["9.23","85.6"],"303":["9.23"],"304":["9.23"],"825":["16.16"],"1000":["16.17"],"1355":["16.16"],"1970":["30.4"],"2000":["85.1"],"2017":["16.50"],"2055":["16.16"],"3000":["53.35"],"3600":["53.19"],"10000":["16.43"],"123456":["14.4"],"异步的":["0.1"],"j":["0.1","59.7","66.1","67.2"],"parse":["0.2","0.3","59.5"],"responsetext":["0.2"],"console":["0.2","0.6","19.34","19.47","19.73","21.6","21.10","24.2","37.12","42.32","44.35","47.0","63.0","75.17","75.22","75.23"],"log":["0.2","0.6","19.34","19.47","19.73","20.4","21.9","21.10","24.2","37.12","42.32","44.35","47.0","63.0","75.17"],"response":["0.2"],"data":["0.2","0.6","16.32","44.22","45.5","45.9","45.13","45.16","72.1"],"fetch":["0.2"],"fetch采用promise实现":["0.2"],"json":["0.3"],"post":["0.4","9.16"],"区别":["0.4"],"协议不同":["0.5"],"http和https":["0.5"],"www":["0.5"],"注意":["0.6","2.10","16.32","19.4"],"jsonp返回的数据是json对象可以直接使用":["0.6"],"ajax":["0.6"],"取得数据是json字符串需要转换成json对象才可以使用":["0.6"],"cors":["0.6"],"跨域资源共享":["0.6"],"服务器设置access":["0.6"],"control":["0.6"],"allow":["0.6"],"origin响应头之后":["0.6"],"浏览器将会允许跨域请求":["0.6"],"需要后台设置":["0.6"],"access":["0.6"],"origin":["0.6"],"允许所有域名访问":["0.6"],"或者":["0.6"],"source":["0.7","20.3"],"修改参数的格式或加密参数等":["0.8"],"这样可以在发送请求之前对参数进行统一处理":["0.8"],"全局loading状态管理":["0.8"],"你可以在请求拦截器中显示全局loading状态":["0.8"],"以提供用户反馈":["0.8"],"然后在请求完成之后隐藏loading状态":["0.8"],"可以使用户了解请求的状态":["0.8"],"请求错误处理":["0.8"],"你可以在请求拦截器中检查请求的错误":["0.8"],"并根据需要执行相应的错误处理操作":["0.8"],"如果请求需要登录权限但用户未登录":["0.8"],"你可以在请求拦截器中重定向到登录页面或执行其他操作":["0.8"],"js":["0.8","0.10","1.18","3.2","3.8","5.8","6.20","19.47","19.71","20.6","20.8","20.12","20.15","20.19","20.22","20.30","20.31","22.1","23.2","32.3","32.5","33.0","34.30","36.7","36.10","36.16","43.11","44.10","44.52","45.13","45.22","45.27","46.2","50.1","53.11","53.17","71.13","71.14","75.4","75.5","75.8","75.9","75.13","75.14","75.20","75.27","75.28","75.31","79.8","80.7","80.8"],"import":["0.8","29.5","34.4","36.16","43.10","44.35","46.2"],"axios":["0.8"],"from":["0.8","16.16","29.4","36.16","46.6","59.10","78.3","82.3"],"设置请求拦截器":["0.8"],"在请求发送之前设置请求头的token":["0.8"],"来实现一些具体的业务":["0.9"],"必须携带一些参数才可以请求":["0.9"],"例如":["0.9","1.10","6.20","19.71","27.0","28.9","28.12","34.5","82.4"],"会员业务":["0.9"],"方式一":["0.10"],"const":["0.10","19.28","20.6","20.8","20.12","20.19","20.25","29.4","36.16","44.52","45.4","45.7","50.2","53.13"],"son":["1.1"],"绝对定位配合margin":["1.1"],"auto":["1.1"],"的实现方案":["1.1"],"position":["1.1"],"使用伪元素清除浮动":["1.2"],"css":["1.2","1.10","2.0","5.10","8.2","32.5","34.28"],"clearfix":["1.2"],"after":["1.2","15.4","41.9"],"是一块独立的渲染区域":["1.3"],"内部元素不会影响外部的元素":["1.3"],"如何触发":["1.3"],"根元素":["1.3"],"hidden":["1.5","2.2","2.10"],"结构保留":["1.5"],"占据空间":["1.5","1.7"],"仅触发重绘":["1.5"],"不会触发事件":["1.5"],"无法选中":["1.5"],"设置":["1.6"],"absolute":["1.6","56.10"],"或":["1.6","5.12","9.23","19.5","36.10","44.22"],"90deg":["1.7"],"通过2d变换来达到隐藏":["1.7"],"的区别":["1.8","1.21"],"px全称pixel像素":["1.8"],"是相对于屏幕分辨率而言的":["1.8"],"css3":["1.9"],"新单位":["1.9"],"即":["1.9","19.75","34.17"],"view":["1.9"],"一般为16px":["1.10"],"然后在css中使用rem作为单位来定义元素的尺寸":["1.10"],"flex即可":["1.11"],"容器有以下属性":["1.11"],"direction":["1.11"],"wrap":["1.11"],"flex在浏览器中查看分别是":["1.12"],"flex":["1.12","1.21","85.18"],"对应的是1":["1.13","1.14"],"对应的是0":["1.15","1.16"],"布局一次只能处理一个维度上的元素布局":["1.17"],"一行或者一列":["1.17"],"布局是将容器划分成了":["1.17"],"行":["1.17"],"实现多行文本溢出省略效果":["1.18"],"property":["1.19"],"对合成属性进行":["1.19"],"transition":["1.19"],"animation":["1.19"],"动画将会创建一个合成层":["1.19"],"设置了":["1.20"],"值后":["1.20"],"在屏幕范围":["1.20"],"viewport":["1.20"],"around":["1.21","1.26"],"这个是":["1.21"],"duration":["1.22"],"指定过渡所需的完成时间":["1.22"],"timing":["1.22","1.27"],"function":["1.22","1.27","3.7","19.45","20.15","20.31","36.16","45.9","45.22","45.28","56.0","60.0","69.6","71.15","85.13"],"指定过渡函数":["1.22"],"区域内的部分显示":["1.23"],"区域外的隐藏":["1.23"],"外边距和内边距等盒模型属性":["1.24"],"可以容纳其他块级元素或行内元素":["1.24"],"right":["1.25","71.15","79.8"],"main":["1.25","11.17","11.18"],"justify":["1.25"],"between":["1.26","14.13"],"对齐弹性盒的":["1.26"],"em相对于父元素":["1.28"],"类选择器":["1.29","56.16"],"link":["1.30"],"pseudo":["1.30"],"classes":["1.30"],"选择尚未访问过的链接":["1.30"],"visited":["1.30"],"选择已访问过的链接":["1.30"],"用户行为伪类选择器":["1.30"],"user":["1.30","14.11"],"修饰文本或创建特殊效果":["1.31"],"before":["1.31"],"设置字体的尺寸":["1.32"],"style":["1.32","5.21"],"定义字体的风格":["1.32"],"variant":["1.32"],"vw":["1.33","2.1"],"而如果外部引用css代码":["1.34"],"在解析html结构过程中遇到外部css文件":["1.34"],"文件中的媒体查询":["1.35"],"根据设备的属性和特征":["1.35"],"的":["2.1","36.7","38.5"],"单位":["2.1"],"both":["2.2"],"height":["2.2"],"overflow":["2.2","2.10"],"外边距":["2.3"],"margin":["2.3"],"css盒模型中":["2.3"],"元素的大小由这四个部分的大小和相互之间的关系决定":["2.3"],"和ie盒模型":["2.4"],"主要区别是二者的盒子宽高是否包括元素的边框和内边距":["2.4"],"其取值为content":["2.5"],"box和border":["2.5"],"更新dom节点":["2.6"],"通过display":["2.6"],"none隐藏一个dom节点":["2.6"],"将多个图标文件整合到一张图片中":["2.7"],"雪碧图":["2.7"],"image":["2.8","14.4"],"背景":["2.8"],"background":["2.8"],"size":["2.8","42.21","70.0"],"我们可以根据屏幕宽度":["2.9"],"高度等条件来动态地调整网页的布局和样式":["2.9"],"以便适应不同尺寸的设备和不同的显示环境":["2.9"],"再利用相对定位":["2.10"],"定位到两边":["2.10"],"圣杯布局中间列的宽度不能小于两边任意列的宽度":["2.10"],"而双飞翼布局则不存在这个问题":["2.10"],"html":["2.10","6.4","10.6","19.64"],"class":["2.10","11.17","11.19","11.23","16.27","16.28","16.45","16.47","16.49","34.21","45.13"],"container":["2.10","34.20"],"中间":["2.10"],"左边":["2.10"],"右边":["2.10"],"padding":["2.10"],"es6":["3.1","29.2","44.22"],"文件都是一个独立的模块":["3.2"],"只允许使用唯一的一次export":["3.4"],"按需导入的成员名称必须和按需导出的名称保持一致":["3.5"],"var会提升变量的声明到作用域的顶部":["3.6"],"但let和const不会":["3.6"],"类型":["3.7","42.19"],"global":["3.7","23.2"],"window":["3.7","19.25"],"然后对其中的变量进行赋值":["3.8"],"普通函数存在着变量的提升":["3.9"],"箭头函数没有":["3.9"],"symbol":["3.10","85.10"],"class关键字是es5构造函数":["3.11"],"原型模式创建对象的语法糖":["3.11"],"根据功能封装模块":["3.12"],"通过import导入":["3.12"],"然后通过export导出":["3.12"],"promise":["3.13"],"惰性计算":["3.14"],"lazy":["3.14"],"evaluation":["3.14","20.22"],"属性简写":["3.15"],"属性名表达式":["3.15"],"obj":["3.15","22.9","45.7","65.2","85.4"],"a":["3.15","9.19","11.18","11.21","20.3","20.25","42.13","75.24","82.13","85.4"],"super":["3.15","73.2"],"mysymbol":["4.0"],"hello":["4.0","19.73","27.0"],"第二种写法":["4.0"],"第三种写法":["4.0"],"object":["4.0","19.34","42.21","42.26","44.22","44.23","45.8","59.6","65.4","85.12"],"defineproperty":["4.0","44.18","44.22","44.23","45.4"],"value":["4.0","5.21","11.25","16.36","16.41","16.42","19.74","22.1","22.7","45.17","46.3"],"以上的都可以得到":["4.0"],"symbol属性的遍历":["4.0"],"它可以被专门的object":["4.0"],"为渲染引擎能够理解的内部结构":["5.1"],"这个结构就是":["5.1"],"并同时将读取的数据":["5.2"],"喂":["5.2"],"给":["5.2","19.23"],"你可以把这个管道想象成一个":["5.2"],"水管":["5.2"],"网络进程接收到的字节流像水一样倒进这个":["5.2"],"而":["5.2","36.5","38.2","38.5","75.16"],"的另外一端是渲染进程的":["5.2"],"它会动态接收字节流":["5.2"],"并将其解析为":["5.2"],"阻塞后面js语句的执行":["5.3"],"的解析":["5.4"],"执行":["5.4"],"代码":["5.4"],"通过":["5.5","45.4"],"触发":["5.6"],"加载外部脚本和样式表文件":["5.7","19.50"],"下载完成":["5.8"],"浏览器会开始解析css文件":["5.8"],"dom加载到script标签":["5.8"],"js文件不会与dom并行加载":["5.8"],"因此需要等待js整个文件加载完之后":["5.8"],"树是一个渐进过程":["5.9"],"为达到更好的用户体验":["5.9"],"树和":["5.10"],"的解析是从右往左逆向解析的":["5.11"],"jq":["5.12"],"不会立即操作":["5.13"],"而是将这":["5.13"],"次更新的":["5.13"],"diff":["5.13","44.49"],"对象模拟":["5.14"],"dom":["5.14","34.5","34.6"],"树":["5.14"],"createelement":["5.16","6.7","35.6","47.0","63.0"],"方法创建":["5.16"],"表示文档中的一个节点":["5.17"],"可以是元素节点":["5.17"],"文本节点":["5.17"],"注释节点等":["5.17"],"提供了节点的基本方法和属性":["5.17"],"queryselectorall":["5.18"],"选择器选择匹配的所有元素节点":["5.18"],"返回文档的头部元素节点":["5.19"],"setattribute":["5.20"],"textcontent":["5.21"],"获取或设置元素的纯文本内容":["5.21"],"用于表单元素":["5.21"],"获取或设置输入框":["5.21"],"文本区域等的值":["5.21"],"返回一个cssstyledeclaration对象":["5.21"],"用于访问和修改元素的样式属性":["5.21"],"dataset":["5.21"],"createattribute":["5.22"],"创建属性节点":["5.22"],"提供了许多常用的方法和属性":["5.23"],"defaultvalue":["5.24"],"文本输入框":["5.24"],"并返回用户输入的值":["5.24"],"settimeout":["5.24","21.9","85.13"],"url":["5.25"],"地址信息":["5.25"],"navigator":["5.25"],"中处理事件的基本对象":["5.26"],"currenttarget":["5.27"],"当前正在处理事件的元素":["5.27"],"eventphase":["5.27"],"事件的当前阶段":["5.27"],"阻止事件进一步冒泡或捕获":["5.28"],"stopimmediatepropagation":["5.28"],"doctype是html5的文档声明":["6.1"],"通过它可以告诉浏览器":["6.1"],"使用哪一个html版本标准解析文档":["6.1"],"i":["6.2","16.22","17.19","20.4","66.3","67.2","69.1","69.4"],"em":["6.2"],"h3":["6.3"],"h4":["6.3"],"h5":["6.3"],"h6":["6.3"],"dl":["6.3"],"dt":["6.3"],"dd":["6.3"],"常见的行级元素":["6.3"],"最常用label的地方就是表单中的性别单选框了":["6.4"],"当点击文字时也能够自动聚焦绑定的表单控件":["6.4"],"form":["6.4"],"label":["6.4"],"href":["6.5"],"tel":["6.5","80.4"],"在seo中":["6.6"],"tdk其实就是title":["6.6"],"tagname":["6.7","53.13"],"footer":["6.8"],"header":["6.8","28.10"],"nav等":["6.8"],"视频video":["6.8"],"音频audio":["6.8"],"画布canvas":["6.8"],"html转换为dom":["6.9"],"css转换为cssom":["6.9"],"忽略不可见的元素":["6.10"],"计算渲染树中的元素":["6.11"],"重排一定重绘":["6.12"],"gpu":["6.13"],"合成":["6.13"],"cpu":["6.13"],"处理要快":["6.13"],"当需要":["6.13"],"不影响其他图层":["6.14"],"而其他不是合成层的渲染层":["6.14"],"则和其第一个拥有图层":["6.14"],"graphicslayer":["6.14"],"transform":["6.15","53.28"],"translatez":["6.15"],"如果使用":["6.15"],"translatex":["6.15"],"和":["6.16","19.74","20.30","45.5","45.26"],"内存资源":["6.16"],"严重影响了页面的性能":["6.16"],"也就是说除了我们显式的声明的合成层":["6.17"],"还可能由于重叠原因不经意间产生一些不在预期的合成层":["6.17"],"极端一点可能会产生大量的额外合成层":["6.17"],"当浏览器解析到标签时":["6.18"],"它将该标签解释为包含这一块内容的最重要的标题":["6.18"],"有利于seo":["6.19"],"爬虫依赖标签来确定关键字的权重":["6.19"],"因此可以帮助爬虫抓取更多的有效信息":["6.19"],"广告展示等":["6.20"],"iframe元素的基本用法是通过src属性指定要嵌入的html文档或网页的url":["6.20"],"optimization":["7.1"],"汉译为搜索引擎优化":["7.1"],"言简意赅的体现出页面的主要内容":["7.2"],"可以用一些符号把不同的主题词隔开":["7.3"],"但是关键词不要太多":["7.3"],"提升关键词的密度":["7.4"],"写清楚图片索要反映的内容":["7.5"],"外链":["7.5"],"友情链接":["7.5"],"结构":["8.1","8.3","37.3"],"主要是有html标签组成":["8.1"],"text":["8.2"],"和数量单位":["8.2"],"不要在注释内容中使用":["8.2"],"所有标签的元素和属性的名字都必须使用小写":["8.2"],"尽量使用外链css样式表和js脚本":["8.3"],"表现和行为分为三块":["8.3"],"通常":["9.1"],"由http客户端发起一个请求":["9.1"],"创建一个到服务器指定端口":["9.1"],"默认是80端口":["9.1"],"的tcp连接":["9.1"],"灵活":["9.2"],"http允许传输任意类型的数据对象":["9.2"],"正在传输的类型由content":["9.2"],"type加以标记":["9.2"],"internet":["9.3"],"传输控制协议":["9.3"],"客户端的连接请求可能会一直等待":["9.4"],"导致阻塞":["9.4"],"抓包工具抓下来的是密文":["9.5"],"大幅增加了中间人攻击的成本":["9.5"],"简单来说":["9.5"],"https协议是由ssl":["9.5"],"http协议构建的可进行加密传输":["9.5"],"身份认证的网络协议":["9.5"],"客户端":["9.6"],"通常是web浏览器":["9.6"],"向服务器发送一个连接请求":["9.6"],"并":["9.6"],"请求服务器发送其ssl证书":["9.6"],"服务器响应":["9.6"],"相同的密钥":["9.7"],"公钥和私钥":["9.8"],"x":["9.9","11.6","16.9","16.23","42.5","42.15","42.26","42.27","42.28"],"大幅度的提升了":["9.9"],"web":["9.9"],"性能":["9.9"],"这对于加载复杂网页或处理大量资源请求时特别有用":["9.10","28.10"],"这些表中包含了一些常用的头部字段和值":["9.11"],"静态表是在协议中预定义的":["9.11"],"不会改变":["9.11"],"客户端可能需要的资源":["9.12"],"并在客户端请求这些资源之前将它们推送给客户端":["9.12"],"其实就是缓存了源站内容的代理服务器":["9.13","53.21"],"应用cdn后":["9.13","53.21"],"dns":["9.13","53.21"],"返回的不再是":["9.13","53.21"],"ip":["9.13","53.21"],"路径":["9.14"],"指定资源提交数据":["9.16"],"请求服务器进行处理":["9.16"],"例如提交表单或者上传文件":["9.16"],"数据被包含在请求文本中":["9.16"],"这个请求可能会创建新的资源或者修改现有资源":["9.16"],"或两者皆有":["9.16"],"put":["9.16","16.42"],"安全性讲":["9.17"],"get和post都一样":["9.17"],"没啥所谓的哪个更安全":["9.17"],"get请求参数在url地址上":["9.17"],"直接暴露":["9.17"],"post请求的参数放request":["9.17"],"post不能":["9.18"],"match":["9.19"],"值为上一次服务器返回的":["9.19"],"etag":["9.19"],"一般会和if":["9.19"],"cookie":["9.19","30.0"],"已有的cookie":["9.19"],"referer":["9.19"],"标识请求引用自哪个地址":["9.19"],"比如你从页面":["9.19"],"跳转到页面":["9.19"],"请求方式中的请求参数":["9.20"],"以":["9.20","37.4"],"响应头":["9.21"],"继续处理":["9.22"],"2xx":["9.22"],"用于表示请求已被成功接收":["9.22"],"请求的网页已永久移动到新位置":["9.23"],"服务器返回此响应":["9.23"],"对":["9.23"],"head":["9.23","72.2","72.6","72.8"],"请求的响应":["9.23"],"时":["9.23","36.17","37.16"],"会自动将请求者转到新位置":["9.23"],"临时移动":["9.23"],"服务器目前从不同位置的网页响应请求":["9.23"],"但请求者应继续使用原有位置来进行以后的请求":["9.23"],"查看其他位置":["9.23"],"请求者应当对不同的位置使用单独的":["9.23"],"请求来检索响应时":["9.23"],"服务器返回此代码":["9.23"],"未修改":["9.23"],"自从上次请求后":["9.23"],"请求的网页未修改过":["9.23"],"服务器返回此响应时":["9.23"],"不会返回网页内容":["9.23"],"查询":["9.25"],"获取网站的ip地址":["9.25"],"向":["9.25","38.6"],"还是一个待搜索的关键词":["9.26"],"并且根据你输入的内容进行自动完成":["9.26"],"字符编码等操作":["9.26"],"操作系统缓存":["9.27"],"操作系统也有自己的":["9.27"],"在直接连接的节点之间传输数据":["9.28"],"提供了可靠的数据传输":["9.28"],"网络层":["9.28"],"network":["9.28"],"负责路由和寻址":["9.28"],"将数据包从源地址传输到目的地址":["9.28"],"则存入缓存":["9.30"],"closed":["9.33"],"的状态":["9.33"],"服务端处于":["9.33"],"listen":["9.33"],"状态":["9.33","41.2"],"等待服务端的确认":["9.34"],"此时客户端处于fin":["9.34"],"wait1状态":["9.34"],"服务端收到":["9.34"],"之后":["9.34","16.3","16.4","16.5"],"是用于在网络中标识和定位设备的地址":["9.35"],"在":["9.35","42.12"],"数据包在发送之前不需要建立连接":["9.36"],"数据传输方式":["9.36"],"提供":["9.36"],"面向字节流的数据传输方式":["9.36"],"将数据切分为大小不等的数据段进行传输":["9.36"],"并确保数据的顺序和完整性":["9.36"],"则以":["9.36"],"数据报的形式传输数据":["9.36"],"每个数据报都是独立的单元":["9.36"],"可能会以":["9.36"],"无状态指的是在每个独立的":["9.37"],"请求之间":["9.37"],"可以是会话级别的":["9.38"],"在浏览器关闭后失效":["9.38"],"或持久性的":["9.38"],"在一定时间后失效":["9.38"],"是一种服务器端的状态管理机制":["9.38"],"当用户":["9.38"],"进行身份认证":["9.38"],"后":["9.38","25.1","34.4"],"服务器会为该用户":["9.38"],"创建一个唯一的":["9.38"],"process":["9.39","19.16"],"从而触发攻击":["10.1"],"存储型":["10.1"],"攻击通常发生在社交网站":["10.1"],"留言板":["10.1"],"博客等":["10.1"],"攻击者会":["10.1"],"将恶意代码存储在服务器上":["10.1"],"跨站点脚本":["10.2"],"xss":["10.2"],"等攻击":["10.2"],"数据保护和加密":["10.2"],"web应用程序必须保护用户的敏感信息":["10.2"],"如用户名":["10.2"],"密码":["10.2"],"scripting":["10.3"],"攻击通常通过以下步骤实施":["10.4"],"攻击者创建恶意网页":["10.4"],"攻击者创建一个包含恶意代码的网页":["10.4"],"其中包含":["10.4"],"对目标网站的请求":["10.4"],"只有在令牌验证通过的情况下":["10.5"],"才执行请求":["10.5"],"启用":["10.5"],"samesite":["10.5"],"进行合适的转义":["10.6"],"将特殊字符转换为其对应的":["10.6"],"实体":["10.6"],"是通过将恶意的":["10.7"],"虚拟机":["11.1"],"并能扩展新的能力":["11.2"],"大大增加程序的重用性和易维护性":["11.2"],"在java中是单继承的":["11.2"],"也就是说一个子类只有一个父类":["11.2"],"float":["11.3"],"double":["11.3","11.25"],"二进制位数":["11.3"],"所以":["11.4"],"在集合类中":["11.5"],"我们是无法将":["11.5"],"java":["11.6","11.19","11.23"],"integer":["11.6"],"调":["11.6"],"valueof":["11.6"],"同一个字符串实例可以被多个线程共享":["11.7"],"因为字符串不可变":["11.7"],"本身就是线程安全的":["11.7"],"支持hash映射和缓存":["11.7"],"因为string的hash值经常会使用到":["11.7"],"比如作为":["11.7"],"map":["11.7","20.10","62.0"],"不可变":["11.8"],"前提是字符串常量池中没有":["11.9"],"这个字符串对象":["11.9"],"保存着所有字符串字面量":["11.10"],"这些字面量在编译时期就确定":["11.10"],"true":["11.11","17.13","19.35","19.41","36.6","38.3","38.8","42.8","45.4","45.15","71.12","72.11","72.12","78.4"],"equals与hashcode的关系":["11.11"],"如果两个对象调用equals比较返回true":["11.11"],"name":["11.12","14.2","14.10","16.49","19.62","20.4","20.13","20.20","42.26","44.35","65.1","65.6"],"存放在堆内存":["11.12"],"int":["11.12","14.3","16.22","16.25","16.28","16.30","16.32","16.36"],"age":["11.12","19.28","20.20","37.10","53.19","53.35"],"school":["11.12"],"存放在堆内存的类的静态成员变量区":["11.12"],"system":["11.14","16.23","16.43","17.17"],"out":["11.14","16.5","16.43","17.17"],"println":["11.14","16.5","16.22","16.43","17.17"],"protected":["11.15"],"public":["11.15","11.17","11.19","11.23"],"最终方法":["11.16"],"abstracttest1":["11.17"],"static":["11.17","11.19","11.23"],"void":["11.17","11.18","11.19","16.9","16.17","16.28","16.33","16.46","17.12","17.13","17.15"],"string":["11.18","16.21","16.28","16.49","19.2","42.5","42.13","42.26"],"args":["11.18","16.21","42.32","75.12"],"new":["11.18","11.22","11.24","16.15","16.21","16.33","16.42","16.47","19.28","20.10","22.2","22.10","42.8","45.4","45.8","59.8","65.3","65.4"],"多继承":["11.19"],"interfacetest1":["11.19"],"抽象类":["11.20"],"可以定义变量也可以定义常量":["11.20"],"父类引用指向子类对象":["11.21"],"usedog":["11.21"],"usecat":["11.21"],"cat":["11.21"],"useanimal":["11.21"],"等于":["11.21"],"f":["11.22"],"blocktest":["11.23"],"io":["11.24"],"外部类访问内部类需要先创建对象访问":["11.24"],"show":["11.24"],"无法保证小数的精度":["11.25"],"则表示否定模式":["11.26"],"此模式匹配所有字符":["11.26"],"除了":["11.26"],"d1":["11.26"],"范围匹配":["11.26"],"到":["11.26"],"d":["11.26","16.50"],"和数字从":["11.26"],"之间":["11.26"],"但不匹配":["11.26"],"xz":["11.26"],"写在方法调用处":["11.28"],"compile":["12.1"],"允许重复使用一个现有的数据库连接":["13.1"],"放在同包同名下":["13.2"],"set":["13.3","44.16","45.4","45.17","45.18","45.21"],"if":["13.3","16.9","16.39","16.42","19.51","19.52","19.54","38.7","45.9","45.28","59.6","59.7","67.4","71.11","71.13","71.14","72.2","73.2","77.3"],"test":["13.3","32.5"],"null":["13.3","14.4","14.6","16.39","16.42","16.50","20.20","53.1","59.1","59.2","67.3","69.2","69.4","71.11","71.12"],"categoryid":["13.3"],"database":["14.0"],"mydatebase":["14.0"],"删除":["14.0","45.24"],"dml":["14.1"],"username":["14.2"],"varchar":["14.2"],"用户名":["14.2"],"password":["14.4","80.5"],"job":["14.4"],"entrydate":["14.4"],"ljt":["14.4","78.2","78.3","79.2","79.3","81.0","82.2","82.3"],"where":["14.5","14.10","14.14"],"条件列表":["14.5"],"吕江涛":["14.6"],"is":["14.6","20.4"],"not":["14.6"],"不满足where条件":["14.7"],"having":["14.8"],"asc":["14.9"],"升序默认":["14.9"],"查询第一页索引可以省略不写":["14.10"],"like":["14.10"],"吕":["14.10"],"and":["14.10"],"id":["14.11","14.14","37.15","44.35"],"foreign":["14.11"],"join":["14.12"],"on":["14.12"],"显示内连接":["14.12"],"inner可写可不写":["14.12"],"外连接":["14.12"],"td":["14.12"],"status":["14.13"],"tb":["14.14"],"dept":["14.14"],"sql":["14.15"],"创建":["14.15"],"create":["14.15","20.14"],"index":["14.15","29.5","34.30","72.9","72.11","72.12"],"声明bean的基础注解":["15.2"],"不属于以下三类时":["15.2"],"用此注解":["15.2"],"service":["15.2"],"component的衍生注解":["15.2"],"标注在控制器上":["15.2"],"controller":["15.2"],"可以被aop控制的方法":["15.3"],"通知":["15.3"],"advice":["15.3"],"前置通知":["15.4"],"在目标方法前执行":["15.4"],"运行前类名越靠前aop越先执行":["15.5"],"会把bean都创建好放在ioc容器中":["15.6"],"与":["15.7","45.18"],"configuration作用相同":["15.7"],"用来声明当前也是一个配置类":["15.7"],"componentscan":["15.7"],"组件扫描":["15.7"],"计时等待":["16.1"],"timed":["16.1"],"终止":["16.1"],"terminated":["16.1"],"获取当前线程的状态":["16.1"],"getstate":["16.1","16.3","16.4","16.5"],"return":["16.1","16.28","16.42","19.22","34.21","42.2","45.9","45.21","52.3","59.1","59.2","59.6","67.1","69.4","72.4","72.8","72.10","74.1","76.7","86.1"],"jdk":["16.1"],"internal":["16.1"],"misc":["16.1"],"vm":["16.1"],"案例演示":["16.2"],"执行thread":["16.3","16.4","16.5"],"start":["16.3","16.4","16.9"],"线程的状态":["16.3","16.4","16.5"],"currentthread":["16.3","16.4","16.5"],"try":["16.3","16.4","16.17","16.43"],"休眠100毫秒":["16.3"],"sleep":["16.3","16.4","16.11","16.17","16.43"],"catch":["16.3","16.4","16.17","16.43","21.6"],"e":["16.3","16.17","16.43","19.51","19.52"],"printstacktrace":["16.3"],"synchronized":["16.4","17.10"],"thread1需要休眠100毫秒":["16.4"],"thread1100毫秒之后":["16.4"],"通过wait":["16.4"],"方法释放obj对象是锁":["16.4"],"wait":["16.4"],"thread3要持有对象锁100毫秒":["16.5"],"notify":["16.5"],"然后通过notify":["16.5"],"方法唤醒所有在ojb2上等待的线程继续执行后续操作":["16.5"],"线程池也是可以看做成一个池子":["16.6"],"在该池子中存储很多个线程":["16.6"],"线程池存在的意义":["16.6"],"系统创建一个线程的成本是比较高的":["16.6"],"自定义线程池":["16.7"],"一次性启动多个":["16.8"],"2个":["16.8"],"消费者线程":["16.8"],"初始化线程方法":["16.9"],"for":["16.9","16.23","20.18","26.4","46.0","53.30","61.0","61.1","67.2","69.1","69.2","69.4","88.1"],"线程":["16.9"],"jdk中线程池":["16.10"],"线程休眠2秒":["16.11"],"主线程休眠2秒":["16.11"],"此时之前提交的任务应该已经执行完毕":["16.11"],"timeunit":["16.11","16.15","17.18"],"seconds":["16.11","16.15","17.18"],"我们发现是通过一个线程执行了两个任务":["16.11"],"此时就说明线程池中的线程":["16.11"],"被线程池回收了":["16.11"],"成为了空闲线程":["16.11"],"当我们再次提交任务的时候":["16.11"],"该线程就去执行新的任务":["16.11"],"corepoolsize":["16.13"],"maximumpoolsize":["16.13"],"long":["16.13"],"keepalivetime":["16.13"],"unit":["16.13"],"blockingqueue":["16.13"],"workqueue":["16.13"],"threadfactory":["16.13"],"rejectedexecutionhandler":["16.13"],"handler":["16.13"],"如果工作队列没有满":["16.14"],"则将新提交的任务存储在这个工作队列里":["16.14"],"等待核心线程池中的空闲线程执行":["16.14"],"如果工作队列满了":["16.14"],"则进入下个流程":["16.14"],"线程池会再次在非核心线程池区域去创建新工作线程来执行任务":["16.14"],"arrayblockingqueue":["16.15"],"executors":["16.15"],"0x0000000100066840":["16.16"],"2f7a2457":["16.16"],"rejected":["16.16","21.2"],"6108b2d7":["16.16"],"running":["16.16"],"active":["16.16"],"threads":["16.16"],"queued":["16.16"],"tasks":["16.16"],"at":["16.16"],"base":["16.16"],"rejectedexecution":["16.16"],"reject":["16.16","21.7","61.1"],"execute":["16.16"],"override":["16.17","16.27","16.33","16.43","16.46","16.47","17.12","17.13","18.4"],"run":["16.17","16.33","16.43","16.46","17.12","17.13"],"线程休眠1秒":["16.17"],"interruptedexception":["16.17","16.21"],"描述了java程序中各种变量":["16.18"],"速度快":["16.19"],"快到没有时间再去读取主内存中的值":["16.19"],"所以while":["16.19"],"读取到的值一直是false":["16.19"],"如果有一个时刻main线程从主内存中读取到了flag的最新值":["16.19"],"那么if语句就可以执行":["16.19"],"main线程何时从主内存中读取最新的值":["16.19"],"我们无法控制":["16.19"],"我们可以让主线程执行慢一点":["16.19"],"问题处理":["16.20","16.29"],"throws":["16.21"],"创建volatilethread线程对象":["16.21"],"volatilethread":["16.21"],"更新之后的案例":["16.22"],"volatiletest":["16.22"],"while":["16.22","16.50","17.13","42.8","66.4","67.3","67.5","70.1","71.10","71.12","71.15","72.9","74.2"],"操作":["16.23","45.18"],"100次":["16.23"],"操作不是一个原子性操作":["16.24"],"也就是说在某一个时刻对某一个操作的执行":["16.24"],"有可能被其他的线程打断":["16.24"],"1571794778139":["16.24"],"产生问题的执行流程分析":["16.24"],"implements":["16.25","16.27","16.30","16.47"],"runnable":["16.25","16.27","16.30","16.46","16.47"],"定义一个int类型的变量":["16.25","16.30"],"并且使用volatile修饰":["16.25"],"private":["16.25","16.27","16.28","16.30","16.43","16.47","16.49","18.1"],"volatile":["16.25","16.27","16.28","16.36"],"volatile使用场景":["16.26"],"volatileusethread":["16.27"],"定义标志变量":["16.27"],"boolean":["16.27","19.2","24.2"],"shutdown":["16.27"],"false":["16.27","16.42","19.42","20.19","36.5","38.2","50.4","69.4","71.11","72.4","72.8"],"温度传感器类":["16.28"],"gettemperature":["16.28"],"settemperature":["16.28"],"this":["16.28","16.43","19.75","19.77","20.4","20.13","34.9","38.7","44.34","65.5","71.12","72.1","72.2","72.5","72.6","72.7","72.10"],"gettype":["16.28"],"settype":["16.28"],"volatileatomicthread":["16.30"],"count":["16.30","61.0"],"initialvalue":["16.32"],"初始化一个指定值的原子型integer":["16.32"],"get":["16.32","16.39","19.54","22.8","45.4","45.18","45.21","45.26","45.29","72.11","72.12"],"获取值":["16.32"],"getandincrement":["16.32"],"以原子方式将当前值加1":["16.32","16.36"],"这里返回的是自增前的值":["16.32"],"incrementandget":["16.32","16.36"],"这里返回的是自增后的值":["16.32","16.36"],"addandget":["16.32"],"atomicinteger原理":["16.34"],"要修改的新值b":["16.35"],"当且仅当旧预期值a和内存值v相同时":["16.35"],"将内存值v修改为b并返回true":["16.35"],"否则什么都不做":["16.35"],"并返回false":["16.35"],"举例说明":["16.35"],"在内存值v当中":["16.35"],"存储着值为10的变量":["16.35"],"1571817059527":["16.35"],"objectfieldoffset":["16.36"],"this表示当前atomicinteger对象":["16.36"],"1表示要增加的值":["16.36"],"总是假设最坏的情况":["16.37"],"每次去拿数据的时候都认为别人会修改":["16.37"],"所以每次在拿数据的时候都会上锁":["16.37"],"这样别人想拿这个数据就会阻塞直到它拿到锁":["16.37"],"concurrenthashmap":["16.38"],"hashmap中的键就是当前循环变量的x这个数据的字符串表现形式":["16.39"],"根据键找到值":["16.39"],"然后在进行判断":["16.39"],"equals":["16.39"],"控制台输出结果":["16.39"],"通过控制台的输出结果":["16.39"],"我们可以看到在多线程操作hashmap的时候":["16.39"],"可能会出现线程安全问题":["16.39"],"注1":["16.39"],"需要多次运行才可以看到具体的效果":["16.39"],"可以使用循环将代码进行改造":["16.39"],"以便让问题方便的暴露出来":["16.39"],"案例2":["16.39"],"演示hashtable线程安全":["16.39"],"hashtabledemo01":["16.39"],"创建一个hashtable集合对象":["16.39"],"hashtable":["16.39"],"当前节点key对应的哈希码值":["16.41"],"key":["16.41","19.73","22.7","34.25","45.19","45.28","45.32","85.11"],"存储键":["16.41"],"存储值":["16.41"],"next":["16.41","67.2","67.4","67.5","67.7"],"下一个节点":["16.41"],"对应的结构如下图所示":["16.41"],"1571880094854":["16.41"],"简单来讲":["16.41"],"就是concurrenthashmap比hashmap多了一次hash过程":["16.41"],"第1次hash定位到segment":["16.41"],"第2次hash定位到hashentry":["16.41"],"然后链表搜索找到指定节点":["16.41"],"在进行写操作时":["16.41"],"只需锁住写":["16.41"],"元素所在的segment即可":["16.41"],"这种锁被称为":["16.41"],"red":["16.41","82.7"],"分段锁":["16.41"],"其他segment无需加锁":["16.41"],"从而产生锁竞争的概率大大减小":["16.41"],"提高了并发读写的效率":["16.41"],"该种实现方式的缺点是hash过程比普通的hashmap要长":["16.41"],"因为需要进行两次hash操作":["16.41"],"concurrenthashmap的put方法源码分析":["16.41","16.42"],"添加元素":["16.42"],"putval":["16.42"],"putval方法定义":["16.42"],"onlyifabsent":["16.42"],"key为null直接抛出异常":["16.42"],"throw":["16.42","42.8","59.8"],"nullpointerexception":["16.42"],"计算key所对应的hashcode值":["16.42"],"spread":["16.42"],"hashcode":["16.42"],"bincount":["16.42"],"构造方法的作用":["16.43"],"接收countdownlatch对象":["16.43"],"thread":["16.43","16.45","16.46","16.49"],"10秒以后执行了countdownlatchthread01":["16.43"],"cyclicbarrier":["16.44"],"创建一个员工线程类":["16.45"],"employeethread":["16.45"],"该线程类中需要定义一个cyclicbarrier类型的形式参数":["16.45"],"创建一个开会线程类":["16.45"],"mettingthread":["16.45"],"测试类":["16.45"],"创建cyclicbarrier对象":["16.45"],"创建5个employeethread线程对象":["16.45"],"把第一步创建的cyclicbarrier对象作为构造方法参数传递过来":["16.45"],"启动5个员工线程":["16.45"],"员工线程类":["16.45"],"extends":["16.45","16.49","34.21","73.2"],"当前我们两个线程到达了屏障点以后":["16.46"],"我们需要立即对数据进行汇总":["16.46"],"因此我们需要使用第二个构造方法":["16.46"],"并且我们当前这个类就是一个任务类":["16.46"],"因此我们可以直接传递参数this":["16.46"],"存储两个线程所读取的数据":["16.46"],"线程1":["16.46"],"读取数据":["16.46"],"bufferedreader":["16.46","16.50"],"创建线程任务类对象":["16.47"],"创建5个线程对象":["16.47"],"并启动":["16.47"],"5个线程对象":["16.47"],"相当于5辆汽车":["16.47"],"carthreadrunnable类":["16.47"],"创建一个semaphore对象":["16.47"],"限制只允许2个线程获取到许可证":["16.47"],"exchanger":["16.48"],"启动两个线程":["16.49"],"manthread类":["16.49"],"定义exchanger类型的变量":["16.49"],"读取文件中的数据":["16.50"],"然后将其存储到集合中":["16.50"],"filereader":["16.50"],"salary":["16.50"],"txt":["16.50"],"line":["16.50"],"readline":["16.50"],"add":["16.50"],"是进程的实际运作单位":["17.1"],"是概率问题":["17.5"],"不会全部执行完":["17.6"],"交给操作系统了":["17.8"],"java就不管了":["17.8"],"如果线程遇到阻塞方法":["17.8"],"没有执行资格和执行权":["17.8"],"阻塞方法结束之后处于就绪状态":["17.8"],"safety":["17.9"],"是指在多线程环境下":["17.9"],"关键字或":["17.10"],"lock接口":["17.10"],"来对关键代码块或方法进行同步":["17.10"],"原子操作可以用来解决确保线程安全":["17.11"],"确保对共享数据的操作是原子性的":["17.11"],"不会被其他线程中断":["17.11"],"在java中":["17.11"],"ticket":["17.12","17.13"],"stringbuffer用于多线程":["17.14"],"lock":["17.15"],"吃":["17.17"],"notifyall":["17.17"],"唤醒绑在这把锁上的所有线程":["17.17"],"阻塞队列实现等待唤醒":["17.17"],"cook":["17.17"],"空闲线程最大存活时间":["17.18"],"时间单位":["17.18"],"注解":["18.1"],"衍生注解":["18.2"],"autowired注入service接口":["18.3"],"service接口需要一个实现类来获取数据":["18.3"],"success":["18.4","79.4","84.1"],"接口实现类方法重写":["18.4"],"原始和pagehelper插件进行分页查询":["18.4"],"分页查询实现类":["18.4"],"param":["18.4"],"安全":["19.1"],"由于javascript通常运行在浏览器环境中":["19.1"],"typeof能识别所有的基本类型值类型":["19.3"],"识别函数":["19.3"],"bool":["19.4","42.17"],"array":["19.4","42.19","59.10","73.1","73.2","77.5"],"und":["19.4"],"regexp":["19.4"],"async":["19.5"],"加载和渲染后续文档元素的过程将和":["19.6"],"script":["19.6"],"它也会在html页面解析完毕之后再去执行":["19.7"],"所以定义在return上":["19.9"],"以方法形式调用this是当前实例":["19.10"],"即主执行栈":["19.11"],"异步任务进入任务队列":["19.11"],"主线程内的任务执行完毕为空":["19.11"],"会去任务队列读取对应的任务":["19.11"],"不是所有微任务之后都会执行渲染":["19.12"],"如此形成循环":["19.12"],"又分为宏任务和微任务":["19.13"],"宏任务":["19.13"],"完成当下的宏任务后":["19.14"],"会立刻执行所有在此期间入队的微任务":["19.14"],"如果时间到了":["19.15"],"js引擎还在执行同步任务":["19.15"],"这个回调函数需要等待":["19.15"],"then":["19.16","60.0","86.1"],"微任务队列":["19.17"],"则对应属性的地址还是原对象的地址":["19.20"],"赋值后原对象改变":["19.21"],"也会影响":["19.21"],"square":["19.22"],"num":["19.22","42.17","53.14","59.9","88.1"],"var":["19.22","19.61","66.2","72.3"],"result":["19.22","20.22","61.0","76.4"],"因此可以将这块内存释放":["19.25"],"从全局对象":["19.25"],"开始":["19.25","38.0"],"该执行上下文会包含函数的":["19.26"],"作用域链":["19.26"],"还会把不能转成数字的判断为true":["19.27"],"例如字符串":["19.27"],"xxx":["19.27"],"prototype":["19.28","65.6","71.15"],"a为真时执行b":["19.29"],"返回一个代表该对象的字符串":["19.30"],"valueof偏向于运算":["19.30"],"存在栈内存里":["19.31"],"typeof":["19.34","45.9","60.0"],"为":["19.35"],"不同的数据类型在底层都是通过二进制表示的":["19.36"],"需要类型相同":["19.37"],"如果有一个操作数是布尔值":["19.39"],"则在比较相等性之前先将其转换为数值":["19.39"],"按照隐式转换规则":["19.40","19.41"],"右边为布尔值":["19.42"],"对吗":["19.43"],"不对":["19.43"],"onclick":["19.45"],"默认是false":["19.46"],"不阻止冒泡":["19.46"],"变量提升优先级":["19.47"],"并往上传播":["19.48"],"事件捕获":["19.48"],"是对xmlhttprequest对象":["19.49"],"xhr":["19.49"],"解析html结构":["19.50"],"这就是事件委托":["19.53"],"优点有":["19.53"],"方法遍历数组":["19.54"],"检查当前元素是否在":["19.54"],"中存在":["19.54"],"nan":["19.55"],"静态方法和原型方法":["19.57"],"数组开头添加元素":["19.58"],"返回新数组长度":["19.58"],"reserve":["19.58"],"反转一个数组":["19.58"],"返回修改后的数组":["19.58"],"sort":["19.58"],"排序一个数组":["19.58"],"取arr中的最小值":["19.59"],"ceil":["19.59"],"小数":["19.59"],"小数向上取整":["19.59"],"alert":["19.60"],"如":["19.61","53.19"],"date":["19.61"],"uri":["19.62"],"my":["19.62","20.4"],"profile":["19.62"],"php":["19.62"],"sammer":["19.62"],"操纵浏览器的记录":["19.63"],"back":["19.63"],"go":["19.63"],"innerheight":["19.63"],"即文档对象模型":["19.64"],"是":["19.64","44.49"],"和xml":["19.64"],"它从startindex返回子字符串并返回":["19.66"],"个字符数":["19.66"],"它返回从startindex到endindex":["19.67"],"1的子字符串":["19.67"],"是es5中引入的js指令":["19.68"],"元素在":["19.69"],"无需像其他参数一样在函数定义时声明":["19.71"],"我们可以这样定义一个函数":["19.71"],"arguments":["19.72"],"str":["19.73","72.3"],"in":["19.73","28.11","55.1"],"遍历对象的可枚举属性":["19.73"],"let":["19.73","22.2","22.9","22.10","41.7","42.2","42.5","42.15","42.20","45.7","45.21","53.30","59.2","61.1","65.3","66.2","69.5","69.7","71.15","72.8","72.11","72.12","73.1","73.2","75.4","75.5","75.7","75.9","75.11","75.13","75.14","75.18","75.23","75.26","75.27","75.29","75.30","75.31","76.1","77.4"],"输出":["19.73"],"用于提供下一个值":["19.74"],"并返回一个具有":["19.74"],"done":["19.74"],"属性的对象":["19.74"],"并将新创建的对象作为构造函数的上下文":["19.75"],"关键字的指向":["19.75"],"返回对象实例":["19.75"],"如果构造函数中没有显式地返回一个对象":["19.75"],"那么":["19.75"],"冒泡时当前目标元素会变":["19.76"],"preventdefault":["19.76"],"阻止事件的默认行为":["19.76"],"window对象":["19.77"],"lifo":["19.78"],"中":["20.1","42.9"],"几乎所有的对象都是":["20.1"],"对象":["20.2","45.3"],"b":["20.3","20.18","20.26","24.2","42.7","75.24"],"am":["20.4"],"要定义或修改的属性描述符":["20.6"],"object1":["20.6","20.12","20.16","20.19","20.25"],"循环还会枚举原型链中的属性":["20.8"],"一个被冻结的对象再也不能被修改":["20.9"],"冻结了一个对象则不能向这个对象添加新的属性":["20.9"],"foo":["20.10"],"bar":["20.10"],"prototype1":["20.12"],"level":["20.13"],"superhero":["20.13"],"baz":["20.14"],"进行检查的":["20.15"],"car":["20.15"],"make":["20.15"],"model":["20.15","44.60","80.4"],"year":["20.15"],"property1":["20.16"],"方法返回一个由指定对象的所有自身属性的属性名":["20.17"],"prop":["20.19"],"exists":["20.19"],"undefined":["20.20","42.14","53.1"],"如果满足以下任意条件则两个值相等":["20.21"],"都是":["20.21"],"number":["20.22","24.2","42.7","42.10","42.15","42.23","42.25","42.28","42.32"],"视为不相等":["20.22"],"case":["20.22"],"the":["20.22","28.11"],"same":["20.22"],"as":["20.22"],"using":["20.22"],"somestring":["20.25"],"c":["20.26"],"with":["20.26"],"random":["20.26"],"bigint":["20.30","53.1","53.27"],"方法接受一个可选的":["20.30"],"radix":["20.30"],"参数":["20.30","36.17"],"重写派生类对象":["20.31"],"mynumbertype":["20.31"],"n":["20.31"],"这个函数为立即执行的":["21.0"],"称之为":["21.0"],"executor":["21.0","86.2"],"fulfilled":["21.2"],"已兑现":["21.2"],"执行了resolve函数则代表了已兑现状态":["21.2"],"已拒绝":["21.2"],"执行了reject函数则代表了已拒绝状态":["21.2"],"如果resolve中传入的是另外一个promise":["21.3"],"那么这个新promise会决定原promise的状态":["21.3"],"当我new":["21.4"],"promise的时候":["21.4"],"会把返回的该对象的":["21.4"],"如果只捕获错误":["21.5"],"还可以这样写":["21.5"],"因为第二个参数是捕获异常的":["21.5"],"第一个可以写个null或":["21.5"],"占位":["21.5"],"ice":["21.6"],"error":["21.6","42.7","42.8","59.8"],"err":["21.6"],"resolve":["21.7","29.8","43.11","61.1"],"只要有一个promise的状态为rejected":["21.8"],"则会回调":["21.8"],"catch方法":["21.8"],"rejected状态":["21.8"],"同步的":["21.9"],"zero":["22.1"],"equality":["22.1"],"它类似于精确相等运算符":["22.1"],"主要的区别是nan等于自身":["22.1"],"而精确相等运算符认为nan不等于自身":["22.1"],"返回一个包含集合中所有键的迭代器":["22.3"],"values":["22.3"],"返回一个包含集合中所有值得迭代器":["22.3"],"entries":["22.3"],"返回一个包含set对象中所有元素得键值对迭代器":["22.3"],"是以":["22.7"],"的形式储存元素":["22.7"],"向字典中添加新元素":["22.8"],"通过键查找特定的数值并返回":["22.8"],"而weakmap中的键是弱引用":["22.11"],"当对应的对象被垃圾回收后":["22.11"],"键值对会自动从weakmap中删除":["22.11"],"这种行为使得weakmap更适合于临时存储与对象关联的数据":["22.11"],"直接访问":["23.1"],"得到的是一个空对象":["23.1"],"node":["23.2","33.0","71.7","71.9","72.1"],"中指向":["23.2"],"函数中的":["23.2"],"在函数中调用":["23.2"],"浏览器window":["23.3"],"node里global":["23.3"],"对象调用方法":["23.3"],"target":["23.3","45.4","45.22","45.28"],"如果如果没有这个参数或参数为undefined或null":["23.4"],"则":["23.4"],"默认指向全局window":["23.4"],"返回一个布尔值结果":["24.1"],"要注意":["24.2"],"函数调用":["24.3"],"后缀运算符":["24.3"],"前缀运算符":["24.3"],"同时将":["25.0"],"cookie的path属性设置为根路径":["25.0"],"app系统拿到":["25.1"],"从后台向sso发送请求":["25.1"],"验证":["25.1"],"是否有效":["25.1"],"验证通过后":["25.1"],"app系统将登录状态写入":["25.1"],"app系统的session":["25.1"],"先遍历再展平一级":["26.1"],"增删改查":["26.1"],"filter":["26.1"],"返回一个过滤后的新数组":["26.1"],"pop":["26.1","53.14","59.9","85.7"],"push":["26.1","43.6"],"shift":["26.1"],"unshift":["26.1"],"concat":["26.1","53.14","59.9"],"slice":["26.1"],"orange":["26.4"],"从该位置开始读取数据":["26.5"],"默认为":["26.5"],"表示从末尾开始计算":["26.5"],"end":["26.5"],"用于控制正则表达式匹配的方式":["27.0"],"和new":["27.0"],"都会创建一个匹配hello的正则表达式对象":["27.0"],"匹配字符集":["27.0"],"用方括号":["27.0"],"表示一个字符集":["27.0"],"定义一个方法组建作为参数传入":["28.1"],"给子组件":["28.2"],"传值传给父组件":["28.2"],"这样就实现了数据双向绑定":["28.2"],"尺寸通过计算属性来更改类名":["28.2"],"使用":["28.2","36.15","44.22","44.23"],"useattrs":["28.2"],"来继承原生input的属性":["28.2"],"一键清空通过":["28.2"],"做不到按需加载":["28.3"],"经常用的一个series和parallel定义执行任务顺序执行并行执行":["28.4"],"删除之前的打包文件函数":["28.5"],"写了一个配置文件":["28.6"],"在pinia的配置文件里写项目要用到的actions":["28.7"],"post等请求":["28.8"],"您可以独立扩展前端服务器或后端":["28.9"],"api":["28.9"],"而无需重新编写整个应用程序":["28.9"],"从而提高性能并减少延迟":["28.10"],"2还引入了头部压缩":["28.10"],"compression":["28.10"],"和服务器推送":["28.10"],"middle":["28.11"],"未过期":["28.12"],"之前的最长时间":["28.12"],"以秒为单位":["28.12"],"影响网页的可用性和可读性":["28.13"],"明确指定资源尺寸":["28.13"],"在网页中为图像":["28.13"],"视频和其他资源指定明确的尺寸":["28.13"],"如图片":["28.14"],"脚本和样式":["28.14"],"以减少初始加载时间":["28.14"],"图像和媒体优化":["28.14"],"图像压缩":["28.14"],"使用适当的图像压缩算法和工具":["28.14"],"减少图像文件的大小":["28.14"],"它是webgl的继任者":["28.15"],"空间占用":["28.16"],"是一种软件开发模式":["28.17"],"语言":["29.1"],"你会发现它有两种格式的模块":["29.1"],"br":["29.1","80.6"],"模块使用import引入具体数据和export导出指定数据":["29.2"],"只要脚本文件里面使用import或者export命令":["29.3"],"那么就必须采用":["29.3"],"mjs后缀名":["29.3"],"packagemain":["29.4"],"package":["29.4"],"结束进程":["29.7"],"readfile":["29.9"],"通过非阻塞":["29.10"],"默认的情况下是关闭浏览器后失效":["30.1"],"存储量较小":["30.2"],"一般会携带在http请求的头部中":["30.3"],"expires":["30.4"],"thu":["30.4"],"01":["30.4"],"jan":["30.4"],"00":["30.4"],"目前见到的浏览器都支持":["30.5"],"token是用来干嘛的":["30.6"],"的意思":["30.7"],"token是服务端生成的一串字符串":["30.7"],"生成token":["30.8"],"验证成功后":["30.8"],"服务端会生成一个token":["30.8"],"然后把这个token发送给客户端":["30.8"],"后期每次请求接口都需要把他当做一个字段传给后台":["30.9"],"会有xss攻击":["30.9"],"每次浏览器向服务器发送请求时":["30.10"],"它都会将相应的cookie信息发送给服务器":["30.10"],"服务器可以读取cookie中的数据":["30.10"],"从而知道用户的身份":["30.10"],"偏好设置等信息":["30.10"],"cookie通常包含以下属性":["30.10"],"开发时":["31.0"],"vite":["31.1","31.2","51.5"],"配置文件采用es6模块化规范":["31.3"],"安装":["32.0"],"配置文件采用commonjs模块化规范":["32.1"],"development开发模式":["32.2"],"src":["32.3","44.63"],"file":["32.3"],"clean":["32.4"],"模块":["32.5"],"以供应用程序使用":["32.5"],"以及被添加到依赖图中":["32.5"],"module":["32.5"],"rules":["32.5"],"m":["32.6"],"exclude":["32.6"],"自身也是构建于你在":["32.7"],"配置中用到的":["32.7"],"把代码部署到服务器上":["32.8"],"实时自动刷新":["32.8"],"此选项控制是否生成":["32.9"],"以及如何生成":["32.9"],"typescript":["33.0"],"语法":["34.1"],"单向数据绑定":["34.1"],"其state变化会引起render的重新执行":["34.2"],"函数式组件中":["34.2"],"使用sethook更新state也会引起render的重新执行":["34.2"],"shouldcomponentupdate":["34.2","34.26"],"比对":["34.2"],"state和":["34.2"],"props":["34.2","34.4","36.14","38.7"],"模板与数据的绑定":["34.3"],"确保数据在dom挂载时已经准备好了":["34.3"],"即没有组件状态":["34.4"],"只能依赖传入的":["34.4"],"进行渲染":["34.4"],"但是":["34.4"],"自":["34.4"],"版本引入":["34.4"],"hooks":["34.4","34.9"],"函数组件可以使用":["34.4"],"usestate":["34.4"],"等":["34.4"],"hook":["34.4"],"来管理状态":["34.4","34.9"],"使得函数组件具有了状态管理的能力":["34.4"],"称为有状态函数组件":["34.4"],"常用的钩子":["34.5"],"在组件挂载成功之后调用":["34.5"],"该过程组件已经成功挂载到了真实":["34.5"],"上":["34.5"],"一般在这个钩子中做一些初始化的事":["34.5"],"开启定时器":["34.5"],"发送网络请求":["34.5"],"订阅消息":["34.5"],"在组件挂载到":["34.6"],"后调用":["34.6"],"可以进行一次性的数据获取":["34.6"],"订阅事件等操作":["34.6"],"更新阶段":["34.6"],"updating":["34.6"],"它接收两个参数":["34.7"],"一个是传进来的":["34.7"],"它使得组件能在发生更改之前从":["34.8"],"中捕获一些信息":["34.8"],"此组件返回的任何值将作为":["34.8"],"也可以使用":["34.9"],"有状态组件可以通过":["34.9"],"数据修改了":["34.10"],"接下来要解决视图的更新":["34.10","40.1"],"react中":["34.10","40.1"],"调用setstate方法后":["34.10","40.1"],"会自顶向下重新渲染组件":["34.10","40.1"],"在老的架构中":["34.11"],"节点以树的形式被组织起来":["34.11"],"每个节点上有多个指针指向子节点":["34.11"],"要找到两棵树的变化部分":["34.11"],"最容易想到的办法就是":["34.11"],"深度优先遍历":["34.11"],"这种遍历有一个特点":["34.11"],"必须一次性完成":["34.11"],"fiber把组件渲染工作切片":["34.12"],"然后由统一的事件处理程序":["34.13"],"dispatchevent":["34.13"],"来处理":["34.13"],"同时也是基于冒泡":["34.13"],"所有节点的事件都会在":["34.13"],"将这些事件在document上注册":["34.14"],"在组件挂载完成后":["34.14"],"而是由原生事件合成的react事件":["34.15"],"比如":["34.15","37.4"],"click事件合成为onclick事件":["34.15"],"比如blur":["34.15"],"change":["34.15"],"input":["34.15"],"在一开始就将事件插件全部加载进来":["34.16"],"registrationnamemodule":["34.16"],"react":["34.17","36.11","36.16","36.17","36.19","38.0"],"事件对象不会被释放掉":["34.17"],"节点上的原生事件的执行是在目标阶段":["34.18"],"元素触发事件":["34.19"],"会冒泡到":["34.19"],"render":["34.20","34.27"],"app":["34.20","46.6"],"withlogger":["34.21"],"wrappedcomponent":["34.21"],"withlogger是一个接受一个组件作为参数的":["34.21"],"hoc":["34.21"],"component":["34.21","37.4","37.12"],"componentdidmount":["34.21"],"createclass":["34.22"],"通过getinitialstate":["34.22"],"方法返回一个包含初始值的对象":["34.22"],"state":["34.23","37.10","41.2","44.33"],"或者组件的属性":["34.23"],"dom的读取在pre":["34.24"],"被添加或者被移出的辅助标识":["34.25"],"在开发过程中":["34.25"],"我们需要保证某个元素的":["34.25"],"子组件修改自身state":["34.26"],"不要再":["34.27"],"方法中使用高阶组件":["34.27"],"组件中引入":["34.28"],"文件":["34.28"],"active的class执行动画":["34.29"],"in属性置为false时":["34.29"],"csstransition会给子组件加上xxx":["34.29"],"exit和xxx":["34.29"],"exit":["34.29"],"active的class":["34.29"],"javascript":["34.31"],"错误":["34.31"],"创建新的组件":["35.1"],"即使是类似的组件":["35.1"],"但只要组件不同":["35.1"],"就会被销毁重新创建":["35.1"],"策略三":["35.1"],"元素diff":["35.1"],"element":["35.1","73.1","73.2"],"dom同层级单个节点的比较":["35.1"],"比较策略":["35.1"],"如果根节点相同":["35.2"],"进入下一步":["35.2"],"比较其子节点":["35.2"],"如果根节点不同":["35.2","44.50"],"对比一致则":["35.3"],"指针向后或者向前移动":["35.3"],"如果头头比较一致则节点不移动":["35.3"],"如果头尾比较一致则节点移动":["35.3"],"指向新的一组子节点的最后一个节点":["35.4"],"然后比较两个指向的新旧节点":["35.4"],"如果相同指向":["35.4"],"直到两个节点不同时结束后置节点的处理":["35.4"],"处理新旧两个组子节点中相同的前置节点和后置节点":["35.4"],"处理完后":["35.4"],"如果剩余节点无法简单的通过挂载新节点或者卸载已经不存在的节点来完成更新":["35.4"],"则需要根据节点的索引关系":["35.4"],"构建出一个最长递增子序列":["35.4"],"最长递增子序列所指向的节点即为不需要移动的节点":["35.4"],"还定义了一个变量patched用于记录":["35.5"],"然后遍历新的一组子节点":["35.5"],"构建key与index的映射表":["35.5"],"最后遍历老的一组节点":["35.5"],"去映射表中寻找":["35.5"],"转换成react":["35.6"],"复杂的组件层次结构":["36.1"],"随着组件复杂度的增加":["36.1"],"对应关系":["36.2"],"在调用时按顺序加入数组中":["36.2"],"如果使用循环":["36.2"],"条件或嵌套函数很有可能导致数组取值错位":["36.2"],"勾出state":["36.3"],"中需要传递一个初始值":["36.3"],"这个值就是你希望在变量中存储的值":["36.3"],"在react中我们通过setstate":["36.3"],"该函数会在":["36.4","38.1"],"还是放到一个updatequeue中延时更新":["36.5","38.2"],"默认是":["36.5","38.2"],"会触发batchedupdates把":["36.6","38.3"],"isbatchingupdates":["36.6","38.3"],"修改为":["36.6","38.3"],"对于每一个":["36.7"],"effect":["36.7","45.18"],"callback":["36.7"],"会向":["36.7"],"settimeout回调函数一样":["36.7"],"放入任务队列":["36.7"],"等到主线程任务完成":["36.7"],"更新":["36.7","45.24"],"更新之后":["36.8"],"浏览器绘制之前":["36.8"],"这样可以方便修改":["36.8"],"div":["36.9","44.10","44.32"],"通过provider给子组件提供":["36.9"],"创建的内容":["36.9"],"在子组件通过":["36.9"],"拿到父组件提供的内容":["36.9"],"usereducer":["36.9"],"类似redux":["36.9"],"在某些场景下":["36.9"],"通过使用":["36.10"],"我们可以将函数缓存起来":["36.10"],"只在依赖的状态":["36.10"],"发生变化时才重新创建新的函数实例":["36.10"],"memo":["36.11"],"从而避免不必要的重复计算":["36.12"],"提高组件性能":["36.12"],"然后在":["36.13"],"浅比较":["36.14"],"来比较组件接收的":["36.14"],"是否发生变化":["36.14"],"只有在":["36.14"],"去包裹一下":["36.15"],"那么对浏览器的开销就会很大":["36.15"],"本末倒置了":["36.15"],"项目中可以针对刷新频率高的组件":["36.15"],"根据实际情况":["36.15"],"进行优化":["36.15"],"是对":["36.15"],"可以用来获取函数组件中的":["36.16"],"元素的引用":["36.16"],"mycomponent":["36.16"],"关联到一个组件上时":["36.17"],"将提供对该组件实例的引用":["36.17"],"在函数组件中":["36.17"],"没有组件实例的概念":["36.17"],"但当使用":["36.17"],"forwardref":["36.17","36.18"],"将":["36.17","44.13"],"组件在":["36.19"],"和并发模式":["36.20"],"concurrent":["36.20"],"transtion":["36.21"],"但是页面不会刷新":["37.1"],"browserrouter":["37.2"],"hashrouter":["37.2"],"事件":["37.3"],"无需在":["37.3"],"中包含哈希":["37.3"],"字符":["37.3"],"更加直观和美观的":["37.3"],"默认值为false":["37.4"],"false时":["37.4"],"会匹配到以":["37.4"],"结尾的路径":["37.4"],"path设置为":["37.4"],"默认情况下":["37.4"],"也会导致组件挂载":["37.4"],"设置为true时":["37.4"],"结尾的路径不会被匹配":["37.4"],"就会执行跳转到对应的to路径中":["37.5"],"uselocation":["37.7"],"新记录添加":["37.8"],"replace":["37.8"],"历史记录被替换":["37.8"],"location":["37.8"],"location对象":["37.8"],"添加新的历史记录":["37.8"],"略":["37.9"],"route":["37.9","37.17"],"path":["37.9","37.17","43.6"],"why":["37.10"],"hash":["37.10"],"hash字符串":["37.10"],"获取当前路由匹配的信息":["37.11"],"有isexact":["37.11"],"nomatch":["37.12"],"而是必须要放到routes组件中":["37.13"],"匹配到的则显示":["37.14"],"其余route则不再继续匹配":["37.14"],"studentlist":["37.15"],"并返回有关匹配的信息":["37.16"],"当您需要手动运行路由器的匹配算法以":["37.16"],"确定路由路径是否匹配":["37.16"],"somewhere":["37.17"],"home":["37.17","43.6"],"错误的使用":["37.17"],"它的":["37.18"],"to":["37.18"],"query":["37.18","43.15"],"其中属性to代替a标题的href属性":["37.19"],"navlink是在link基础之上增加了一些样式属性":["37.19"],"handlesomething":["38.0"],"假设":["38.0"],"从":["38.0"],"重新渲染该组件时":["38.0"],"child":["38.4"],"在同一个":["38.4"],"click":["38.4"],"传递给组件":["38.5"],"类似于函数的形参":["38.5"],"是在":["38.5"],"组件内被组件自己管理":["38.5"],"的数据无效":["38.6"],"判断如果props发生改变":["38.7"],"keys":["38.7"],"isfirstrender":["38.8"],"setisfirstrender":["38.8"],"代理":["39.1"],"vue能准确知道视图模版中哪一块用到了这个数据":["39.2"],"可以自动找到引用组件进行渲染":["39.2"],"指令":["39.3"],"最长递增子序列":["39.4"],"新state替换旧state":["39.5"],"自顶向下的含义是":["40.1"],"找出变动的部分":["40.2"],"action":["41.0","41.1","44.34","52.5"],"来触发状态的变化":["41.0"],"一个js对象":["41.0"],"的唯一途径":["41.1","52.5"],"动作":["41.1","52.5","52.6"],"可预测":["41.3"],"predictable":["41.3"],"redux是一个状态容器":["41.3"],"所以使用redux必须先创建容器对象":["41.3"],"它的所有操作都是通过容器对象来进行的":["41.3"],"这个方法可以帮助获取":["41.4"],"里边所有的数据内容":["41.4"],"subscrible":["41.4"],"方法订阅":["41.4"],"payload":["41.5"],"default":["41.5","50.2","79.0"],"schoolreducer":["41.5"],"做一些其他操作":["41.6"],"也就是说":["41.6"],"它":["41.6"],"改变的是执行dispatch到":["41.6"],"reducer":["41.6"],"的流程":["41.6"],"redux":["41.6"],"dispatch":["41.7"],"thunk":["41.8"],"异步处理中间件":["41.8"],"middleware2":["41.9"],"定义联合类型":["42.1"],"函数表达式":["42.2"],"else":["42.3","51.7","59.4","67.6","71.5","71.14"],"默认参数":["42.3"],"semlinker":["42.6"],"loopforever":["42.8"],"任何类型都可以被归为":["42.9"],"大object":["42.11"],"代表所有拥有":["42.11"],"tostring":["42.11"],"hasownproperty":["42.11"],"方法的类型":["42.11"],"所以所有原始类型":["42.11"],"strlength":["42.13"],"和非":["42.14"],"ts":["42.15","42.30"],"对应的字符串字面量":["42.16"],"数字字面量":["42.16"],"布尔字面量分别拥有与其值一样的字面量类型":["42.16"],"它是对行为的抽象":["42.18"],"而具体如何行动需要由类":["42.18"],"还提供了":["42.19"],"readonlyarray":["42.19"],"t":["42.19"],"它与":["42.19"],"propname":["42.20"],"any":["42.20"],"tom":["42.20"],"ok":["42.21"],"money":["42.23"],"和为你的":["42.24"],"代码或第三方代码":["42.24"],"定义数据模型":["42.24"],"y":["42.25"],"partialpointx":["42.26"],"interface":["42.27","42.28","42.30","42.32"],"point":["42.27","42.28"],"pointx":["42.28"],"identity":["42.29"],"arg":["42.29","42.32"],"实现这个接口即可":["42.30"],"sizeable":["42.30"],"可以用":["42.32"],"声明一个类型变量并且对它进行使用":["42.32"],"returntype":["42.32"],"r":["42.32"],"有时候我们定义的泛型不想过于灵活或者说想继承某些类等":["42.32"],"可以通过":["42.32"],"关键字添加泛型约束":["42.32"],"lengthwise":["42.32"],"length":["42.32","59.4","59.10","66.1","66.2","66.3","66.4","72.4","72.7","72.9","72.10","74.2","76.5","88.1"],"loggingidentity":["42.32"],"url后面会带有":["43.2"],"号":["43.2"],"history模式则是通过监听popstate事件来实现更新页面部分内容的操作原理和hash模式差不多":["43.2"],"浏览器地址改变":["43.3"],"当浏览器向服务器发送请求时":["43.4"],"只会把":["43.4"],"的方式会导致浏览器向服务器发送请求":["43.5"],"但是history":["43.5"],"模式可以传输复杂一些的数据":["43.5"],"而且比hash模式美观":["43.5"],"to目标路由对象":["43.7"],"from当前导航正要离开的路由对象":["43.7"],"next函数":["43.7"],"全局解析守卫beforeresolve":["43.7"],"和beforeeach类似":["43.7"],"区别是在导航被确认之前":["43.7"],"同时在所有组件内守卫和异步路由":["43.7"],"组件被解析之后调用":["43.7"],"守卫会在导航被确认之前被调用":["43.7"],"解析异步路由组件":["43.8"],"在重用的组件里调用":["43.8"],"beforerouteupdate":["43.8"],"解决白屏问题":["43.9"],"调用import":["43.10"],"require":["43.11"],"放入需要加载的路由地址":["43.11"],"谁可以访问路由等":["43.12"],"你需要从服务器获取用户的数据":["43.13"],"我们可以通过两种方式来实现":["43.13"],"查询参数":["43.14","43.15"],"是通过":["43.15"],"响应式数据绑定":["44.1"],"single":["44.2"],"page":["44.2"],"created":["44.3","52.0"],"实例创建后":["44.3","52.0"],"beforemount":["44.3","52.0"],"你可以使用onbeforemount和onmounted这两个函数来模拟beforecreate和created的行为":["44.4"],"以确保在组件挂载到dom之前":["44.5"],"数据和组件状态已经准备就绪":["44.5"],"mounted":["44.5"],"onmounted":["44.5"],"dom挂载完成":["44.5"],"可以":["44.5"],"子created":["44.6"],"子beforemount":["44.6"],"子mounted":["44.6"],"父mounted":["44.6"],"if表示一个dom元素是否被创建":["44.8"],"vue2中v":["44.9"],"for的优先级会更高":["44.9"],"template":["44.10"],"addsum":["44.10"],"例如data属性或其他computed属性":["44.12"],"vue":["44.12","44.25","44.51","44.52","45.23","46.6"],"无法正确地追踪依赖关系和触发更新":["44.13"],"如果计算属性中使用异步操作":["44.13"],"computed不支持异步":["44.14"],"watcher":["44.15","44.53"],"属性":["44.16"],"为每个computed属性都创建一个watcher":["44.17"],"对每个computed属性进行get劫持":["44.17"],"get劫持是最关键的步骤":["44.17"],"并且在通过":["44.18"],"vue2":["44.18"],"proxy":["44.18"],"一样":["44.19"],"也是一个监听器":["44.20"],"它只接收一个回调函数":["44.20"],"options":["44.21"],"api中methods":["44.21"],"compute":["44.21"],"data等api都是分散的":["44.21"],"而composition":["44.21","51.3"],"会将":["44.22"],"中的数据转换为响应式数据":["44.22"],"这意味着当数据发生变化时":["44.22"],"相关的视图将自动更新":["44.22"],"方法来劫持对象的属性":["44.23"],"watcheffect的数组侦听":["44.24"],"当我们使用":["44.25"],"具名插槽顾名思义就是具有名字的插槽":["44.26"],"子组件中可以用name熟悉对slot命名":["44.26"],"父组件在使用的时候":["44.26"],"一定要通过template":["44.26"],"中的v":["44.26"],"name或者":["44.26"],"name来定义这个插槽中的内容":["44.26"],"inject":["44.27"],"子传父":["44.27"],"emit":["44.27"],"bind给子组件传值":["44.28"],"就可以使父组件的func执行":["44.29"],"这意味着通过ref可以直接访问子组件的":["44.31"],"属性和方法":["44.31"],"并在父组件中与子组件进行交互":["44.31"],"子":["44.32"],"vuex有三个核心的概念":["44.33"],"mutations":["44.33"],"actions":["44.33","44.34","44.35","52.6"],"修改state":["44.34"],"建议通过":["44.34"],"去修改":["44.34"],"里可以直接通过":["44.34"],"访问":["44.34"],"definestore":["44.35"],"setdata":["44.35"],"将其包裹的话这个组件就会被缓存":["44.37"],"当这个组件再一次被显示时就会保留之前的状态":["44.37"],"alive就不会调用beforedestroy":["44.39"],"一个混入对象可以包含任意组件选项":["44.40"],"当组件使用混入对象时":["44.40"],"所有混入对象的选项将被":["44.40"],"只能代理属性":["44.41"],"代理的是对象":["44.41"],"要去的位置":["44.43"],"和disabled":["44.43"],"是否留在原位置":["44.43"],"它一般用于包裹多个异步组件处理多个异步组件加载前与完成后的统一状态":["44.44"],"更新视图后":["44.46"],"通过回调函数来访问更新后的":["44.46"],"而虚拟dom就是为了减少这些操作的":["44.48"],"虚拟dom首先会通过状态生成一个虚拟节点树":["44.48"],"也就是通过移动代替新增":["44.49"],"两棵树的":["44.49"],"js会销毁旧的虚拟dom树及其对应的真实dom":["44.50"],"并将新的虚拟dom树转换为真实dom":["44.50"],"插入到dom树中":["44.50"],"接收":["44.51"],"可透传":["44.51"],"在上级组件中的属性可以直接传给最底层的根组件":["44.51"],"最底层的根组件可以直接接收到父组件的属性":["44.51"],"父组件":["44.51"],"father":["44.51"],"如果":["44.53"],"同一个":["44.53"],"被多次触发":["44.53"],"只会被推入到队列中一次":["44.53"],"并等待下一次dom更新循环":["44.53"],"key是为了让diff算法更精准的识别到新旧dom的差异的节点":["44.54"],"判断元素是新创建的还是被移动的元素":["44.54"],"default和":["44.55"],"fallback":["44.55"],"reactive适合复杂数据类型的对象将其包装成响应式对象":["44.56"],"h1":["44.57"],"content":["44.57"],"view层不能直接修改state":["44.59"],"必须要通过actions来进行操作":["44.59"],"这样更加清晰可控":["44.59"],"但是vue和react父子组件之间数据传递":["44.60"],"仍然还是遵循单向数据流的":["44.60"],"父组件可以向子组件传递props":["44.60"],"资源是否重复发送请求去加载了":["44.61"],"合理利用localstorage":["44.62"],"ui框架按需加载":["44.62"],"公共的文件应该以绝对路径的方式从根目录引用":["44.63"],"外的文件不应该被引入":["44.63"],"标签编写样式":["44.64"],"在观察者模式中":["45.2"],"只有两种主体":["45.2"],"目标对象":["45.2"],"通过发布主题事件的方式通知各个订阅该主题的":["45.3"],"发布订阅模式中有三个角色":["45.3"],"进行操作代理定义":["45.4"],"enumerable":["45.4","45.15"],"configurable":["45.4","45.15"],"值的读取操作":["45.4"],"进行依赖收集":["45.4"],"depend":["45.4"],"值的更新操作":["45.4"],"触发依赖更新":["45.4"],"newval":["45.4"],"初始化数据":["45.5"],"computed":["45.5"],"数据过程中":["45.5"],"val":["45.7","67.2","67.6"],"修改":["45.8"],"observe":["45.8"],"如果obj内有嵌套的属性呢":["45.9"],"我们可以使用递归来完成嵌套属性的数据劫持":["45.9"],"入口函数":["45.9"],"调用observer":["45.9"],"以array":["45.10"],"依赖":["45.11"],"此时watcher在dep集合里":["45.11"],"dep使用发布订阅模式":["45.11"],"setter方法":["45.12"],"通知watcher":["45.12"],"watcher能够控制自己属于哪个":["45.13"],"是data中的属性的还是watch":["45.13"],"或者是computed":["45.13"],"watcher自己有统一的更新入口":["45.13"],"只要你通知它":["45.13"],"就会执行对应的更新方法":["45.13"],"watcher必须要有的2个方法":["45.13"],"一个就是通知变化":["45.13"],"另一个就是被收集起来到dep中去":["45.13"],"constructor":["45.13","86.2"],"dep收集到了一个依赖watcher":["45.14"],"这个依赖就是用来管理data中数据变化的":["45.14"],"使用watch时":["45.14"],"自定义的监听某个data中属性的变化":["45.14"],"属性变化时通知watch执行回调函数":["45.14"],"dep收集到了第二个个依赖":["45.14"],"第二个依赖就是用来管理watch中message变化的":["45.14"],"所有才会导致":["45.16"],"没有在":["45.16"],"中进行声明的对象属性直接赋值时无法触发视图更新":["45.16"],"reflect":["45.17","45.19"],"receiver":["45.19","45.32"],"res":["45.19","53.30","86.1"],"fn":["45.20"],"创建一个内部的副作用函数":["45.20"],"然后立即执行":["45.20"],"此时会触发对象的":["45.20"],"depsmap":["45.21","45.29"],"通过一个副作用":["45.23"],"方法调用之外":["45.24"],"对整个对象的新增":["45.24"],"至于":["45.25"],"shallowreadobly":["45.25"],"的话":["45.25"],"其实就是读取什么返回什么":["45.25"],"基本没有别的处理了":["45.25"],"接受一个内部值":["45.25"],"返回一个响应式的":["45.25"],"可更改的":["45.25"],"refimpl":["45.26"],"类型的实例":["45.26"],"其中的":["45.26"],"就保存响应式数据":["45.26"],"并定义了对象的":["45.26"],"函数收集起来放进dep里":["45.27"],"track":["45.28","45.32"],"activeeffect":["45.28"],"targetmap":["45.29"],"访问时收集依赖":["45.32"],"所以实际是访问的值是receiver的key的值":["45.33"],"但是这可不是直接访问":["45.33"],"在proxy里使用reflect会提高语义化":["45.34"],"v":["46.0","50.3"],"钩子函数对象":["46.2"],"我们会在下面介绍":["46.2"],"全局注册app":["46.2"],"createapp":["46.2"],"绑定元素的父组件卸载后调用":["46.3"],"unmounted":["46.3"],"钩子参数el":["46.3"],"指令绑定到的元素":["46.3"],"这可以用于直接操作":["46.3"],"一个对象":["46.3"],"包含以下属性":["46.3"],"attributes":["46.4"],"没有要复制的内容":["47.0","63.0"],"textarea":["47.0","63.0","80.8"],"document":["47.0","63.0"],"readonly":["47.0","63.0"],"进行双向绑定":["50.1"],"input输入值时":["50.1"],"有关当前row的data就会绑定一个inputvalue值":["50.1"],"field":["50.1"],"row":["50.2"],"inspectionlist":["50.2"],"inspectionid":["50.2"],"grid":["50.3"],"ref":["50.3"],"ruletype":["50.3"],"bind":["50.3"],"ruleoptions":["50.3"],"showaddandeditmodal":["50.4"],"close":["50.4"],"rulelistorigin":["50.4"],"rulelist":["50.4"],"图表":["51.0"],"轮播图等等":["51.0"],"一致的设计语言":["51.0"],"版本控制":["51.1"],"rest":["51.2"],"api中的代码是根据逻辑功能来组织的":["51.3"],"我们可以将一个功能所定义的methods":["51.3"],"data等api会放在一起":["51.3"],"让我们可以更灵活地组合组件逻辑":["51.3"],"对模块进行打包和转换":["51.5"],"导致构建速度较慢":["51.5"],"实例并将其":["51.6"],"token":["51.6"],"parent":["51.7","71.12"],"如果没有父节点":["51.7"],"说明是根节点":["51.7"],"直接放入树结构":["51.7"],"输入":["51.7"],"arrr":["51.7"],"实例创建前":["52.0"],"或者beforerouter":["52.1"],"里面就可以":["52.1"],"别的组件访问不到":["52.2"],"拦截操作":["52.3"],"attrs":["52.4"],"listeners":["52.4"],"无":["52.4"],"合并到":["52.4"],"并在属性变化时执行特定的操作":["52.7"],"computed属性是基于它们的依赖进行缓存的":["52.7"],"声明的是变量":["53.2"],"const声明的是常量":["53.2"],"引用类型地址和基本类型存放在栈里":["53.2"],"当函数执行完毕后":["53.2"],"4ms延时":["53.3"],"同步任务执行完会在异步任务队列里拿任务":["53.4"],"可靠":["53.5"],"ssl":["53.7"],"tsl加密":["53.7"],"pending":["53.8"],"反射性":["53.9"],"表单提交":["53.9"],"man":["53.12"],"遍历当前元素的子元素":["53.13"],"children":["53.13"],"newremaining":["53.14","59.9"],"它通过js来操作像素":["53.16"],"max":["53.19"],"使得每个进程都认为它拥有连续的私有内存空间":["53.20"],"存储临时数据":["53.22"],"一个进程可以有多个线程":["53.23"],"分别执行不同的任务":["53.23"],"主进程":["53.23"],"渲染进程":["53.23"],"料到字节有补充追问的习惯":["53.25"],"需要缓存":["53.26"],"是否缓存过":["53.26"],"没有则加到存储缓存组件的对象this":["53.26"],"cache中":["53.26"],"arr":["53.30","75.11","75.12","77.0"],"dns查询ip地址":["53.34"],"control设置一个相对时间最大缓存时间max":["53.35"],"客户端和服务器之间建立一次连接后保持打开状态":["53.36"],"你怎么排查原因":["53.37"],"环境差异":["53.37"],"这道题讨论了40分钟":["53.38"],"visualstudio":["55.0"],"com":["55.0"],"open":["55.1"],"node才好用":["55.2"],"setarr":["56.0"],"而computed是在依赖的数据发生变化时才进行计算":["56.2"],"并将计算结果缓存起来":["56.2"],"只有在依赖的数据发生变化时":["56.2"],"表单输入验证":["56.3"],"在表单中":["56.3"],"可以使用watch来监听输入字段的变化":["56.3"],"并根据输入的值进行验证或格式化":["56.3"],"当用户输入发生变化时":["56.3"],"可以立即进行验证并给出实时反馈":["56.3"],"flex或inline":["56.6"],"flex设置":["56.6"],"relative":["56.10"],"元素的定位相对于其正常位置进行偏移":["56.10"],"但仍然保留其原有的空间占位":["56.10"],"元素的定位相对于其最近的已定位":["56.10"],"非":["56.10"],"组件中的传递是单向的":["56.11"],"从父组件向子组件传递":["56.11"],"继续执行其他任务":["56.12"],"从而避免阻塞":["56.12"],"提升性能和响应性":["56.12"],"使用promise可以更好地组织和控制异步操作的流程":["56.13"],"使代码更具可读性和可维护性":["56.13"],"链式调用":["56.13"],"异步任务":["56.14"],"是在特定条件下触发并在后台执行的任务":["56.14"],"触发和执行是非阻塞的":["56.14"],"通常是一些比较耗时的任务":["56.14"],"不断地从任务队列中取出任务":["56.15"],"timmer":["59.1"],"temmer":["59.2"],"stringify":["59.5"],"typeerror":["59.8"],"获取参数":["59.8"],"dp":["59.10"],"onfulfilled":["60.0"],"onrejected":["60.0"],"dep":["62.0"],"current":["65.1","71.15","72.6","72.8"],"o":["65.3","65.4"],"math":["66.4","69.5"],"floor":["66.4"],"pivotvalue":["66.5"],"splice":["66.5"],"两个指针next":["67.1"],"和head":["67.1"],"next指向head的下一个节点":["67.1"],"循环第一步temp":["67.1"],"next其实没有值":["67.1"],"temp":["67.3","69.5"],"cur":["67.3","77.3"],"val头结点的值":["67.7"],"判断是否是修改":["69.2"],"limit":["69.3"],"bucket":["69.3"],"storage":["69.3"],"parseint":["69.5"],"getprime":["69.6"],"resize":["69.7"],"newlimit":["69.7"],"oldstorage":["69.7"],"isempty":["70.0"],"tree":["71.1"],"也称二叉排序树或二叉查找树":["71.1"],"二叉搜索树是一颗二叉树":["71.1"],"相对较大的值总是保存在右结点上":["71.2"],"如果结点存在":["71.3"],"则返回true":["71.3"],"如果不存在":["71.3"],"则返回false":["71.3"],"指向的右子树":["71.4"],"对于binaryserachtree来说":["71.4"],"只需要保存根结点即可":["71.4"],"insertnode":["71.5"],"root":["71.7","71.8","71.12"],"left":["71.10"],"isleftchild":["71.12"],"只是清空了根":["71.13"],"因为只有它":["71.13"],"否则就把父节点的left或者right字段设置为null即可":["71.13"],"剪短":["71.14"],"让爷爷直接连接儿子即可":["71.14"],"这个过程要求改变父节点的left或者right":["71.14"],"指向要删除节点的子节点":["71.14"],"当然":["71.14"],"在这个过程中还要考虑是否current就是根":["71.14"],"getsuccessor":["71.15"],"delnode":["71.15"],"successor":["71.15"],"successorparent":["71.15"],"情况2":["71.16"],"非叶子结点":["71.16"],"只有一个节点":["71.16"],"右为空":["71.16"],"第一个节点为空":["72.2"],"把新节点放在第一个节点":["72.2"],"情况一":["72.4","72.12"],"把插入的data放在首位":["72.4","72.12"],"新插入的newnode":["72.4","72.11","72.12"],"next指向原来的第一个":["72.11","72.12"],"head指向新插入的":["72.11","72.12"],"情况二":["72.11","72.12"],"后一个":["72.11","72.12"],"prev":["72.11","72.12"],"前一个":["72.11","72.12"],"从头开始找位置":["72.11","72.12"],"priorityqueue":["73.1","73.2"],"创建一个内部类":["73.1"],"queueelement":["73.1","73.2"],"priority":["73.1","73.2"],"enqueue":["73.1","74.2"],"dequeue":["74.1"],"不改变原数组":["75.5","75.6"],"里面是一个值":["75.6"],"result12":["75.7"],"返回true或false":["75.8"],"arr8":["75.10"],"方法":["75.12"],"但比分别调用这两个方法稍微更高效一些":["75.12"],"它返回修改后的数组":["75.13"],"改变原数组":["75.13"],"填充一个数到最后":["75.13"],"result15":["75.13"],"result13":["75.14"],"foobar":["75.15"],"result16":["75.15","76.1"],"创建一个具有单个元素":["75.16"],"的数组":["75.16"],"arr4":["75.18"],"arr5":["75.19","75.22","75.23"],"有着和":["75.20"],"shift相似的行为":["75.20"],"但是是作用在数组的最后一个元素上的":["75.20"],"arr15":["75.21"],"result21":["75.22"],"result23":["75.23"],"arr6":["75.24"],"累加":["75.25"],"arr9":["75.26"],"arr10":["75.27"],"包括":["75.28"],"不包括end":["75.28"],"原始数组不会被改变":["75.28"],"arr13":["75.29"],"arr14":["75.30"],"例如一个逗号":["75.31"],"隔开":["75.31"],"arr17":["75.32"],"split":["76.2"],"foreach":["76.6"],"item":["76.6"],"reduce":["77.1","77.2"],"pre":["77.1","77.2","77.3"],"result5":["77.5"],"流光按钮":["78.1","78.4"],"plain":["79.1","84.1"],"btn":["79.3"],"在组件内挂载之后只需要引用下面这行代码":["79.3"],"事例":["79.4"],"l":["79.4","79.5","79.6","79.7","79.8","84.1","84.2","88.1"],"button":["79.5","79.6","79.7","79.8","84.1","84.2"],"type":["79.5","79.6","79.7","79.8","80.5","80.8","84.1","84.2"],"例如上面展示的效果":["79.8"],"primary":["79.8"],"请输入内容":["80.1","80.2"],"placeholder":["80.2","80.5"],"clearable":["80.4"],"showpassword":["80.5"],"http":["80.7"],"linput":["80.8"],"award":["82.1"],"auction":["82.1"],"aixin":["82.1","82.10"],"会在图标右上角展示相应的徽标":["82.4"],"licon":["82.5"],"artboard":["82.9"],"fanhui":["82.12"],"arrow":["82.12"],"guanbi":["82.14"],"shuaxin":["82.15"],"sousuo":["82.15"],"shangchuan":["82.16"],"bangzhu":["82.16"],"underline":["83.1"],"这是超链接":["83.1"],"disabled":["83.2"],"禁用超链接":["83.2"],"drag":["84.2"],"那么table剩余的宽度会被其他的td平均分":["85.2"],"有点类似flex布局":["85.2"],"给table设置的高度起到的作用只是min":["85.2"],"height的作用":["85.2"],"当内容的高度高于设置的高度时":["85.2"],"table的高度会被撑高":["85.2"],"tr标签":["85.2"],"call":["85.3"],"telphone":["85.5"],"rehect":["85.9"],"所以要过渡某些属性":["85.14"],"首先需要将其重置成具体数字值":["85.14"],"change事件和inpute事件":["85.15"],"mypromise":["86.2"],"面试题":["90.0"],"代码手撕":["90.0","91.0"],"等不及了从这里开始你的":["91.0"]},{"0":["1.1","1.13","11.26","16.11","16.25","16.42","16.50","19.42","21.9","34.4","50.3","66.5","69.2","72.6"],"1":["3.12","5.2","9.5","9.33","11.3","14.14","16.18","16.24","16.36","16.42","22.2","26.5","35.1","41.6","44.40","45.5","59.8","67.2","71.7","71.8","71.9","72.11","72.12","74.2","75.17","75.20","75.28","75.31","85.4"],"2":["3.2","5.14","6.11","6.15","6.17","8.1","9.19","9.26","11.22","14.4","16.16","19.12","19.14","19.30","19.31","21.9","21.10","22.2","30.1","30.5","30.9","38.5","44.13","45.5","45.34","50.2","51.7","53.19","56.13","70.1","75.11","75.12","75.17","75.20","75.27","75.28","75.31","77.0","85.12"],"3":["3.6","6.9","6.14","9.25","10.1","11.7","11.16","15.7","16.8","16.35","19.50","21.0","21.5","22.2","22.11","28.10","28.16","32.0","32.4","35.2","35.4","38.0","41.2","43.6","44.33","44.49","44.60","46.3","51.0","51.3","51.7","56.0","56.2","56.3","56.14","75.10","75.11","75.12","75.17","75.18","75.19","75.21","75.26","75.27","75.30","75.31","76.0","77.0","85.17"],"4":["3.15","5.7","5.17","6.9","10.2","14.3","15.7","16.3","16.4","20.3","21.8","26.1","28.16","30.8","34.15","34.22","44.1","45.11","45.14","51.7","53.34","55.1","75.10","75.11","75.18","75.19","75.21","75.26","75.27","75.29","75.30","75.32"],"5":["5.17","16.11","19.22","19.76","20.3","44.24","51.7","75.1","75.2","75.3","75.10","75.13","75.18","75.19","75.21","75.26","75.29","75.30","75.32"],"6":["24.3","28.2","42.32","75.1","75.2","75.3","75.10","75.19","75.21","75.26","75.29","75.30","75.32"],"7":["8.2","25.1","75.1","75.2","75.3","75.26","75.29"],"8":["8.2","11.3","14.3","43.8","75.1","75.2","75.3","75.29","86.1"],"9":["11.26","43.8","75.29"],"10":["11.14","11.24","14.2","16.22","16.35"],"11":["16.35"],"16":["11.3"],"18":["37.12"],"24":["4.0"],"35":["42.32"],"42":["20.8","20.10","20.25"],"50":["16.5"],"93":["51.3"],"118":["16.16"],"123":["42.10"],"305":["9.23"],"307":["9.23"],"400":["9.23"],"401":["9.23"],"403":["9.23"],"600":["50.3"],"2000":["14.6","14.10"],"2010":["14.4"],"2017":["16.46"],"2023":["14.6","14.10"],"3000":["53.12"],"90000":["16.50"],"123456":["14.6"],"javascript":["0.1","5.2","5.3"],"method":["0.2","17.13","29.4"],"post":["0.2","9.18"],"headers":["0.2","0.8"],"content":["0.2","1.2","1.11","9.19","44.26"],"type":["0.2","9.19","41.0","42.28"],"application":["0.2","9.28","44.2"],"body":["0.2","5.19"],"stringify":["0.2","70.0"],"title":["0.2","50.1"],"双层厚牛堡":["0.2"],"desc":["0.2"],"百分百和牛与香软芝士融为一体配合美味番茄醬丰富口感一咬即刻涌现":["0.2"],"post比get安全":["0.4"],"因为post参数在请求体中":["0.4"],"get参数在url上面":["0.4"],"get传输速度比post快":["0.4"],"子域名不同":["0.5"],"baidu":["0.5"],"a":["0.6","1.25","3.8","6.3","11.19","16.35","20.8","22.1","27.0","42.19","45.7","51.7","76.7"],"com":["0.6"],"只允许所有域名访问":["0.6"],"限制":["0.6"],"浏览器需要支持html5":["0.6"],"可以支持post":["0.6"],"put等方法兼容ie9以上":["0.6"],"代理":["0.6"],"代理是一种常用的解决跨域请求的方法":["0.6"],"它通过在服务器端设置一个代理":["0.6"],"将客户端请求发送给目标服务器":["0.6"],"并将响应返回给客户端":["0.6"],"客户端只与代理服务器交互":["0.6"],"而代理服务器则与目标服务器交互":["0.6"],"代理服务器是一种位于客户端和目标服务器之间的中间层服务器":["0.6"],"当客户端请求目标服务器的资源时":["0.6"],"请求会先发送到代理服务器":["0.6"],"代理服务器再将请求发送到目标服务器":["0.6"],"然后将响应返回给客户端":["0.6"],"通过这种方式":["0.6"],"代理服务器可以绕过浏览器的同源策略限制":["0.6"],"从而实现跨域请求":["0.6"],"react反向代理":["0.6"],"访问地址":["0.6"],"https":["0.6","6.20"],"i":["0.6","16.42","29.10","59.10","61.0","66.4","69.2","73.1","73.2","76.4","88.1"],"maoyan":["0.6"],"interceptors":["0.8"],"request":["0.8","9.16"],"use":["0.8","20.26","32.5","44.25"],"config":["0.8"],"const":["0.8","3.6","20.30","21.2","22.7","34.4","36.17","42.10","42.32","45.22","46.2","53.17","59.8","78.2","79.2","82.2"],"token":["0.8","5.2","30.8"],"localstorage":["0.8"],"getitem":["0.8"],"从本地存储中获取token":["0.8"],"if":["0.8","16.41","16.46","16.50","17.12","17.13","38.8","45.29","59.1","67.2","67.3","67.5","69.3","71.7","71.8","71.9","71.12","71.15","72.9","73.1","76.5","76.6"],"authorization":["0.8"],"bearer":["0.8"],"return":["0.8","16.36","41.10","42.10","42.29","45.28","45.32","50.2","65.3","67.4","67.5","69.3","71.10","72.5","72.7","77.1","77.2"],"error":["0.8","42.10"],"状态码":["0.9"],"根据接口返回的不同status":["0.9"],"来执行不同的业务":["0.9"],"axios":["0.10"],"relative":["1.1","2.10"],"absolute":["1.1"],"top":["1.1","47.0","63.0"],"display":["1.2","6.10"],"table":["1.2"],"float属性不是none":["1.3"],"position为absolute或者fixed":["1.3"],"display为inline":["1.3"],"性能消耗较少":["1.5"],"是继承属性":["1.5"],"子孙节点消失由于继承了hidden":["1.5"],"通过设置visibility":["1.5"],"visible":["1.5"],"可以让子孙节点显式":["1.5"],"fixed":["1.6","47.0","63.0"],"同时":["1.6"],"不可交互":["1.7"],"注意":["1.7","59.5"],"此方法对行内元素无效":["1.7"],"它是一个绝对单位":["1.8"],"em是一个相对长度单位":["1.8"],"width":["1.9"],"可视窗口宽度":["1.9"],"html":["1.10","56.10"],"font":["1.10","28.13"],"size":["1.10","16.50","42.30","74.2"],"16px":["1.10"],"flow":["1.11"],"justify":["1.11"],"align":["1.11","50.1"],"items":["1.11","1.26"],"grow":["1.12"],"设置了对应元素的增长系数":["1.12"],"相当于可扩大":["1.13","1.14"],"可缩小":["1.14"],"相当于不可扩大":["1.15","1.16"],"auto":["1.16"],"和":["1.17","8.2","44.37","45.2","46.3","85.11"],"列":["1.17"],"产生了一个个的网格":["1.17"],"我们可以将网格元素放在与这些行和列相关的位置上":["1.17"],"考虑兼容性":["1.18"],"layer":["1.19"],"这使得被动画元素在一个独立的层中进行动画":["1.19"],"通常情况下":["1.19"],"浏览器会将一个层的内容先绘制进一个位图中":["1.19"],"时该元素的位置并不受到定位影响":["1.20"],"设置是top":["1.20"],"left等属性无效":["1.20"],"当该元素的位置将要移出偏移范围时":["1.20"],"定位又会变成fixed":["1.20"],"布局的内容":["1.21"],"其实就是一个边距的区别":["1.21"],"按水平布局来说":["1.21"],"delay":["1.22","1.27","5.24"],"指定过渡的延迟时间":["1.22"],"关键帧动画":["1.22"],"name":["1.22","4.0","9.13","14.15","16.9","20.30","30.10","37.12","42.32","44.26","50.2","51.7","53.21","82.5"],"指定要绑定到选择器的关键帧的名称":["1.22"],"可以指定一些特定形状":["1.23"],"裁剪一张图像":["1.23"],"行内元素则不会产生换行":["1.24"],"宽度由其内容决定":["1.24"],"不可以设置宽度":["1.24"],"两端对齐":["1.25"],"decoration":["1.25"],"none":["1.25","6.10"],"删除链接的下划线":["1.25"],"div":["1.26","6.18","44.52"],"元素的各项":["1.26"],"iteration":["1.27"],"属性选择器和伪类选择器的权重为10":["1.29","56.16"],"action":["1.30","36.9"],"hover":["1.30"],"选择鼠标悬停在元素上的状态":["1.30"],"active":["1.30"],"选择鼠标点击按下时的状态":["1.30"],"focus":["1.30","36.16"],"选择当前获得焦点的元素":["1.30"],"在元素内容之前插入生成的内容":["1.31"],"after":["1.31"],"偏大或偏小的字体":["1.32"],"文本系列属性":["1.32"],"text":["1.32","2.8","5.18"],"indent":["1.32"],"文本缩进":["1.32"],"vh":["1.33"],"才会开始下载css代码":["1.34"],"再渲染":["1.34"],"判断是否满足媒体查询的条件":["1.35"],"实现一个三角形":["2.0"],"会把视口的宽度平均分为":["2.1"],"给浮动元素父级设置高度":["2.2"],"父级同时浮动":["2.2"],"需要给父级同级元素添加浮动":["2.2"],"父级设置成":["2.2"],"在css中":["2.3"],"有两种盒模型":["2.3"],"标准盒模型和ie盒模型":["2.3"],"标准盒模型的大小计算方式是":["2.3"],"元素的内容区域的大小加上元素的填充":["2.3"],"ie盒模型中内容的宽或高将会包含内边距":["2.4"],"外边距和边框":["2.4"],"box":["2.5"],"触发重排和重绘":["2.6"],"通过visibility":["2.6"],"webp":["2.7"],"格式的浏览器尽量使用":["2.7"],"格式":["2.7"],"origin":["2.8"],"clip":["2.8"],"文本效果":["2.8"],"css":["2.9","85.14"],"media":["2.9"],"screen":["2.9"],"position":["2.10","47.0","63.0"],"双飞翼布局":["2.10"],"浮动":["2.10"],"外边距负值":["2.10"],"双飞翼布局相对于圣杯布局来说":["2.10"],"左右位置的保留是通过中间列的margin值来实现的":["2.10"],"而不是通过父元素的padding来实现的":["2.10"],"模块化规范是":["3.1"],"按需导出与按需导入":["3.3"],"default":["3.4","44.44"],"按需导入时":["3.5"],"只要作用域内存在let":["3.6"],"它们所声明的变量或常量就会自动":["3.6"],"局部作用域":["3.7"],"块级作用域":["3.7"],"this":["3.7","11.14","16.17","16.36","16.45","16.49","17.17","20.15","20.30","42.16","45.13","71.14","72.3","86.2"],"let":["3.8","3.15","22.1","22.3","42.16","42.19","45.27","53.13","70.0","72.5","72.7","75.6","75.8","75.12","75.20","75.28"],"普通函数的this指向":["3.9"],"谁调用指向谁":["3.9"],"创建类的方式":["3.11"],"也可以使用export":["3.12"],"default导出":["3.12"],"函数可以实现惰性计算":["3.14"],"只有当需要获取值时":["3.14"],"异步编程":["3.14"],"指向当前对象的原型对象":["3.15"],"解构赋值":["3.15"],"扩展运算符的应用":["3.15"],"x":["3.15","11.26","16.11","16.33","16.50"],"y":["3.15","11.6","42.26","42.28"],"z":["3.15","27.0"],"getownpropertysymbols":["4.0"],"方法遍历出来":["4.0"],"该方法返回一个数组":["4.0"],"包含了当前对象的所有用作属性名的symbol值":["4.0"],"var":["4.0","19.66","19.67","20.14","53.14","59.9"],"s1":["4.0"],"s2":["4.0"],"b":["4.0","9.19","16.35","20.8","20.25","51.7","76.7"],"江左梅郎":["4.0"],"function":["4.0","5.24","19.71","20.30","36.10","41.10","42.10","42.30","45.25","71.4"],"s":["4.0","11.26","16.41"],"dom":["5.1","5.26","10.1","44.5","44.22"],"提供了对":["5.1"],"需要三个阶段":["5.2"],"通过分词器将字节流转换为":["5.2"],"v8":["5.2"],"编译":["5.2"],"过程中的第一步是做词法分析":["5.2"],"将":["5.2","25.0"],"先分解为一个个":["5.2"],"解析":["5.2","5.4"],"如果要下载javascript代码":["5.4"],"下载过程会阻塞dom":["5.4"],"async":["5.5"],"事件":["5.6"],"解析并执行脚本代码":["5.7","19.50"],"如果script标签引用了外部脚本":["5.8"],"就下载该脚本":["5.8"],"否则就直接执行":["5.8"],"才能继续dom的加载":["5.8"],"外链的js如果含有defer":["5.8"],"true":["5.8","16.17","16.21","16.28","17.12","32.4","42.17","71.11"],"渲染引擎会尽快将内容显示在屏幕上":["5.9"],"样式表构建完毕后才开始构建的":["5.10"],"嵌套标签越多":["5.11"],"操作":["5.12","16.33","45.20"],"内容保存到本地一个":["5.13"],"js":["5.13","19.6","19.66","19.67","19.75","21.2","22.3","22.7","26.5","36.17","43.5","44.43","44.51","71.4","75.6","75.12","78.4","80.1","80.5","82.4","82.8","82.9","82.10","82.11","82.12","82.13","82.14","82.15","82.16"],"对象中":["5.13"],"最终将这个":["5.13"],"对象一次性":["5.13"],"attch":["5.13"],"diff算法比较两棵虚拟":["5.14"],"它定义在":["5.16"],"event":["5.17","5.27","45.3"],"表示事件对象":["5.17"],"包含了与事件相关的信息和方法":["5.17"],"createelement":["5.18"],"tagname":["5.18"],"创建一个指定标签名的元素节点":["5.18"],"createtextnode":["5.18"],"返回文档的主体元素节点":["5.19"],"value":["5.20","9.20","16.32","20.6","20.7","20.26","22.6","30.10","45.4","45.25"],"设置指定属性名的属性值":["5.20"],"返回一个domstringmap对象":["5.21"],"包含了元素的自定义数据属性":["5.21"],"data":["5.21"],"offsetparent":["5.21"],"获取元素的最近的定位":["5.21"],"positioned":["5.21"],"祖先元素":["5.21"],"offsettop":["5.21"],"获取元素相对于offsetparent元素的上边距的距离":["5.21"],"offsetleft":["5.21"],"可以是自定义属性":["5.22"],"setattribute":["5.22"],"以下是一些常见的":["5.23"],"在指定的延迟时间后执行一次指定的函数":["5.24"],"setinterval":["5.24"],"获取关于浏览器的信息":["5.25"],"如浏览器名称":["5.25"],"版本等":["5.25"],"innerwidth":["5.25","19.63"],"它代表了在":["5.26"],"可以是捕获阶段":["5.27"],"capturing":["5.27"],"phase":["5.27"],"立即停止事件的传播":["5.28"],"并阻止事件进一步冒泡或捕获":["5.28"],"在浏览器发展的过程中":["6.1"],"html出现过很多版本":["6.1"],"属性表示网页的标题":["6.2"],"元素则表示层次明确的页面内容标题":["6.2"],"对页面信息的抓取也有很大的影响":["6.2"],"span":["6.3"],"img":["6.3"],"button":["6.3","34.4","79.4"],"input":["6.3","6.4","36.16"],"select":["6.3"],"块级元素":["6.3"],"for":["6.4","16.11","16.15","16.33","16.42","16.50","19.28","22.10","53.13","59.10","66.4","66.5","69.5","69.7","73.1","73.2","76.4"],"male":["6.4","42.20"],"男":["6.4"],"也可以用来发送短信":["6.5"],"description":["6.6"],"方法可以让浏览器识别新的标签":["6.7"],"浏览器支持新标签后":["6.7"],"还可以为新标签添加css样式":["6.7"],"表单控件":["6.8"],"calemdar":["6.8"],"date":["6.8"],"time":["6.8"],"email":["6.8"],"将dom和cssom合并成一棵渲染render树":["6.9"],"大小和位置":["6.11"],"重绘不一定重排":["6.12"],"repaint":["6.13"],"时":["6.13","9.19"],"只需要":["6.13"],"本身":["6.13"],"不会影响到其他的层":["6.13"],"的父层共用一个":["6.14"],"它使用":["6.14"],"gpu":["6.14"],"或":["6.15","9.38","44.53"],"translatey":["6.15"],"元素将会被绘制在普通文档流中":["6.15"],"demo":["6.15"],"这一点浏览器也考虑到了":["6.16"],"因此就有了层压缩":["6.16"],"出现层爆炸的现象":["6.17"],"非语义元素":["6.18"],"提升用户体验":["6.19"],"例如title":["6.19"],"alt可以用于解释名称或者解释图片信息":["6.19"],"src":["6.20"],"www":["6.20"],"example":["6.20"],"搜索引擎优化是一种":["7.1"],"利用搜索引擎的搜索规则来提高目前网站在有关搜索引擎内的自然排名的方式":["7.1"],"关键词":["7.2"],"最多不要超过五个":["7.3"],"有利于提升搜索引擎针对对应关键词的搜索排名":["7.4"],"内容质量":["7.5"],"内容质量不能乱写":["7.5"],"原创":["7.5"],"躲避搜索引擎的文章对比机制":["7.5"],"关键词密度":["7.5"],"所有的属性必须用引号":["8.2"],"括起来":["8.2"],"把所有":["8.2"],"符合规范":["8.3"],"同时提高页面渲染速度":["8.3"],"http服务器则在那个端口监听客户端的请求":["9.1"],"一旦收到请求":["9.1"],"服务器会向客户端返回一个状态":["9.1"],"比如":["9.1","42.17"],"无连接":["9.2"],"每次连接只处理一个请求":["9.2"],"服务器处理完客户请求":["9.2"],"网际协议":["9.3"],"是指能够在多个不同网络间实现信息传输的协议簇":["9.3"],"设置超时等待时间":["9.4"],"数据传输阻塞":["9.4"],"在数据传输过程中":["9.4"],"要比http协议安全":["9.5"],"主要区别":["9.5"],"http的url由":["9.5"],"http":["9.5","33.0"],"服务器收到客户端的请求后":["9.6"],"会将自己的ssl证书发送给客户端":["9.6"],"ssl证书包含了服务器的公钥":["9.6"],"证书的颁发机构和有效期等信息":["9.6"],"客户端验证":["9.6"],"对数据进行加密和解密":["9.7"],"公钥用于加密数据":["9.8"],"2是http":["9.9"],"1的升级版本":["9.9"],"于2015年发布":["9.9"],"它引入了一些重要的改进":["9.9"],"动态表则会根据请求和响应的头部信息动态变化":["9.11"],"头部字段的索引":["9.11"],"在每次请求和响应的头部信息中":["9.11"],"使用索引来引用静态表和动态表中的字段":["9.11"],"客户端":["9.12"],"地址":["9.13","53.21"],"而是一个cname":["9.13","53.21"],"canonical":["9.13","53.21"],"参数":["9.14","37.3"],"向指定资源位置上传其最新内容":["9.16"],"delete":["9.16","22.8"],"请求服务器删除":["9.16"],"uri":["9.16"],"所标识的资源":["9.16"],"options":["9.16"],"使服务器传回该资源所支持的所有http请求方法":["9.16"],"body部分":["9.17"],"按f12也直接暴露了":["9.17"],"所以没啥安全性可言":["9.17"],"get和post有一个重大区别":["9.17"],"简单的说":["9.17"],"get产生一个tcp数据包":["9.17"],"向服务器发送大量数据":["9.18"],"值为页面":["9.19"],"的地址":["9.19"],"host":["9.19"],"请求的主机和端口号":["9.19"],"请求和响应常见通用的":["9.19"],"key":["9.20","14.11","19.28","19.76","20.26","35.5","42.23","45.22","59.4","71.10"],"响应体":["9.21"],"理解":["9.22"],"接收":["9.22"],"3xx":["9.22"],"使用代理":["9.23"],"请求者只能使用代理访问请求的网页":["9.23"],"如果服务器返回此响应":["9.23"],"还表示请求者应使用代理":["9.23"],"临时重定向":["9.23"],"4xx":["9.23"],"客户端错误":["9.23"],"错误请求":["9.23"],"服务器不理解请求的语法":["9.23"],"未授权":["9.23"],"请求要求身份验证":["9.23"],"对于需要登录的网页":["9.23"],"服务器可能返回此响应":["9.23"],"禁止":["9.23"],"服务器拒绝请求":["9.23"],"服务器发送查询请求":["9.25"],"通过网址获取ip地址":["9.25"],"会使用":["9.26"],"dns缓存":["9.27"],"但在这之前":["9.27"],"会向检查域名是否存在本地的":["9.27"],"传输层":["9.28"],"transport":["9.28"],"提供端到端的数据传输服务":["9.28"],"确保数据的可靠传输":["9.28"],"应用层":["9.28"],"进行三次握手判断服务端的接收":["9.33"],"发送能力":["9.33"],"客户端的接收":["9.33"],"发送能力是否是正常的":["9.33"],"会发送":["9.34"],"ack":["9.34"],"表明已经收到客户端的报文了":["9.34"],"此时服务端处于":["9.34"],"close":["9.34","16.46"],"地址中":["9.35"],"不同的顺序":["9.36"],"到达目的地":["9.36"],"可靠":["9.36"],"的数据传输":["9.36"],"通过确认":["9.36"],"重传和拥塞控制等机制":["9.36"],"确保数据的完整性和顺序性":["9.36"],"服务器不会保留任何关于客户端的状态信息":["9.37"],"每个请求都是独立的":["9.37"],"对象":["9.38","45.25"],"并为该对象":["9.38"],"分配一个唯一的标识符":["9.38"],"id":["9.38","42.6"],"通常":["9.38"],"通过":["9.38"],"url":["9.38","43.14","43.15"],"参数的方式发送给客户端":["9.38"],"是指正在执行的程序的实例":["9.39"],"当其他用户访问包含恶意代码的页面时":["10.1"],"恶意代码会从服务器返回并在其浏览器中执行":["10.1"],"攻击者可以在博客评论区中提交恶意代码":["10.1"],"当其他用户浏览该博客时":["10.1"],"从而实现攻击":["10.1"],"型":["10.1"],"信用卡号等":["10.2"],"数据保护和加密可以使用加密协议":["10.2"],"如ssl":["10.2"],"tls":["10.2"],"来加密数据传输":["10.2"],"也可以使用加密算法对数据进行加密和解密":["10.2"],"都是常见的安全漏洞":["10.3"],"存在于":["10.3"],"web":["10.3"],"用户访问恶意网页":["10.4"],"攻击者通过各种方式":["10.4"],"诱使用户访问恶意网页":["10.4"],"例如通过电子邮件":["10.4"],"社交媒体":["10.4"],"属性":["10.5","45.33"],"设置":["10.5"],"cookie":["10.5"],"避免被解释为可执行的脚本":["10.6"],"内容安全策略":["10.6"],"csp":["10.6"],"使用内容安全策略来限制网页中可以执行的脚本和资源":["10.6"],"sql查询或添加语句插入到应用的输入参数中":["10.7"],"runtime":["11.1"],"environment":["11.1"],"就是java":["11.1"],"运行时环境":["11.1"],"多态是同一个行为具有多个不同表现形式的能力":["11.2"],"在不修改程序代码的情况下改变程序运行时绑定的代码":["11.2"],"实现多态的三要素":["11.2"],"千万不要在代码中使用浮点数来表示金额等重要的指标":["11.4"],"int":["11.5","11.6","11.23","16.33","16.50"],"double":["11.5"],"等类型放进去的":["11.5"],"了":["11.6"],"intvalue":["11.6"],"的键":["11.7"],"不可变的特性使得":["11.7"],"hash":["11.7","37.18"],"值也不会变":["11.7"],"不需要重新计算":["11.7"],"出于安全考虑":["11.7"],"stringbuilder":["11.8"],"可变":["11.8"],"属于字符串字面量":["11.9"],"字符串常量池位于堆内存中":["11.10"],"专门用来存储字符串常量":["11.10"],"那么它们的hashcode值一定要相同":["11.11"],"如果两个对象的hashcode相同":["11.11"],"test":["11.12","12.1"],"void":["11.12","11.23","16.25","16.27","16.32","16.45","16.49","24.3"],"main":["11.12","11.19","11.23","16.22"],"同一个类":["11.15"],"最终类":["11.16"],"string":["11.17","11.19","11.23","16.9","16.22","17.17","19.74","42.32","70.0"],"args":["11.17","11.19","11.23","16.22","59.1","59.8"],"animal":["11.17"],"an":["11.17"],"new":["11.17","11.19","16.22","16.30","16.41","19.61","20.14","20.30","22.1","22.3","22.7","60.0","73.1"],"报错":["11.17"],"show":["11.18"],"interface":["11.18"],"inter":["11.18"],"abstract":["11.18"],"可以定义具体方法也可以定义抽象方法":["11.20"],"有":["11.20"],"zi":["11.22"],"num":["11.23","69.6"],"匹配":["11.26"],"后直接跟着":["11.26"],"匹配一个数字":["11.26"],"是":["11.26","36.9"],"的简写":["11.26"],"匹配一个非数字":["11.26"],"表示声明一个异常":["11.28"],"编译项目源代码":["12.1"],"而不是在建立一个":["13.1"],"namespace属性与接口名一致":["13.2"],"createtime":["13.3"],"updatetime":["13.3"],"where":["13.3"],"drop":["14.0"],"数据操作语言":["14.1"],"姓名":["14.2"],"age":["14.2","37.12","42.32"],"bigint":["14.3"],"帅帅涛":["14.4"],"jpg":["14.4"],"01":["14.4","14.6","14.10"],"group":["14.5"],"by":["14.5"],"and":["14.6"],"08":["14.6","14.10"],"不参与分组":["14.7"],"gender":["14.10","42.20"],"entrydate":["14.10"],"between":["14.10"],"left":["14.12","14.13","66.5","71.11","71.13","71.14","71.15"],"左外连接":["14.12"],"完全包含左表":["14.12"],"和两表交集":["14.12"],"right":["14.12","66.5","71.13","71.14"],"join":["14.13","19.58","70.0"],"on":["14.13","14.15"],"提交事务":["14.14"],"commit":["14.14"],"回滚事务":["14.14"],"idx":["14.15"],"emp":["14.15"],"tb":["14.15"],"标注在业务类上":["15.2"],"repository":["15.2"],"标注在数据访问上":["15.2"],"一个接口有多个实现类时依赖的对象具体是哪个":["15.2"],"那些重复的逻辑":["15.3"],"也就是共性功能":["15.3"],"切入点":["15.3"],"后置通知":["15.4"],"在目标方法后执行":["15.4"],"运行后类名越靠后aop越先执行":["15.5"],"默认扫描当前引导类所在包及其子包":["15.7"],"enableautoconfiguration":["15.7"],"springboot实现自动化配置的核心注解":["15.7"],"tothreadstate":["16.1"],"threadstatus":["16.1"],"通过源码我们可以看到java中的线程存在6种状态":["16.1"],"每种线程状态的含义如下":["16.1"],"线程状态":["16.1"],"具体含义":["16.1"],"一个尚未启动的线程的状态":["16.1"],"也称之为初始状态":["16.1"],"开始状态":["16.1"],"线程刚被创建":["16.1"],"但是并未启动":["16.1"],"还没调用start方法":["16.1"],"mythread":["16.1"],"t":["16.1","45.25"],"为了验证上面论述的状态即状态转换的正确性":["16.2"],"long":["16.3","18.4"],"完成之后":["16.3"],"获取start":["16.3","16.4","16.5"],"之前的状态":["16.3","16.4","16.5"],"通过new初始化一个线程":["16.3","16.5"],"但是还没有start":["16.3"],"之前":["16.3","16.5"],"e":["16.4","16.9","16.46","75.24","85.9"],"printstacktrace":["16.4","16.9","16.17","16.43","16.46"],"被object":["16.4"],"notify":["16.4","45.4"],"方法唤醒之后":["16.4"],"阻塞结束后":["16.5"],"但是还没有thread":["16.5"],"启动线程":["16.5"],"先等100毫秒":["16.5"],"第一个线程释放锁至少需要100毫秒":["16.5"],"所以在第50毫秒时":["16.5"],"thread正在因等待obj的对象锁而阻塞":["16.5"],"因为它涉及到与操作系统交互":["16.6"],"当程序中需要创建大量生存期很短暂的线程时":["16.6"],"频繁的创建和销毁线程对系统的资源消耗有可能大于业务处理是对系":["16.6"],"统资源的消耗":["16.6"],"刚开始任务容器是空的":["16.8"],"所以线程都在wait":["16.8"],"try":["16.9","16.45","16.46","16.47","16.49","60.0"],"put":["16.9","16.41","16.46","17.17"],"catch":["16.9","16.46","21.8","85.9"],"interruptedexception":["16.9"],"extends":["16.9"],"thread":["16.9","16.28","16.47"],"提供一个构造方法":["16.9"],"用来初始化线程名称":["16.9"],"super":["16.9","16.49"],"override":["16.9","16.25","16.28","16.45","16.49"],"run":["16.9","16.25","16.27","16.28","16.45","16.47","16.49"],"案例2":["16.11"],"演示newfixedthreadpool方法所获取到的线程池的特点":["16.11"],"executorsdemo03":["16.11"],"在该线程池中存在3个线程":["16.11"],"关闭线程池":["16.11"],"threadpoolexecutor":["16.12"],"参数说明":["16.13"],"核心线程的最大值":["16.13"],"不能小于0":["16.13"],"最大线程数":["16.13"],"不能小于等于0":["16.13"],"空闲线程最大存活时间":["16.13"],"时间单位":["16.13"],"直到当前线程池总线程数量超过最大线程数时":["16.14"],"就是按照指定的任务处理策略处理多余的任务":["16.14"],"举例说明":["16.14"],"假如有一个工厂":["16.14"],"工厂里面有10个工人":["16.14"],"正式员工":["16.14"],"每个工人同时只能做一件任务":["16.14"],"defaultthreadfactory":["16.15"],"abortpolicy":["16.15"],"提交3个任务":["16.15"],"此时会产生一个核心线程":["16.15"],"一个临时工线程":["16.15"],"队列中会存在一个任务":["16.15"],"20s后临时工线程被回收":["16.15"],"核心线程不会被回收":["16.15"],"abstractexecutorservice":["16.16"],"控制台报错":["16.16"],"仅仅执行了4个任务":["16.16"],"有一个任务被丢弃了":["16.16"],"案例演示2":["16.16"],"discardpolicy任务处理策略":["16.16"],"threadpoolexecutordemo02":["16.16"],"将flag的值更改为true":["16.17"],"system":["16.17","16.27","16.28","16.47","16.49"],"out":["16.17","16.23","16.27","16.28","16.47","16.49","34.29"],"println":["16.17","16.23","16.27","16.28","16.47","16.49"],"线程共享变量":["16.18"],"的访问规则":["16.18"],"以及在jvm中将变量存储到内存和从内存中读取变量这样的底层细节":["16.18"],"特点":["16.18"],"执行慢一点以后":["16.19"],"在某一个时刻":["16.19"],"可能就会读取到主内存中最新的flag的值":["16.19"],"那么if语句就可以进行执行":["16.19"],"测试类":["16.19","16.23"],"java":["16.19"],"public":["16.19"],"class":["16.19","16.32"],"volatilethreaddemo02":["16.19"],"start":["16.21","16.22","18.4"],"main方法":["16.21"],"while":["16.21","16.27","16.28","16.46","17.12","69.6","72.6"],"加锁进行问题处理":["16.21"],"synchronized":["16.21"],"stope":["16.22"],"static":["16.22","16.32","18.1"],"throws":["16.22"],"exception":["16.22","16.46"],"vt":["16.22"],"冰淇淋的个数":["16.23"],"volatileatomicthreaddemo":["16.23"],"假设此时count的值是100":["16.24"],"线程a需要对改变量进行自增1的操作":["16.24"],"首先它需要从主内存中读取变量count的值":["16.24"],"由于cpu的切换关系":["16.24"],"此时cpu的执行权被切换到了b线程":["16.24"],"count":["16.25","18.4","34.4"],"对该变量进行":["16.25","16.33"],"volatile关键字不保证原子性操作":["16.26"],"关闭线程":["16.27"],"readtemperaturerunnable类":["16.28"],"implements":["16.28"],"runnable":["16.28"],"温度传感器":["16.28"],"不断的读取温度传感器中的数据":["16.28"],"读取数据":["16.28"],"currentthread":["16.28","16.47"],"getname":["16.28","16.47"],"读取到的温度数据为":["16.28"],"接下来我们就来讲解一下我们上述案例":["16.29"],"定义一个object类型的变量":["16.30"],"该变量将作为同步代码块的锁":["16.30"],"object":["16.30","45.2","45.24","65.3","75.22","75.23"],"obj":["16.30"],"原子类":["16.31"],"以原子方式将输入的数值与实例中的值":["16.32"],"atomicinteger里的value":["16.32"],"相加":["16.32"],"并返回结果":["16.32"],"getandset":["16.32"],"以原子方式设置为newvalue的值":["16.32"],"并返回旧值":["16.32"],"案例演示atomicinteger的基本使用":["16.32"],"atomicintegerdemo01":["16.32"],"原子型integer":["16.32"],"100次":["16.33"],"此时线程1想要把变量的值增加1":["16.35"],"对线程1来说":["16.35"],"旧的预期值":["16.35"],"要修改的新值":["16.35"],"1571817085047":["16.35"],"在线程1要提交更新之前":["16.35"],"getandaddint":["16.36"],"调用unsafe类中的getandaddint方法":["16.36"],"unsafe类":["16.36"],"unsafe类中的getandaddint方法":["16.36"],"共享资源每次只给一个线程使用":["16.37"],"其它线":["16.37"],"程阻塞":["16.37"],"源码分析":["16.40"],"定义一个segment对象":["16.41"],"如果value的值为空":["16.41"],"那么抛出异常":["16.41"],"null":["16.41","16.46","20.21","20.22","21.5","22.9","36.16","37.16","69.3","71.7","71.8","71.9","71.13","71.14","71.15","72.2","72.5"],"throw":["16.41","60.0"],"nullpointerexception":["16.41"],"hash函数获取key的hashcode":["16.41"],"然后做了一些处理":["16.41"],"通过key的hashcode定位segment":["16.41"],"j":["16.41"],"segmentshift":["16.41"],"segmentmask":["16.41"],"tab":["16.42"],"f":["16.42"],"n":["16.42","44.49"],"fh":["16.42"],"哈希表如果不存在":["16.42"],"那么此时初始化哈希表":["16.42"],"length":["16.42","42.13","69.2","69.4","72.5","75.16"],"inittable":["16.42"],"通过hash值计算key在table表中的索引":["16.42"],"将其值赋值给变量i":["16.42"],"然后根据索引找到对应的node":["16.42"],"如果node为null":["16.42"],"做出处理":["16.42"],"else":["16.42","71.11","72.2","73.1","73.2"],"tabat":["16.42"],"新增链表头结点":["16.42"],"cas方式添加到哈希表table":["16.42"],"castabat":["16.42"],"break":["16.42","17.13"],"调用countdownlatch对象的countdown方法对计数器进行":["16.43"],"1操作":["16.43"],"线程任务类2":["16.43"],"countdownlatchthread02":["16.43"],"cyclicbarrier类型的成员变量":["16.45"],"private":["16.45","17.13"],"使用构造方法对cyclicbarrier进行初始化":["16.45"],"模拟开会人员的随机到场":["16.45"],"sleep":["16.45","53.12"],"math":["16.45","59.7","70.1"],"random":["16.45","16.47"],"filereader":["16.46"],"d":["16.46","51.7","75.24"],"salary":["16.46"],"txt":["16.46"],"line":["16.46","82.8","82.10","82.12","82.16"],"readline":["16.46"],"parseint":["16.46"],"小的问题":["16.46"],"工资信息不能重复":["16.46"],"finally":["16.46"],"这个run只允许2个线程同时执行":["16.47"],"获取许可证":["16.47"],"正在经过十字路口":["16.47"],"模拟车辆经过十字路口所需要的时间":["16.47"],"nextint":["16.47"],"result":["16.49","56.0"],"钻戒":["16.49"],"把钻戒给媳妇":["16.49"],"set":["16.50","19.54","20.13","45.26","45.32","45.33"],"remove":["16.50"],"调用exchanger中的exchange方法完成数据的交换":["16.50"],"exchange":["16.50"],"先比对长度":["16.50"],"然后使用对方线程所传递过来的数据和自己线程所读取到的数据进行比对":["16.50"],"本方数据":["16.50"],"所以阻塞方法结束之后不会立即执行":["17.8"],"而是去抢cpu":["17.8"],"阻塞":["17.8"],"等待":["17.8"],"wait":["17.8"],"对共享资源":["17.9"],"如变量":["17.9"],"使用原子操作":["17.10"],"atomic":["17.10"],"operations":["17.10"],"来对共享资源进行操作":["17.10"],"确保操作的原子性":["17.10"],"原子操作由java原子类":["17.11"],"classes":["17.11","42.18"],"提供支持":["17.11"],"线程安全":["17.14"],"获得锁":["17.15"],"arrayblockingqueue":["17.17","17.18"],"queue":["17.17"],"任务队列":["17.18","56.14"],"o密集型运算":["17.19"],"相当于":["18.2"],"requestmapping":["18.2"],"在这个实现类中通过":["18.3"],"autowired注入mapper接口":["18.3"],"empmapper":["18.4"],"list":["18.4"],"它可能与用户的敏感数据进行交互":["19.1"],"如果允许javascript多线程访问用户数据":["19.1"],"number":["19.2","20.31","42.1","42.5","42.13","42.26","42.27","42.30"],"undefined":["19.2","20.21","85.3"],"对于其他引用类型统一返回object":["19.3"],"prototype":["19.4","19.72","21.4","59.6"],"tostring":["19.4","59.6","70.0"],"它是一个专门检测数据类型的方法":["19.4"],"它返回的值是一个形如":["19.4"],"的字符串":["19.4"],"通常会编写一个函数":["19.4"],"对返回的字符串从第8位做一个截取":["19.4"],"截取到倒数第一位":["19.4"],"再去做类型比较":["19.4"],"call":["19.4","19.72","20.13"],"浏览器会立即加载并执行指定的脚本":["19.5"],"立即":["19.5"],"也就是类似于把这个script放在了页面底部":["19.7"],"执行时间不同":["19.8"],"所以是闭包":["19.9"],"以普通函数形式调时严格模式下this指向undefined":["19.10"],"推入主线程执行":["19.11"],"上述过程的不断重复就事件循环":["19.11"],"异步任务执行顺序":["19.11"],"浏览器的事件循环由一个宏任务队列":["19.12"],"多个微任务队列组成":["19.12"],"首先":["19.12"],"渲染事件":["19.13"],"请求":["19.13"],"script":["19.13"],"settimeout":["19.13","21.3"],"这种设计是为了给高优先级任务一个插队的机会":["19.14"],"如果当前事件循环的队列里还有其他回调":["19.15"],"需要等其他回调执行完":["19.15"],"宏任务队列":["19.17"],"新对象":["19.21"],"就像是一个整体":["19.21"],"getsquare":["19.22"],"调用square函数":["19.22"],"全局变量赋值":["19.23"],"在内存中进行操作":["19.24"],"顺着引用表能找到的都不是内存垃圾":["19.25"],"不会被回收掉":["19.25"],"只有那些找不到的对象才是内存垃圾":["19.25"],"其次包含函数":["19.26"],"内部定义的变量":["19.26"],"只有判断nan时为true":["19.27"],"ljt":["19.28"],"a为假时执行a":["19.29"],"tostring偏向于显示":["19.30"],"对象转换时":["19.30"],"优先调用tostring":["19.30"],"不同点":["19.35"],"typeof判断null为object":["19.35"],"判断undefined为undefined":["19.35"],"二进制前三位为000则会被判断为object类型":["19.36"],"值相同":["19.37"],"转成number类型":["19.38"],"自增自减运算符":["19.38"],"false转换为0":["19.39"],"而true转换为1":["19.39"],"可转换成nan":["19.40"],"nan":["19.40","22.1"],"可转换成0":["19.41"],"false先转数字0":["19.42"],"所以可转换为":["19.42"],"javascript的计算存在精度丢失问题":["19.43"],"原因":["19.43"],"javascript中小数是浮点数":["19.43"],"决定事件是在捕获":["19.46"],"fun":["19.47"],"由最不具体的元素接收":["19.48"],"的封装":["19.49"],"stoppropagation":["19.51","19.76"],"preventdefault":["19.52"],"绑定在父元素上只需要绑定一次":["19.53"],"如果不存在":["19.54"],"将当前元素作为键存入":["19.54"],"map的键不能重复":["19.54"],"为":["19.55","75.16"],"false":["19.55","72.7","73.1","73.2"],"splice":["19.58","26.1"],"index":["19.58","19.73","26.4","72.6","76.2"],"删除":["19.58"],"添加":["19.58"],"将一个数组所有元素连接成字符串并返回这个字符串":["19.58"],"concat":["19.58"],"floor":["19.59"],"小数向下取整":["19.59"],"confirm":["19.60"],"occupation":["19.62"],"pānting":["19.62"],"encoded":["19.62"],"获取浏览器窗口的高":["19.63"],"获取浏览器窗口的宽":["19.63"],"操作刷新按钮和地址":["19.63"],"的应用程序接口":["19.64"],"api":["19.64"],"遵循w3c":["19.64"],"的标准":["19.64"],"所有浏览器公共遵守的标准":["19.64"],"js是通过访问bom":["19.64"],"使用":["19.68","34.2","36.16"],"form":["19.69"],"元素中使用":["19.69"],"foo":["19.71","20.22","85.4"],"console":["19.71","20.12","20.14","20.19","20.20","34.21","38.8","42.15","45.15","85.13"],"log":["19.71","20.14","20.19","20.20","21.6","34.21","38.8","42.15","45.15","75.22","75.23","85.13"],"slice":["19.72","59.8"],"遍历数组的索引":["19.73"],"数组":["19.74"],"array":["19.74","76.5","76.6"],"包含一组有序的元素":["19.74"],"字符串":["19.74"],"表示一串字符序列":["19.74"],"关键字会自动返回新创建的对象实例":["19.75"],"如果构造函数中有显式地返回一个对象":["19.75"],"关键字会返回这个对象而不是新创建的对象实例":["19.75"],"停止事件的传播":["19.76"],"阻止其在dom树中进一步传播":["19.76"],"指向这个全局对象":["19.77"],"函数执行上下文":["19.77"],"后进先出":["19.78"],"结构":["19.78"],"该对象将会包裹":["20.2"],"c":["20.3","20.25","45.13","51.7","75.24"],"returnedtarget":["20.3"],"human":["20.4"],"me":["20.4"],"方法会直接在一个对象上定义一个新属性":["20.5"],"property1":["20.6","20.7"],"object1":["20.8"],"somestring":["20.8"],"不能删除已有属性":["20.9"],"不能修改该对象已有属性的可枚举性":["20.9"],"baz":["20.10"],"方法返回":["20.11"],"create":["20.12"],"创建一个新的实例对象":["20.12"],"descriptor1":["20.16"],"包括不可枚举属性但不包括":["20.17"],"symbol":["20.17","53.1"],"localsymbol":["20.18"],"globalsymbol":["20.18"],"bar":["20.22"],"方法判断一个对象是否是可扩展的":["20.23"],"ordering":["20.26"],"when":["20.26"],"we":["20.26"],"numeric":["20.26"],"keys":["20.26"],"the":["20.26"],"returned":["20.26"],"numerical":["20.26"],"order":["20.26"],"according":["20.26"],"to":["20.26"],"方法让一个对象变的不可扩展":["20.27"],"方法返回一个布尔值":["20.28"],"方法封闭一个对象":["20.29"],"dog":["20.30","42.10"],"dog1":["20.30"],"回调有两个参数":["21.0"],"resolve":["21.0"],"方法的第二个参数reject捕获的异常依赖于上一个":["21.1"],"对象的执行结果":["21.1"],"success":["21.1","84.2"],"faild":["21.1"],"接收两个函数作为参数":["21.1"],"来处理上一个promise":["21.1"],"对象的结果":["21.1"],"状态只要从待定状态":["21.2"],"变为其他状态":["21.2"],"则状态不能再改变":["21.2"],"promise":["21.2","21.4"],"then的多次调用":["21.5"],"then返回一个promise对象":["21.5"],"第二个then读取的是上一个then返回的新的promise数据":["21.5"],"hi":["21.7"],"ice":["21.7"],"err":["21.8","52.3"],"当遇到rejectd的时候":["21.8"],"后续的promise结果我们是获取不到":["21.8"],"并且会把reject的实参":["21.8"],"传递给catch的err形参中":["21.8"],"allsettled":["21.8"],"上面的promise":["21.8"],"all有一个缺陷":["21.8"],"就是当遇到一个rejected的状态":["21.8"],"那么对于后面是resolve或者reject的结果我们是拿不到的":["21.8"],"es11":["21.8"],"新增语法promise":["21.8"],"无论状态是fulfilled":["21.8"],"rejected都会把参数返回给我们":["21.8"],"宏任务":["21.9"],"当前函数后的所有代码会被放进微任务队列":["21.10"],"from":["22.4","34.4","36.10","36.17","43.11","44.35","44.51","46.2","77.5"],"item":["22.5","53.30","76.2"],"filter":["22.6"],"has":["22.6","22.8","45.17","67.4"],"的形式储存":["22.7"],"m":["22.7"],"判断字典中是否存在键key":["22.8"],"creat":["22.9"],"map对象可以使用迭代器方法":["22.11"],"如foreach":["22.11"],"entries":["22.11"],"模块中":["23.1"],"每个模块都有自己的作用域":["23.1"],"所以在模块中访问":["23.1"],"它的值取决于函数的调用方式":["23.2"],"如果函数是作为普通函数调用":["23.2"],"的值是全局对象":["23.2"],"如果函数是作为对象的方法调用":["23.2"],"这种就是改变了this了":["23.3"],"三者都可以传参":["23.4"],"但是":["23.4","34.11","36.14","38.0"],"与严格相等运算符":["24.1"],"转数字为0":["24.2"],"false转数字为0":["24.2"],"转布尔值为true":["24.2"],"取反为false":["24.2"],"typeof":["24.3"],"await":["24.3"],"并设置":["25.1"],"app域下的cookie":["25.1"],"至此":["25.1"],"跨域单点登录就完成了":["25.1"],"以后我们再访问app系统时":["25.1"],"app就是登录的":["25.1"],"接下来":["25.1"],"我们再看看访问app2系统时的流程":["25.1"],"用户访问app2系统":["25.1"],"app2系统没有登录":["25.1"],"跳转到sso":["25.1"],"找元素方法":["26.1"],"some":["26.1"],"有一个行就返回true":["26.1"],"every":["26.1"],"有一个不行就返回false":["26.1"],"find":["26.1"],"找到符合条件的第一个数":["26.1"],"findlast":["26.1"],"反向找到符合条件的第一个数":["26.1"],"word":["26.4"],"of":["26.4","53.30","61.1"],"到该位置前停止读取数据":["26.5"],"默认等于数组长度":["26.5"],"字符集中列出的任何字符都将匹配":["27.0"],"abc":["27.0"],"表示匹配a":["27.0"],"b或c中的任何一个字符":["27.0"],"您还可以使用连字符":["27.0"],"表示字符范围":["27.0"],"内部为组件添加install函数":["28.1"],"并且通过app":["28.1"],"给父组件传一个空值":["28.2"],"密码框":["28.2"],"这里通过ref拿到了原生input的dom实例":["28.2"],"当父组件给子组件传一个showpassword时":["28.2"],"给input的type赋值为password":["28.2"],"这里通过promise":["28.2"],"then放进微任务中":["28.2"],"确保在更新":["28.2"],"showpassword":["28.2"],"的值后":["28.2"],"下一轮事件循环开始之前再次访问":["28.2"],"ipt":["28.2"],"样式文件将使用":["28.3"],"比如说打包时先删除之前的打包文件再打包":["28.4"],"获取路径的函数":["28.5"],"在里面重新定义了各种请求错误信息":["28.6"],"方法":["28.7","45.26"],"通过中间件设置了querystring模块来解析请求体":["28.8"],"更好的可维护性":["28.9"],"前后端分离使代码更模块化":["28.9"],"更易于理解和维护":["28.9"],"前端和后端团队可以专注于各自的领域":["28.9"],"server":["28.10"],"push":["28.10","60.0","70.1","73.1"],"等功能":["28.10"],"以减少数据传输量和提高效率":["28.10"],"attack":["28.11"],"缩写为mitm攻击":["28.11"],"3600表示资源文件将被缓存1小时":["28.12"],"no":["28.12"],"可以在加载前为它们保留空间":["28.13"],"避免布局偏移":["28.13"],"预加载字体":["28.13"],"使用preload标签或css中的":["28.13"],"提高加载速度":["28.14"],"响应式图片":["28.14"],"根据设备和屏幕大小":["28.14"],"使用合适的图像尺寸和分辨率":["28.14"],"避免不必要的图像加载":["28.14"],"视频流优化":["28.14"],"使用流式视频传输":["28.14"],"旨在提供更高效":["28.15"],"并发安装":["28.16"],"它将多个相关的项目或组件放置在同一个代码仓库中管理":["28.17"],"一种是":["29.1"],"br":["29.2"],"用法上面":["29.2"],"require":["29.2"],"遇到":["29.3"],"mjs文件":["29.3"],"因为":["29.4"],"模块需要支持静态代码分析":["29.4"],"而":["29.4","45.24","53.20"],"esm":["29.5"],"wrapper":["29.5"],"nexttick":["29.7"],"绝对路径":["29.8"],"appendfile":["29.9"],"localstorage和sessionstorage三者都是在开发中用到的临时存储客户端会话信息或者数据的方法":["30.0"],"一般页面最多存储20条左右信息":["30.2"],"例如一些关键密匙验证等":["30.3"],"gmt":["30.4"],"sessionstorage的相关操作":["30.4"],"存储":["30.4"],"sessionstorage":["30.4"],"setitem":["30.4"],"数据名":["30.4"],"数据值":["30.4"],"以作客户端进行请求的一个令牌":["30.7"],"名称":["30.10","32.4"],"cookie的名称":["30.10"],"值":["30.10"],"cookie中保存的数据":["30.10"],"并不对代码打包":["31.0"],"build":["31.1"],"可以使用":["31.3","36.15"],"webpackcil":["32.0"],"加上clean后之前的就会删除":["32.4"],"style":["32.5","47.0","50.3","63.0"],"ts":["32.5","42.16","45.25"],"node":["32.6","71.8"],"modules":["32.6"],"bower":["32.6"],"components":["32.6"],"相同的插件系统":["32.7"],"之上":["32.7"],"插件目的在于解决":["32.7"],"提供静态资源的服务":["32.8"],"express":["32.8"],"代码经过打包后会被压缩":["32.9"],"ajax":["33.0"],"pack":["33.0"],"用户操作action":["34.1"],"确定是否要重新渲染":["34.2"],"immutable":["34.2"],"我们会":["34.2"],"在shouldcomponentupdate":["34.2"],"中使用immutable":["34.2"],"通过vue的响应式系统来实现数据的自动更新":["34.3"],"react是在组件挂载到dom后拿数据":["34.3"],"statefulfunctioncomponent":["34.4"],"setcount":["34.4"],"p":["34.4","44.57"],"onclick":["34.4","36.6","38.3"],"newprops":["34.5"],"在props发生改变":["34.5"],"父组件重新render或者更新props":["34.5"],"时调用":["34.5"],"这个钩子":["34.5"],"提供对":["34.5"],"props":["34.5","34.23","56.11"],"的监听":["34.5"],"在":["34.5","34.25","36.9","42.8","44.18"],"在更新时被调用":["34.6"],"shouldcomponentupdate":["34.6"],"在更新前被调用":["34.6"],"用于":["34.6"],"和之前的":["34.7"],"他应该返回一个对象来更新":["34.7"],"componentdidupdate":["34.8","34.26"],"的第三个参数":["34.8"],"jsx":["34.8","37.10"],"来存储和更新状态":["34.9"],"并且可以通过":["34.9"],"setstate":["34.9"],"方法来更新状态":["34.9"],"自顶向下的含义是":["34.10"],"该组件以及它的子组件全部需要渲染":["34.10","40.1"],"而vue使用object":["34.10","40.1"],"defineproperty":["34.10","40.1","45.8","45.16","45.24"],"假设遍历发生了中断":["34.11"],"虽然可以保留当下进行中节点的索引":["34.11"],"下次继续时":["34.11"],"我们的确可以继续遍历该节点下面的所有子节点":["34.11"],"没有办法找到其父节点":["34.11"],"因为每个节点只有其子节点的指向":["34.11"],"断点没有办法恢复":["34.11"],"而vue基于数据劫持":["34.12"],"更新粒度很小":["34.12"],"document":["34.13"],"上触发":["34.13"],"合成事件的执行是在冒泡阶段":["34.13"],"通过这种处理":["34.13"],"将事件处理函数存储到":["34.14"],"listenerbank":["34.14"],"映射表":["34.14"],"中":["34.14","42.8","42.12","46.3"],"事件执行":["34.14"],"keydown":["34.15"],"keyup等":["34.15"],"合成为onchange":["34.15"],"那么":["34.15","42.20"],"它包含了":["34.16"],"而是存放进一个数组中":["34.17"],"当事件触发":["34.17"],"就从这个数组中弹出":["34.17"],"然而合成事件的执行是在冒泡阶段":["34.18"],"对象后":["34.19"],"再处理":["34.19"],"而不是document上":["34.20"],"这样好处是有利于微前端的":["34.20"],"组件被挂载了":["34.21"],"componentwillunmount":["34.21"],"组件将被卸载了":["34.21"],"render":["34.21","37.4"],"返回原始组件":["34.21"],"并将所有传入的props传递下去":["34.21"],"component":["34.22"],"通过constructor设置初始状态":["34.22"],"dom的使用在commit阶段":["34.24"],"在其同级元素中具有唯一性":["34.25"],"diff":["34.25"],"getsnapshotbeforeupdate":["34.26"],"父组件修改props":["34.26"],"性能问题":["34.27"],"在render":["34.27"],"方法中使用高阶组件可能导致性能问题":["34.27"],"样式是全局生效":["34.28"],"样式之间会互相影响":["34.28"],"module":["34.28"],"switchtransition":["34.29"],"两个组件显示和隐藏切换时":["34.29"],"使用该组件":["34.29"],"in":["34.29","59.4"],"把所有的角色导入":["34.30"],"并打印这些错误":["34.31"],"同时展示降级":["34.31"],"先将所有列表遍历一遍":["35.1"],"确定需要新增和删除的节点":["35.1"],"再确定需要移动的节点":["35.1"],"同一层级的节点":["35.1"],"每个节点在对应的层级用唯一的key作为标识":["35.1"],"diff算法有3种节点的操作":["35.1"],"插入":["35.1"],"insert":["35.1"],"markup":["35.1"],"新的节点不在旧集合中":["35.1"],"js会销毁旧的虚拟dom树及其对应的真实dom":["35.2"],"并将新的虚拟dom树转换为真实dom":["35.2"],"插入到dom树中":["35.2"],"比较子节点":["35.2","44.50"],"当旧列表的头一个节点oldstartnode与新列表的头一个节点newstartnode对比时key相同":["35.3"],"那么旧列表的头指针oldstartindex与新列表的头指针newstartindex同时向后移动一位":["35.3"],"当旧列表的最后一个节点oldendnode与新列表的最后一个节点newendnode对比时key相同":["35.3"],"剩余节点的处理":["35.4"],"当我们处理完相同的前置节点和后置节点后":["35.4"],"如果还有剩余节点":["35.4"],"就要对剩余节点进行处理":["35.4"],"剩余节点分为3中情况":["35.4"],"分别是":["35.4"],"只有新的一组的子节点有剩余":["35.4"],"k":["35.5"],"keyindex":["35.5"],"oldvnode":["35.5"],"如果找到就把对应的索引存入到source对应的位置中":["35.5"],"babel帮助我们完成了这个转换的过程":["35.6"],"createelement函数对props进行处理":["35.6"],"内部通查会充斥各种状态和副作用":["36.1"],"然而很多逻辑都分散在类组件的各生命周期里":["36.1"],"执行错误的":["36.2"],"保证了":["36.2"],"修改状态都是":["36.3"],"异步":["36.3"],"完成的":["36.3"],"换句话说并不是调用完setstate":["36.3"],"表示":["36.5","38.2"],"会同步更新":["36.5","38.2"],"大部分开发中用到的都是react封装的事件":["36.6","38.3"],"比如onchange":["36.6","38.3"],"ontouchmove等":["36.6","38.3"],"执行完成":["36.7"],"视图绘制完毕":["36.7"],"才执行":["36.7"],"所以":["36.7"],"回调函数不会阻塞浏览器绘制视图":["36.7"],"v17后":["36.7"],"副作用清理函数是":["36.7"],"异步执行":["36.7"],"如果要卸载组件":["36.7"],"获取":["36.8"],"信息":["36.8"],"这样浏览器只会绘制一次":["36.8"],"会比":["36.9"],"usestate":["36.9","36.10"],"更适用":["36.9"],"当state逻辑较复杂":["36.9"],"我们就可以用这个钩子来代替usestate":["36.9"],"它的工作方式犹如":["36.9"],"redux":["36.9"],"函数调用时会接收到两个参数":["36.9"],"state和action":["36.9"],"state表示当前的state":["36.9"],"可以通过该state来计算新的state":["36.9"],"action是一个普通对象":["36.9"],"用来存储操作信息":["36.9"],"或类似的状态管理库中":["36.9"],"payload":["36.9"],"通常指代一个包含操作所需数据的对象":["36.9"],"它":["36.9"],"对象的一个属性":["36.9"],"对象用于描述发生的事件或操作":["36.9"],"并将其发送给":["36.9"],"reducer":["36.9","41.3","41.5"],"进行状态更新":["36.9"],"属性则承载了传递给":["36.9"],"import":["36.10","36.17","37.10","38.7","44.51"],"进行了性能优化时":["36.11"],"才有必要考虑使用":["36.11"],"接受两个参数":["36.12"],"第一个参数是一个函数":["36.12"],"依赖项改变时再次执行":["36.13"],"发生变化时":["36.14"],"才会触发子组件的重新渲染":["36.14"],"由于":["36.14"],"计算的结果":["36.15"],"进行缓存":["36.15"],"当缓存结果不变时":["36.15"],"会使用缓存结果":["36.15"],"对于耗时长":["36.15"],"性能开销大的地方":["36.15"],"来优化":["36.15"],"但大多数情况下":["36.15"],"inputref":["36.16"],"handlebuttonclick":["36.16"],"引用传递给组件内部":["36.17"],"并访问该组件实例":["36.17"],"mycomponent":["36.17"],"自定义暴露给父组件的实例值":["36.18"],"concurrent":["36.19"],"mode":["36.20"],"当迫切的任务执行后":["36.21"],"route":["37.2"],"例如":["37.3"],"home":["37.3"],"about":["37.3","37.9"],"等":["37.3"],"可以处理各种":["37.3"],"react":["37.4","38.7","39.2","39.4"],"router会自动向组件中传递三个参数match":["37.4"],"location和history":["37.4"],"后续可以通过钩子usehistory":["37.4"],"useparams":["37.4"],"uselocation函数来获取值":["37.4"],"render也是route组件中的属性":["37.4"],"和component类似":["37.4"],"也用来指定路径匹配后需要挂载的组件":["37.4"],"只是render需要的是一个回调函数作为参数":["37.4"],"useroutematch":["37.7"],"替换历史记录":["37.8"],"go":["37.8"],"跳转到指定记录":["37.8"],"goback":["37.8"],"回退":["37.8"],"goforward":["37.8"],"block":["37.8"],"历史记录中的状态对象":["37.10"],"可以用来在跳转时传递数据":["37.10"],"是否匹配布尔值":["37.11"],"query参数":["37.12"],"在跳转的路径中添加了一些query参数":["37.12"],"why":["37.12"],"location":["37.12"],"search":["37.12"],"简言之routes就是一个存放route的容器":["37.13"],"path":["37.14","53.14","59.9"],"要匹配的路径":["37.14"],"student":["37.15"],"上例中":["37.15"],"route嵌套后":["37.15"],"这非常有用":["37.16"],"如果模式与给定的路径名不匹配":["37.16"],"则返回":["37.16"],"正确使用":["37.17"],"component使用匿名函数时会频繁的触发unmount和mount操作":["37.17"],"属性会被组合在一起并渲染为":["37.18"],"href":["37.18"],"例如组件被选中时":["37.19"],"发生样式变化":["37.19"],"会变为":["38.0"],"而不是你期望的":["38.0"],"这是因为上面的":["38.0"],"函数是从":["38.0"],"中读取数据的":["38.0"],"不会更新":["38.0"],"事件中都调用了":["38.4"],"这样就可以":["38.4"],"类似于在一个函数内声明的变量":["38.5"],"是不可修改":["38.5"],"所有":["38.5"],"传入的数据类型和验证的数据类型不符":["38.6"],"就会":["38.6"],"在控制台发出警告信息":["38.6"],"它可以避免随着应用越来越复杂从而出现的":["38.6"],"react17之后有了hooks可以用useeffect":["38.7"],"钩子来实现在父组件的":["38.7"],"发生变化时调用的功能":["38.7"],"useeffect":["38.7"],"首次渲染的操作":["38.8"],"对侦测数据的变化更敏感":["39.1"],"简单易懂":["39.3"],"vuex":["39.5"],"vue":["40.1","44.14","44.63","46.2","51.3"],"也就是常说的diff算法":["40.2"],"包含两个属性":["41.0"],"标识属性":["41.0"],"类似于":["41.1","52.5"],"不同之处在于":["41.1","52.5"],"是用于执行异步操作或批量的":["41.1","52.5"],"actions":["41.2"],"createstore用来创建一个redux中的容器对象":["41.3"],"它需要三个参数":["41.3"],"preloadedstate":["41.3"],"的改变":["41.4"],"只要":["41.4"],"发生改变":["41.4"],"花果山一小":["41.5"],"花果山大街1号":["41.5"],"school":["41.5"],"stu":["41.5"],"提供了一个":["41.6"],"applymiddleware":["41.6"],"函数":["41.6"],"可以用于使用中间件":["41.6"],"applymiddleware的内部实现":["41.6"],"总体来说就是接收外部传入的":["41.6"],"chain":["41.7"],"middlewareapi":["41.7"],"getstate":["41.7"],"loggermiddleware":["41.8"],"logger":["41.8"],"日志功能":["41.8"],"fn1":["41.10"],"hello":["41.10"],"arr3":["42.1","76.1"],"表示定义了一个名称叫做arr的数组":["42.1"],"这个数组中将来既可以存储数值类型的数据":["42.1"],"mysum":["42.2"],"buildname":["42.3"],"cat":["42.3"],"类型必须匹配且个数必须为2":["42.5"],"username":["42.6"],"你只能为它赋予null和undefined":["42.7"],"在strictnullchecks未指定为true时":["42.7"],"声明一个void类型的变量没有什么大用":["42.7"],"我们一般也只有在函数没有返回值时去声明":["42.7"],"never类型同null和undefined一样":["42.8"],"也是任何类型的子类型":["42.8"],"也可以赋值给任何类型":["42.8"],"但是没有类型是never的子类型或可以赋值给never类型":["42.8"],"除了never本身之外":["42.8"],"即使any也不可以赋值给never":["42.8"],"typescript":["42.8"],"可以利用":["42.8"],"如果不缩小类型":["42.10"],"就无法对unknown类型执行任何操作":["42.10"],"getdog":["42.10"],"非原始类型都可以赋给":["42.11"],"同样":["42.11"],"类型":["42.14"],"具体而言":["42.14"],"initialize":["42.15"],"specifiedstr":["42.16"],"缺省显式类型注解的可变更的变量的类型转换为了赋值字面量类型的父类型":["42.17"],"的类型是":["42.17"],"去实现":["42.18"],"相似":["42.19"],"只是把所有可变方法去掉了":["42.19"],"因此可以确保数组创建后再也不能被修改":["42.19"],"需要注意的是":["42.20"],"一旦定义了任意属性":["42.20"],"类型断言":["42.22"],"any":["42.23"],"类型别名":["42.24"],"会给一个类型起个新名字":["42.24"],"setpoint":["42.25"],"partialpointy":["42.26"],"类别名扩展类别名":["42.28"],"其中":["42.29"],"代表":["42.29"],"索引类型":["42.32"],"getvalues":["42.32"],"person":["42.32"],"map":["42.32","45.21","76.2"],"musion":["42.32"],"只不过url后面不会出现":["43.2"],"会显得更加美观":["43.2"],"同时会带来一个问题":["43.2"],"因为没有":["43.2","43.5"],"点击前进后退按钮":["43.3"],"当监听到history变化之后":["43.3"],"前面部分发送给服务器":["43.4"],"一般前面部分的是不变的":["43.4"],"所以hash":["43.4"],"window":["43.5"],"addeventlistener":["43.5"],"该守卫是在异步操作执行前执行":["43.7"],"可以在异步操作执行完毕后":["43.7"],"再跳转到目标路由":["43.7"],"全局后置钩子aftereach":["43.7"],"在路由跳转完成后调用":["43.7"],"from两个参数":["43.7"],"不会接受":["43.7"],"next":["43.7","72.4","72.9"],"函数也不会改变导航本身":["43.7"],"beforeresolve":["43.8"],"导航被确认":["43.8"],"懒加载简单来说就是延迟加载或按需加载":["43.9"],"之处":["43.10"],"vuerouterconfig":["43.11"],"webpack写法":["43.11"],"将import":["43.11"],"userdetails":["43.11"],"这些事情可以通过接收属性对象的meta属性来实现":["43.12"],"导航完成之后获取":["43.13"],"先完成导航":["43.13"],"查询参数是通过":["43.14"],"的查询字符串进行传递的":["43.15"],"参数以键值对的形式出现在":["43.15"],"中的查询字符串中":["43.15"],"指令和插值表达式":["44.1"],"onbeforemount":["44.3","52.0"],"dom挂载前调用":["44.3","52.0"],"mounted":["44.3","52.0"],"onmounted":["44.3"],"组合式api一般在setup中请求数据":["44.4"],"访问":["44.5"],"节点":["44.5"],"进行":["44.5"],"数据交互":["44.5"],"beforeupdate":["44.5"],"渲染":["44.6"],"更新过程":["44.6"],"而v":["44.8"],"show则是控制这个dom元素的display属性是否为none":["44.8"],"所以会先执行循环":["44.9"],"再进行v":["44.9"],"if判断":["44.9"],"js会自动追踪这些依赖关系":["44.12"],"无法准确确定何时重新计算属性的值":["44.13"],"watch选项是基于观察者模式实现的":["44.13"],"都是以":["44.14"],"实例对象":["44.15"],"而且":["44.16"],"将computed":["44.17"],"watcher添加到data属性值的订阅者队列":["44.17"],"vue3":["44.18"],"定义监听":["44.18"],"get":["44.18","45.7","45.8","45.15","45.20","45.28"],"是在组件挂载前":["44.19"],"但是其收集对象是自己属性对应的":["44.19"],"而在这个回调函数当中":["44.20"],"它会自动监听响应数据":["44.20"],"api中的代码是根据逻辑功能来组织的":["44.21"],"我们可以将一个功能所定义的methods":["44.21"],"data等api会放在一起":["44.21"],"让我们可以更灵活地组合组件逻辑":["44.21"],"proxy":["44.22"],"如果支持":["44.22"],"来实现数据响应式":["44.22"],"编译模板":["44.22"],"在初始化阶段将模板编译成渲染函数":["44.22"],"渲染函数用于创建":["44.22"],"virtual":["44.22"],"并最终渲染成实际的":["44.22"],"为其添加":["44.23"],"getter":["44.23"],"setter":["44.23"],"v":["44.24","44.26","46.3"],"for的key属性":["44.24"],"plugin":["44.25"],"listeners":["44.27"],"无":["44.27"],"合并到":["44.27"],"attrs方式":["44.27","52.4"],"子组件渲染出来":["44.28"],"还可以传参":["44.29"],"参数1":["44.29"],"参数n":["44.29"],"useattrs":["44.30"],"dom元素的ref":["44.31"],"当在vue模板中使用ref引用dom元素时":["44.31"],"ref会被赋值为对应的dom元素":["44.31"],"message":["44.32"],"其中state为存放数据的地方":["44.33"],"mutations中的函数作用则是用来修改state":["44.33"],"actions中一般是用了处理一些异步操作的函数":["44.33"],"changename":["44.34"],"通过getter修改":["44.34"],"不建议":["44.34"],"方法每次页面渲染都会调用":["44.34"],"性能消化大":["44.34"],"useuserstore":["44.35"],"user":["44.35"],"alive接收两个属性include":["44.37"],"exclude":["44.37"],"分别代表哪些组件要用缓存和哪些不需要缓存":["44.37"],"第二次或以后使用组件时触发activated":["44.38"],"beforecreate":["44.38"],"组件销毁前钩子":["44.39"],"混合":["44.40"],"进入该组件本身的选项":["44.40"],"mixin的作用将组件的公共逻辑提取出来":["44.40"],"对象上新增属性":["44.41"],"proxy可以监听到":["44.41"],"defineproperty不能":["44.41"],"接收比如下面代码":["44.43"],"组件可以通过插槽的方式提供两个模板":["44.44"],"这个回调函数会在":["44.46"],"更新循环结束之后执行":["44.46"],"js对象":["44.48"],"o":["44.49"],"的":["44.49","45.18"],"对于每对相同位置的子节点":["44.50"],"递归地应用diff算法":["44.50"],"比较它们的差异":["44.50"],"js会使用一种叫做":["44.50"],"从pinia拿数据":["44.51"],"usemealsstore":["44.51"],"defineemit":["44.52"],"hide":["44.52"],"click":["44.52"],"也称为":["44.53"],"事件循环":["44.53"],"帧":["44.53"],"结束后才进行实际的dom更新":["44.53"],"如果在":["44.53"],"修改数据后立即访问更新后的":["44.53"],"从而减少不必要的元素渲染":["44.54"],"default是显示具体内容":["44.55"],"追踪更新对象的多个属性":["44.56"],"footer":["44.57"],"vue则同时支持单向绑定和双向绑定":["44.59"],"单向绑定":["44.59"],"插值形式":["44.59"],"但是子组件不能修改父组件传递来的props":["44.60"],"子组件只能通过事件通知父组件进行数据更改":["44.60"],"加载脚本的时候":["44.61"],"图片资源的压缩":["44.62"],"组件重复打包":["44.62"],"cli脚手架已经帮我们做了相关的约束了":["44.63"],"正常我们的前端项目都会有个src文件夹":["44.63"],"scoped":["44.64"],"发布者":["45.3"],"事件调度中心":["45.3"],"观察者的构造函数":["45.4"],"接收一个表达式和回调函数":["45.4"],"watcher":["45.4"],"vm":["45.4"],"exporfn":["45.4"],"cb":["45.4","45.13"],"parsepath":["45.4"],"实例触发值读取时":["45.4"],"会涉及到以下几个对象":["45.5"],"下文中该方法统称为getter":["45.7"],"reactivegetter":["45.8"],"遍历obj的属性":["45.9"],"遍历该对象":["45.9"],"并进行数据劫持":["45.9"],"prototype为原型":["45.10"],"当数据发生变化时":["45.11"],"循环依赖列表":["45.11"],"把所有的watcher通知一遍":["45.11"],"watcher收到后执行回调":["45.12"],"expression":["45.13"],"数据对象":["45.13"],"如obj":["45.13"],"表达式":["45.13"],"如b":["45.13"],"根据data和expression就可以获取watcher依赖的数据":["45.13"],"依赖变化时触发的回调":["45.13"],"使用computed计算属性时":["45.14"],"a属性是依赖b属性变化的时":["45.14"],"b变化时要通知到computed":["45.14"],"让它去执行回调函数":["45.14"],"这个时候message的dep就收集到了三个依赖":["45.14"],"这个依赖就是用来管理computed中message变化的":["45.14"],"我被读了":["45.15"],"我要不要做点什么好":["45.15"],"被读取了":["45.15"],"将这个依赖收集起来":["45.15"],"碍于":["45.16"],"prop":["45.17"],"方法时":["45.18"],"会访问属性":["45.18"],"state":["45.18"],"counter":["45.18"],"此时会触发":["45.18"],"track":["45.19","45.20"],"收集依赖":["45.19"],"调用":["45.20"],"dep":["45.21"],"depsmap":["45.22","45.28"],"targetmap":["45.22"],"effect":["45.23"],"函数来跟踪当前正在运行的函数":["45.23"],"枚举等也能直接拦截":["45.24"],"此对象只有一个指向其内部值的属性":["45.25"],"用来收集依赖和发布更新事件":["45.26"],"如果不是":["45.26"],"shallowref":["45.26"],"声明的浅层响应式数据的话":["45.26"],"其":["45.26"],"activeeffect":["45.27"],"reflect":["45.32"],"大家要区分一下":["45.33"],"model":["46.0"],"app":["46.2"],"传递给指令的值":["46.3"],"例如在":["46.3"],"my":["46.3"],"directive":["46.3"],"值是":["46.3"],"oldvalue":["46.3"],"之前的值":["46.3"],"仅在":["46.3"],"中可用":["46.3"],"无论值是否更改":["46.3"],"它都可用":["46.3"],"arg":["46.3"],"传递给指令的参数":["46.3"],"类似":["46.4"],"在vue3中如果组件有多个根结点":["46.4"],"9999px":["47.0","63.0"],"threshold":["50.1"],"阈值":["50.1"],"center":["50.1"],"minwidth":["50.1"],"警告":["50.2"],"提醒":["50.2"],"max":["50.3","59.7"],"height":["50.3"],"margin":["50.3"],"10px":["50.3"],"selectrow":["50.4"],"组件的template里要加上div把内容包起来包起来":["50.4"],"这样如果v":["50.4"],"if销毁modal时template里面就没有东西了":["50.4"],"灵活的可定制性":["51.0"],"好的组件库应该提供灵活的可定制性选项":["51.0"],"允许开发者根据项目需求进行样式":["51.0"],"主题和功能上的定制":["51.0"],"发布日志":["51.1"],"完全回退":["51.2"],"vue2将响应式数据放到data函数中":["51.3"],"而vue3则是使用ref和reactive将数据声明为响应式":["51.3"],"响应式实现方式":["51.3"],"e5":["51.3"],"vite是es6模块":["51.4"],"采用了按需编译的策略":["51.5"],"只在需要时编译单个模块或文件":["51.5"],"而不是像":["51.5"],"属性传给axios":["51.6"],"如果涉及到需要页面加载完成之后的话用mounted":["52.1"],"在vue中":["52.2"],"对响应错误进行处理":["52.3"],"provide":["52.4"],"inject":["52.4"],"getters":["52.6"],"获取器":["52.6"],"mutations没有了":["52.6"],"只有当依赖发生变化时":["52.7"],"引用":["53.1"],"栈会自动释放这些内存":["53.2"],"因此栈的管理非常高效":["53.2"],"引用类型的值放在堆里":["53.2"],"访问栈比访问堆要快得多":["53.2"],"异步任务右分为":["53.4"],"宏任务微任务":["53.4"],"字节流":["53.5"],"保证数据顺序和完整性":["53.5"],"ssl有对称加密和非对称加密":["53.7"],"fuillied":["53.8"],"存储型":["53.9"],"permute":["53.14","59.9"],"len":["53.14","59.9"],"res":["53.14","59.9"],"used":["53.14","59.9"],"dfs":["53.14","59.9"],"个数选够了":["53.14","59.9"],"并在画布上绘制图像":["53.16"],"图形和动画":["53.16"],"协商缓存":["53.19"],"协商缓存是通过设置http响应头来实现的":["53.19"],"浏览器在使用缓存前会向服务器发送请求":["53.19"],"如果服务器确认资源没有发生变化":["53.19"],"页面关闭就数据消失":["53.22"],"gpu进程":["53.23"],"网络进程":["53.23"],"插件进程":["53.23"],"采用系统时间补偿法":["53.25"],"首先获取组件的key值":["53.26"],"拿到key值后去this":["53.26"],"cache对象中去寻找是否有该值":["53.26"],"第三方库":["53.27"],"scaley":["53.28"],"建立连接":["53.34"],"浏览器向服务器发送请求":["53.35"],"如果当前页面资源没有变化":["53.35"],"直到到了超时时间或者一方主动断开连接":["53.36"],"日志记录":["53.37"],"dp":["53.38"],"国内镜像":["55.0"],"browser":["55.1"],"latest":["55.3"],"g":["55.4"],"使用reduce":["56.0"],"reduce":["56.0","76.7","77.4"],"current":["56.0","71.13","72.3","72.7"],"computed会重新计算":["56.2"],"而当没有相关数据变化时":["56.2"],"computed会返回之前缓存的计算结果":["56.2"],"深度监听":["56.3"],"通过设置deep":["56.3"],"true选项":["56.3"],"可以在watch中进行深度监听":["56.3"],"即递归地监听对象或数组内部属性的变化":["56.3"],"常用属性flex":["56.6"],"的祖先元素进行定位":["56.10"],"如果没有已定位的祖先元素":["56.10"],"则相对于最初的包含块":["56.10"],"一般是":["56.10"],"元素":["56.10"],"元素脱离了文档流":["56.10"],"这意味着父组件可以通过":["56.11"],"在网络请求中":["56.12"],"异步操作允许在等待响应期间继续处理其他用户交互":["56.12"],"而不会使界面冻结":["56.12"],"将异步操作封装在一个promise对象中":["56.13"],"并通过链式调用来处理操作的完成或失败":["56.13"],"处理异步操作的结果":["56.13"],"它们的执行通常由底层的操作系统或浏览器的相应组件处理":["56.14"],"按照一定顺序执行":["56.15"],"arguments":["59.1","59.8"],"newtimmer":["59.2"],"hasownproperty":["59.4"],"不能拷贝包含函数":["59.5"],"正则表达式":["59.5"],"回溯":["59.9"],"add":["62.0","73.1","73.2"],"trigger":["62.0"],"john":["65.1","65.6"],"min":["66.2"],"挑一个比":["66.2"],"temp":["66.3"],"把原链表第一个值的next指到了temp":["67.1"],"next的位置":["67.1"],"紧接着temp":["67.1"],"next指向了head指针所在的值":["67.1"],"于是下一次循环temp":["67.1"],"next就有值了":["67.1"],"head后移":["67.1"],"哈希集合":["67.6"],"迭代":["67.7"],"tuple":["69.2","69.4"],"sqrt":["69.5"],"storage":["69.7"],"limit":["69.7"],"json":["70.0"],"可以为空":["71.1"],"如果不为空":["71.1"],"那么利用这个特点":["71.2"],"inordertraverse":["71.3"],"通过中序遍历方式遍历所有结点":["71.3"],"preordertraverse":["71.3"],"因为其他结点都可以通过根结点找到":["71.4"],"binaryserachtree":["71.4"],"递归方法实现插入":["71.5"],"处理经过的节点":["71.7"],"处理左子树中的节点":["71.9"],"root":["71.14"],"左为空":["71.16"],"最后一个节点":["72.2"],"head":["72.3","72.4"],"next指向原来的第一个":["72.4"],"head指向新插入的":["72.4"],"indexof":["72.11","72.12","77.3"],"update":["72.11","72.12"],"shift":["74.1","85.7"],"front":["74.1"],"result99":["75.4"],"arr":["75.4","75.5","75.7","75.9","75.13","75.14"],"result9":["75.5"],"result11":["75.6"],"result10":["75.8"],"result14":["75.9"],"arr7":["75.12"],"创建一个":["75.16"],"arr11":["75.20"],"arr12":["75.28"],"arr16":["75.31"],"parsefloat":["76.2"],"isarray":["76.5","76.6"],"cur":["77.1","77.2"],"result4":["77.4"],"pre":["77.4"],"btn":["78.2","78.3","79.2","81.0","82.2","82.3"],"你就可以看到按钮啦":["79.3"],"primary":["79.5","79.6","79.7"],"plain":["79.8","84.2"],"shuaxin":["79.8"],"placeholder":["80.4"],"请输入内容":["80.4"],"请输入密码":["80.5"],"suffixicon":["80.6"],"bianji":["82.1"],"bangzhu":["82.1"],"bofangjilu":["82.1"],"dianhua":["82.1"],"dianzan":["82.1"],"在组件内挂载之后只需要引用下面这行代码":["82.3"],"licon":["82.4"],"apple":["82.5"],"fill":["82.7"],"gengduo":["82.9"],"award":["82.10"],"shengyin":["82.11"],"up":["82.12"],"down":["82.12"],"fenxiang2":["82.13"],"shibai":["82.14"],"xiaoxi":["82.15"],"zhihui":["82.15"],"auction":["82.16"],"文件上传":["84.1","84.2"],"tr":["85.2"],"给tr设置高度只起到min":["85.2"],"默认会平分table的高度":["85.2"],"tr中的td默认高度会继承tr的高度":["85.2"],"若给任一td设置了高度":["85.2"],"其他td的高度也同样变高":["85.2"],"类型只有":["85.5"],"临时移动":["85.6"],"属性使用裁剪方式创建元素的可显示区域":["85.8"],"除了obeject之外的其他类型":["85.12"],"直接调用":["85.12"],"用户键入内容改变时":["85.15"],"应该设置在父元素上":["85.18"],"封装好的组件库":["90.0"],"错题集":["90.0"]},{"0":["1.5","4.0","16.15","16.33","19.41","19.73","36.10","53.13","53.28","67.6","69.3","74.1","76.4","76.6"],"1":["1.20","3.8","9.1","14.0","14.2","14.6","16.22","19.71","21.1","22.3","28.17","42.1","42.19","45.3","59.10","66.1","66.2","67.7","69.2","69.4","71.1","75.13","77.3","88.1"],"2":["2.1","3.4","5.4","5.6","9.5","9.33","19.71","21.1","22.3","26.5","30.2","30.3","35.1","41.0","41.6","42.15","42.19","44.8","44.21","44.40","45.24","51.2","51.4","69.5","71.7","71.8","71.9","71.11","85.1"],"3":["1.30","3.3","3.9","5.3","9.18","9.34","16.4","19.15","19.24","19.30","19.39","19.42","19.71","21.3","21.9","21.10","26.5","27.0","32.3","35.1","35.5","36.1","41.9","42.19","42.22","43.14","44.9","44.10","44.21","44.41","45.5","45.16","45.18","45.25","45.26","51.1","51.5","56.12","71.2","75.20","75.28"],"4":["3.6","6.14","6.19","7.5","9.25","16.8","19.30","19.50","21.9","22.5","23.3","26.5","41.1","41.2","42.19","44.50","44.60","46.3","51.0","52.5","56.0","56.3","56.10","75.12","75.17","75.20","75.28","75.31","76.0","77.0","85.17"],"5":["3.15","10.2","16.5","16.35","26.5","44.1","53.34","55.1","75.11","75.12","75.17","75.20","75.27","75.28","75.31","76.0","77.0"],"6":["3.7","5.17","19.76","51.7","75.6","75.11","75.12","75.17","75.18","75.20","75.27","75.28","75.31"],"7":["16.47","20.26","24.3","69.4","75.10","75.11","75.12","75.17","75.18","75.19","75.20","75.21","75.27","75.28","75.30","75.31","75.32"],"8":["7.5","9.23","24.3","25.1","75.10","75.12","75.17","75.18","75.19","75.21","75.26","75.27","75.30","75.32"],"9":["0.2","9.23","25.1","75.1","75.2","75.3","75.10","75.12","75.21","75.26","75.30","75.32"],"10":["0.6","11.23","14.10","17.8","25.1","42.5","43.8","75.1","75.2","75.3","75.7","75.10","75.21","75.26","75.29","75.30"],"11":["43.8"],"20":["65.1"],"25":["0.2"],"28":["65.6"],"30":["59.4"],"32":["11.3"],"42":["20.6"],"50":["1.23","16.3"],"64":["11.3"],"94":["51.3"],"100":["2.1","16.28","16.33","17.12","17.13","20.26"],"123":["44.52"],"128":["11.6"],"150":["16.4","50.1"],"200":["9.1"],"300":["16.5"],"304":["53.19"],"404":["9.23"],"405":["9.23"],"406":["9.23"],"407":["9.23"],"408":["9.23"],"409":["9.23"],"456":["85.11"],"1000":["16.45","53.12","85.1"],"3000":["16.43","21.3"],"and":["0.1","2.9"],"price":["0.2"],"img":["0.2"],"images":["0.2"],"meals":["0.2","44.51"],"png":["0.2"],"then":["0.2","21.7","61.0"],"res":["0.2","21.7","61.0"],"读json格式数据":["0.2"],"eval":["0.3"],"jsonstr":["0.3"],"根据传参决定的":["0.4"],"post通过请求体传参":["0.4"],"后台通过数据流接收":["0.4"],"速度稍微慢一些":["0.4"],"而get通过url传参可以直接获取":["0.4"],"com":["0.5","6.20"],"主域名不同":["0.5"],"api":["0.6"],"mmdb":["0.6"],"movie":["0.6"],"v3":["0.6"],"list":["0.6"],"hot":["0.6"],"json":["0.6","9.19"],"ct":["0.6"],"e4":["0.6"],"b8":["0.6"],"8a":["0.6"],"e6":["0.6"],"b5":["0.6"],"b7":["0.6"],"ci":["0.6"],"channelid":["0.6"],"文件名为setupproxy":["0.6"],"const":["0.6","20.15","36.10","37.10","41.3","43.11","45.13","59.4","62.0","67.7","70.0","75.22","75.23"],"createproxymiddleware":["0.6"],"require":["0.6"],"proxy":["0.6"],"middleware":["0.6","41.7"],"反向代理":["0.6"],"跨域":["0.6"],"param":["0.6"],"promise":["0.8","52.3"],"reject":["0.8","21.0","21.2","52.3","86.2"],"设置响应拦截器":["0.8"],"在接收到响应后验证token的有效性":["0.8"],"response":["0.8"],"在这里执行对响应的处理":["0.8"],"originalrequest":["0.8"],"如果响应状态码为401":["0.8"],"表示token已过期或无效":["0.8"],"这块需要和后端约定好":["0.9"],"请求方法":["0.9"],"根据get":["0.9"],"left":["1.1","71.5","71.8","71.9","71.12"],"bottom":["1.1"],"right":["1.1","71.11","71.12"],"margin":["1.1","2.2"],"class":["1.2","3.11","16.13","45.14"],"block":["1.3","2.2"],"table":["1.3"],"cell":["1.3","85.2"],"opacity":["1.5","6.13"],"可以正常触发事件":["1.5"],"因合成层触发gpu加速":["1.5"],"所以不发生回流":["1.5"],"circle":["1.7"],"0px":["1.7"],"利用裁剪创建元素的可显示区域":["1.7"],"具体的大小需要相对于父元素计算":["1.8"],"比如":["1.8","44.16"],"父元素的字体大小":["1.8"],"height":["1.9","1.32"],"可视窗口高度":["1.9"],"1vw":["1.9"],"就等于可视窗口宽度的百分之一":["1.9"],"1vh":["1.9"],"基准字体大小":["1.10"],"div":["1.10","36.16","41.5","44.29","50.4"],"width":["1.10","2.9"],"10rem":["1.10"],"direction属性决定主轴的方向":["1.11"],"wrap属性定义":["1.11"],"shrink":["1.12"],"可缩小":["1.13","1.15"],"basis为auto":["1.14"],"不可缩小":["1.16"],"从而达到我们布局的目的":["1.17"],"template":["1.17","44.32","50.4"],"columns":["1.17"],"overflow":["1.18"],"hidden":["1.18"],"text":["1.18","9.19","36.16","80.8"],"然后再作为纹理":["1.19"],"texture":["1.19"],"上传到":["1.19"],"gpu":["1.19"],"只要该层的内容不发生改变":["1.19","6.14"],"就没必要进行重绘":["1.19","6.14"],"根据设置的left":["1.20"],"top等属性成固定位置的效果":["1.20"],"属性值有以下几个特点":["1.20"],"between是两端对齐":["1.21"],"在左右两侧没有边距":["1.21"],"动画指定需要多少秒或毫秒完成":["1.22"],"设置动画将如何完成一个周期":["1.22"],"以圆形的方式显示":["1.23"],"css":["1.23","44.63"],"高度和垂直方向的外边距":["1.24"],"上下外边距":["1.24"],"只能设置水平方向的外边距和内边距":["1.24"],"可用于所有字句变成大写或小写字母":["1.25"],"或每个单词的首字母大写":["1.25"],"uppercase":["1.25"],"transform":["1.25","6.13"],"居中对齐弹性盒的各项":["1.26"],"元素":["1.26","44.53"],"count":["1.27","36.10"],"direction":["1.27","56.6"],"元素选择器和伪元素选择器的权重为1":["1.29","56.16"],"内容状态伪类选择器":["1.30"],"content":["1.30"],"state":["1.30","34.4","34.5","34.7","36.9"],"first":["1.30","1.31"],"child":["1.30","5.18","44.32"],"选择作为父元素的第一个子元素的元素":["1.30"],"在元素内容之后插入生成的内容":["1.31"],"align":["1.32"],"文本水平对齐":["1.32"],"line":["1.32","82.5"],"行高":["1.32"],"word":["1.32","2.8"],"spacing":["1.32"],"rem":["1.33"],"异步加载css":["1.34"],"资源压缩":["1.34"],"如果满足":["1.35"],"则将媒体查询内的样式规则应用到对应的元素或组件上":["1.35"],"利用盒模型的":["2.0"],"border":["2.0"],"份":["2.1"],"inline":["2.2"],"其":["2.2"],"和边框":["2.3"],"的大小":["2.3"],"不计算外边距":["2.3"],"而w3c盒模型把内边距边框放到外面相加":["2.4"],"默认值为content":["2.5"],"hidden隐藏一个dom节点":["2.6"],"只触发重绘":["2.6"],"因为没有几何变化":["2.6"],"因为":["2.7"],"格式具有更好的图像数据压缩算法":["2.7"],"能带来更小的图片体积":["2.7"],"而且拥有肉眼识别无差异的图像质量":["2.7"],"wrap":["2.8"],"颜色":["2.8"],"新增":["2.8"],"rgba":["2.8"],"hsla":["2.8"],"模式":["2.8"],"max":["2.9","14.13","71.10","77.2"],"inner":["2.10"],"浏览器端与服务器端通用的模块化开发规范":["3.1"],"导入其它模块成员使用":["3.2"],"import关键字":["3.2"],"否则会报错":["3.4"],"可以使用":["3.5"],"as":["3.5","42.13"],"绑定":["3.6"],"这个区域":["3.6"],"不再受外部作用域的影响":["3.6"],"ecmascript":["3.7"],"简称es6":["3.7"],"b":["3.8","3.15","21.5","22.1"],"箭头函数是在哪定义就指向谁":["3.9"],"普通函数可以当成构造函数":["3.9"],"export":["3.12"],"可以导出多个属性或者方法":["3.12"],"需要用":["3.12"],"函数与":["3.14"],"yield":["3.14"],"结合可以实现更简洁的异步编程":["3.14"],"迭代器":["3.14"],"对象新增的方法":["3.15"],"object":["3.15","11.5","16.36","53.1"],"is":["3.15","42.16","42.32"],"assign":["3.15"],"返回的数组元素不是字符串":["4.0"],"而是实际的symbol值":["4.0"],"因此可以通过它引用到对象的该属性":["4.0"],"es6新增的reflect":["4.0"],"ownkeys":["4.0"],"方法可以遍历出所有的常规键名和symbol键名":["4.0"],"reflect":["4.0"],"文档结构":["5.1"],"化的表述":["5.1"],"也是一样的":["5.2"],"需要通过分词器先将字节流转换为一个个":["5.2"],"分为":["5.2"],"tag":["5.2"],"和文本":["5.2"],"上述":["5.2"],"代码通过词法分析生成的":["5.2"],"如下所示":["5.2"],"维护了一个token":["5.2"],"会阻止dom树的解析":["5.3"],"chrome":["5.4"],"浏览器预解析操作":["5.4"],"当渲染引擎收到字节流之后":["5.4"],"或":["5.5","23.2"],"dom树构建完成":["5.7","19.50"],"domcontentloaded":["5.7"],"属性":["5.8","37.18"],"将会并行加载js":["5.8"],"到页面全部加载完成后才会执行":["5.8"],"会按顺序执行":["5.8"],"外链的js如果含有async":["5.8"],"它不必等到整个":["5.9"],"html":["5.9"],"这三个过程在实际进行的时候并不是完全独立的":["5.10"],"而是会有交叉":["5.10"],"解析越慢":["5.11"],"时":["5.12","37.17"],"浏览器会从构建":["5.12"],"到":["5.13"],"树上":["5.13"],"再进行后续操作":["5.13"],"避免大量无谓的计算量":["5.13"],"所以":["5.13","36.2"],"用":["5.13","9.16"],"树的差异":["5.14"],"src":["5.16"],"core":["5.16"],"window":["5.17","20.22"],"表示浏览器窗口":["5.17"],"提供了操作和访问浏览器窗口的方法和属性":["5.17"],"location":["5.17"],"创建一个包含指定文本内容的文本节点":["5.18"],"appendchild":["5.18","47.0","63.0"],"将一个节点添加为当前节点的子节点":["5.18"],"removechild":["5.18"],"title":["5.19","50.4"],"hasattribute":["5.20"],"获取元素相对于offsetparent元素的左边距的距离":["5.21"],"offsetwidth":["5.21"],"获取元素的可见宽度":["5.21"],"包括内容区域":["5.21"],"内边距和边框":["5.21"],"offsetheight":["5.21"],"获取元素的可见高度":["5.21"],"clientwidth":["5.21"],"获取元素的内部宽度":["5.21"],"queryselector":["5.22"],"queryselectorall":["5.22"],"每隔指定的时间间隔执行一次指定的函数":["5.24"],"cleartimeout":["5.24","59.1"],"timeoutid":["5.24"],"取消由":["5.24"],"获取当前窗口的视口宽度":["5.25"],"innerheight":["5.25"],"获取当前窗口的视口高度":["5.25"],"screen":["5.25"],"中发生的特定事件":["5.26"],"可以包含有关事件的信息和方法":["5.26"],"目标阶段":["5.27"],"at":["5.27"],"或冒泡阶段":["5.27"],"同时阻止调用其他的事件处理函数":["5.28"],"initevent":["5.28"],"type":["5.28","6.4","28.2","36.9","36.16","42.8","42.25","42.29","79.0"],"不同的版本之间格式书写上略有差异":["6.1"],"如果没有事先告诉浏览器":["6.1"],"那么浏览器就不知道文档解析标准是什么":["6.1"],"是标明重点内容":["6.2"],"有语气加强的含义":["6.2"],"使用阅读设备阅读网络时":["6.2"],"strong会重读":["6.2"],"总是在新行上开始":["6.3"],"就是每个块级元素独占一行":["6.3"],"默认从上到下排列":["6.3"],"宽度缺少时是它的容器的100":["6.3"],"除非设置一个宽度":["6.3"],"高度":["6.3"],"行高以及外边距和内边距都是可以设置的":["6.3"],"块级元素可以容纳其它行级元素和块级元素":["6.3"],"radio":["6.4"],"name":["6.4","32.4","36.9","37.9","59.4","65.2","82.3","82.4"],"sex":["6.4"],"id":["6.4","25.0","32.4","36.9","37.4"],"sms":["6.5"],"keywords这三个标签":["6.6"],"用javascript解决":["6.7"],"使用html5的shim框架":["6.7"],"在head标签中调用以下代码":["6.7"],"地理":["6.8"],"本地离线存储":["6.8"],"localstorage长期存储数据":["6.8"],"浏览器关闭后数据不丢失":["6.8"],"sessionstorage的数据在浏览器关闭后自动删除":["6.8"],"对渲染树进行reflow":["6.9"],"回流":["6.9"],"重排":["6.9"],"不占位置会忽略":["6.10"],"visiabllity":["6.10"],"当页面中的元素的":["6.11"],"大小或位置发生变化":["6.11"],"对于":["6.13"],"和":["6.13","6.18","34.2","34.4","44.44"],"效果":["6.13"],"来计算":["6.14"],"使用固定定位或绝对定位":["6.15"],"将元素设置为position":["6.15"],"fixed或position":["6.15"],"absolute":["6.15"],"可以使元素创建为单独的合成层":["6.15"],"layer":["6.16"],"squashing":["6.16"],"的处理":["6.16"],"解决层爆炸的问题":["6.17"],"最佳方案是打破":["6.17"],"overlap":["6.17"],"span":["6.18"],"无法提供关于其内容的信息":["6.18"],"以及label标签的灵活运用":["6.19"],"便于团队开发和维护":["6.19"],"iframe元素的主要特点包括":["6.20"],"独立的文档流":["6.20"],"iframe元素中嵌入的文档与主文档是独立的":["6.20"],"seo是指为了从搜索引擎中获得更多的免费流量":["7.1"],"从网站结构":["7.1"],"提升页面关键词密度":["7.2"],"keywords里面把每个关键词用英文逗号隔开":["7.3"],"三到五个最佳":["7.3"],"通过站内的关键词链接指向网站内部的链接":["7.4"],"关键词占整篇文章的比重":["7.5"],"话术设置":["7.5"],"表现":["8.1"],"即指css样式表":["8.1"],"特殊符号用编码表示":["8.2"],"任何小于号":["8.2"],"不是标签的一部分":["8.2"],"都必须被编码为":["8.2"],"lt":["8.2"],"任何大于号":["8.2"],"提高用户的体验":["8.3"],"样式尽量少用行间样式表":["8.3"],"ok":["9.1","42.5","42.15"],"以及返回的内容":["9.1"],"收到用户的应答后":["9.2"],"便断开连接":["9.2"],"这种方式可以节省传输时间":["9.2"],"无状态":["9.2"],"ip协议不仅仅指的是tcp":["9.3"],"和ip两个协议":["9.3"],"而是指一个由ftp":["9.3"],"网络拥塞或数据包丢失":["9.4"],"tcp会进行重传":["9.4"],"起始且默认使用端口80":["9.5"],"而https的url由":["9.5"],"https":["9.5","9.26"],"起始且默认使用端口443":["9.5"],"http是超文本传输协议":["9.5"],"客户端收到服务器的ssl证书后":["9.6"],"会对证书进行验证":["9.6"],"它会检查证书的合法性和有效性":["9.6"],"包括检查证书的颁发机构是否受信任":["9.6"],"是否在有效期内等":["9.6"],"密钥交换":["9.6"],"而私钥用于解密数据":["9.8"],"其中最显著的是":["9.9"],"多路复用":["9.9"],"multiplexing":["9.9"],"功能":["9.9"],"多路复用允许在单个tcp连接上同时发送多个请求和响应":["9.9"],"索引是整数值":["9.11"],"通过索引可以找到对应的头部字段和值":["9.11"],"增量更新动态表":["9.11"],"在处理请求和响应的过程中":["9.11"],"可以拒绝接收":["9.12"],"推送的资源":["9.12"],"别名记录":["9.13","53.21"],"指向cdn的全局负载均衡系统":["9.13","53.21"],"负载均衡系统":["9.13","53.21"],"cdn的全局负载均衡系统找到一个合适的边缘节点":["9.13","53.21"],"返回给用户":["9.13","53.21"],"来代替资源名称":["9.16"],"向":["9.16"],"web":["9.16"],"服务器发送":["9.16"],"可以测试服务器功能是否正常运作":["9.16"],"head":["9.16","72.5","72.7"],"post产生两个tcp数据包":["9.17"],"原因是":["9.17"],"对于get方式的请求":["9.17"],"浏览器会把http":["9.17"],"header和data":["9.17"],"一并发送出去":["9.17"],"没有数据量限制":["9.18"],"请求体":["9.19"],"响应体的类型":["9.19"],"plain":["9.19"],"application":["9.19"],"x":["9.19","16.15","16.25","42.14"],"www":["9.19"],"form":["9.19"],"urlencoded":["9.19"],"accept":["9.19"],"说明接收的类型":["9.19"],"可以多个值":["9.19"],"形式进行存储":["9.20"],"多个请求参数之间用":["9.20"],"连接":["9.20","9.25"],"用于表示资源":["9.22"],"网页等":["9.22"],"被永久转移到其它":["9.22"],"未找到":["9.23"],"服务器找不到请求的网页":["9.23"],"方法禁用":["9.23"],"禁用请求中指定的方法":["9.23"],"不接受":["9.23"],"无法使用请求的内容特性响应请求的网页":["9.23"],"需要代理授权":["9.23"],"此状态代码与":["9.23"],"类似":["9.23"],"但指定请求者应当授权使用代理":["9.23"],"请求超时":["9.23"],"服务器等候请求时发生超时":["9.23"],"冲突":["9.23"],"服务器在完成请求时发生冲突":["9.23"],"tcp":["9.25"],"客户端向服务器发请求":["9.25"],"hsts":["9.26"],"强制客户端使用":["9.26"],"hosts":["9.27"],"文件里":["9.27"],"没有则向":["9.27"],"为应用程序提供网络服务":["9.28"],"是最接近用户的层次":["9.28"],"七层协议模型":["9.28"],"osi参考模型":["9.28"],"第一次握手就是客户端给服务器端发送一个报文":["9.33"],"客户端的发送能力":["9.33"],"服务端的接收能力是正常的":["9.33"],"第二次就是服务器收到报文之后":["9.33"],"wait状态":["9.34"],"如果服务端也想断开连接了":["9.34"],"和客户端的第一次挥手一样":["9.34"],"发给":["9.34"],"有内网":["9.35"],"不提供":["9.36"],"性保证":["9.36"],"它只是简单地将数据报发送出去":["9.36"],"不关心数据是否到达目的地":["9.36"],"效率":["9.36"],"由于":["9.36","10.4","38.5","44.12"],"需要维护连接状态和保证数据的可靠传输":["9.36"],"因此相对而言会增加一定的开销":["9.36"],"使得数据传输效率较低":["9.36"],"服务器无法识别出不同请求来自同一个客户端":["9.37"],"这意味着服务器不能基于之前的请求状态来处理当前的请求":["9.37"],"它使得服务器可以独立地处理每个请求":["9.37"],"并在后续的请求中":["9.38"],"或参数传递给服务器":["9.38"],"服务器根据":["9.38"],"识别用户":["9.38"],"并在":["9.38"],"服务器端存储和管理与该用户相关的状态信息":["9.38"],"通常存储在服务器的内存或持久化存储":["9.38"],"如数据库":["9.38"],"线程":["9.39"],"thread":["9.39"],"攻击通常发生在":["10.1"],"攻击者会通过":["10.1"],"修改":["10.1"],"页面的":["10.1"],"文档对象模型":["10.1"],"来触发攻击":["10.1"],"而不是从服务器返回恶意代码":["10.1"],"这种攻击通常需要用户与":["10.1"],"安全配置和管理":["10.2"],"web服务器和web应用程序必须采取安全的配置和管理策略":["10.2"],"以确保应用程序和服务器免受各种攻击":["10.2"],"这包括配置文件权限":["10.2"],"日志记录":["10.2"],"漏洞扫描和修复":["10.2"],"安全审计等方面":["10.2"],"应用程序中":["10.3"],"是一种攻击方式":["10.3","28.11"],"攻击者通过利用":["10.3"],"钓鱼链接等方式":["10.4"],"用户在目标网站已登录的情况下访问恶意网页":["10.4"],"用户在目标网站已经登录":["10.4"],"浏览器中保存了用户的会话信息":["10.4"],"的":["10.5"],"属性为":["10.5"],"httponly":["10.6"],"标记":["10.6"],"将敏感的":["10.6"],"cookie":["10.6"],"再在后台":["10.7"],"核心类库":["11.1"],"继承":["11.2"],"重写":["11.2"],"父类引用指向子类对象":["11.2"],"建议使用bigdecimal或者long来表示金额":["11.4"],"因为集合的容器要求元素是":["11.5"],"类型":["11.5","42.9","42.17"],"将基本数据类型包装成类":["11.6"],"interger自动装箱时有一个":["11.6"],"127的范围":["11.6"],"在范围内装箱不新建地址":["11.6"],"地址相同":["11.6"],"不在范围内装箱":["11.6"],"会新建地址":["11.6"],"地址不同":["11.6"],"网络地址url":["11.7"],"文件路径path":["11.7"],"密码通常情况下都是以string类型保存":["11.7"],"假若string不是固定不变的":["11.7"],"将会引起各种安全隐患":["11.7"],"比如将密码用string的类型保存":["11.7"],"那么它将一直留在内存中":["11.7"],"线程安全":["11.8"],"因此编译时期会在":["11.9"],"字符串常量池中创建一个字符串对象":["11.9"],"指向这个":["11.9"],"在创建字符串时":["11.10"],"jvm首先会检查字符串常量池":["11.10"],"它们并不一定相同":["11.11"],"hashcode方法主要是用来提升对象比较的效率":["11.11"],"args":["11.12","16.9","16.17","16.19","16.23","16.32","19.75","51.7"],"jjj":["11.12"],"stu":["11.12"],"方法重写":["11.14"],"返回值":["11.14"],"方法名和参数都一样的话会方法改写":["11.14"],"son":["11.14"],"同一个包":["11.15"],"不同包的子类":["11.15"],"基本数据类型变量不能被改变":["11.16"],"引用数据类型地址不能改变":["11.16"],"为":["11.17"],"abstract":["11.17","11.21"],"无法实例化":["11.17"],"implements":["11.18","16.39"],"override":["11.18","16.30"],"show":["11.19","14.15"],"interface":["11.19","45.25"],"inter":["11.19"],"inter2":["11.19"],"接口":["11.20"],"只能定义常量":["11.20"],"eat":["11.21"],"向下转型":["11.22"],"system":["11.23","16.15","16.21","16.32","16.45","16.46","16.50"],"out":["11.23","16.15","16.21","16.32","16.45","16.46","16.50"],"println":["11.23","16.21","16.32","16.45","16.46","16.50"],"string":["11.25","16.17","16.19","16.23","16.32","42.16"],"转字符串可以":["11.25"],"匹配一个空格":["11.26"],"t":["11.26"],"x0b":["11.26"],"f":["11.26","51.7","75.24"],"匹配一个非空格":["11.26"],"w":["11.26"],"匹配一个单词字符":["11.26"],"大小写字母":["11.26"],"数字":["11.26"],"下划线":["11.26"],"za":["11.26"],"写在方法内":["11.28"],"使用合适的单元测试框架运行测试":["12.1"],"package":["12.1"],"释放空闲时间超过最大空闲时间的连接":["13.1"],"查询":["13.3","14.0","14.15"],"resulttype单条记录所封装的类名":["13.3"],"include调用了sql封装的代码":["13.3"],"listlike":["13.3"],"resulttype":["13.3"],"pojo":["13.3"],"user":["13.3"],"include":["13.3"],"refid":["13.3"],"like":["13.3"],"concat":["13.3","76.5","76.7"],"select":["14.0","50.2"],"dql":["14.1"],"数据查询语言":["14.1"],"年龄":["14.2"],"gender":["14.2","42.32"],"char":["14.2"],"float":["14.3"],"double":["14.3"],"wwt":["14.4"],"分组字段列表":["14.5"],"having":["14.5"],"分组后条件列表":["14.5"],"between":["14.6"],"而having是分组之后对结果进行过滤":["14.7"],"判断条件不同":["14.7"],"desc":["14.9","14.10"],"order":["14.10","15.5"],"by":["14.10","14.13"],"update":["14.10"],"time":["14.10"],"if":["14.10","16.21","21.5","45.15","45.19","45.22","46.0","50.1","53.30","56.0","59.2","66.1","66.5","72.6","77.4","88.1"],"references":["14.11"],"tb":["14.11"],"右外连接":["14.12"],"完全包含右表":["14.12"],"子查询":["14.12"],"查询不同类别的菜品的最大价格":["14.13"],"group":["14.13"],"查询状态为起售且菜品数量大于3的种类名称":["14.13"],"撤回删除":["14.14"],"rollback":["14.14"],"原子性":["14.14"],"事务是不可分割的最小单元":["14.14"],"默认是按照类型进行":["15.2"],"存在多个想同类型的bean":["15.2"],"会报错":["15.2"],"解决":["15.2"],"primary":["15.2"],"pointcut":["15.3"],"匹配连接点的条件":["15.3"],"通知仅会在切入点方法执行时被应用":["15.3"],"无论是否有异常都会执行":["15.4"],"afterreturning":["15.4"],"可用":["15.5"],"enableautoconfiguration底层封装了一个":["15.7"],"import注解":["15.7"],"import注解实现了一个类autoconfigurationimportselect实现类":["15.7"],"实现其中的一个selectimports的方法":["15.7"],"返回值是需要将哪些类交给ioc容器管理":["15.7"],"只有线程象":["16.1"],"没有线程特征":["16.1"],"当我们调用线程对象的start方法":["16.1"],"那么此时线程对象进入了runnable状态":["16.1"],"那么此时才是真正的在jvm进程中创建了一个线程":["16.1"],"线程一经启动并不是立即得到执行":["16.1"],"线程的运行与否要听令与cpu的调度":["16.1"],"那么我们把这个中间状态称之为可执行状态":["16.1"],"也就是说它具备执行的资格":["16.1"],"但是并没有真正的执行起来而是在等待cpu的度":["16.1"],"也为了加深对线程状态转换的理解":["16.2"],"启动线程":["16.3","16.4"],"休眠50毫秒":["16.3"],"因为thread1需要休眠100毫秒":["16.3"],"所以在第50毫秒":["16.3"],"thread处于sleep状态":["16.3"],"用main线程来获取thread1线程的状态":["16.3"],"因为thread1线程睡眠时间较长":["16.3"],"所以当main线程执行的时候":["16.3"],"thread1线程还没有睡醒":["16.3"],"还处于计时等待状态":["16.3"],"通过new初始化一个线程":["16.4"],"但是还没有start":["16.4"],"之前":["16.4"],"main线程休眠150毫秒":["16.4"],"因为thread1在第100毫秒进入wait等待状态":["16.4"],"所以第150秒肯定可以获取其状态":["16.4"],"因为等待锁而阻塞时":["16.5"],"再等300毫秒":["16.5"],"两个线程的执行时间加上之前等待的50毫秒总共是250毫秒":["16.5"],"所以第300毫秒":["16.5"],"所有的线程都已经执行完毕":["16.5"],"线程执行完毕之后":["16.5"],"代码简化":["16.5"],"obj":["16.5","19.75","20.10"],"t1":["16.5"],"这样就有点":["16.6"],"舍本逐末":["16.6"],"了":["16.6"],"针对这一种情况":["16.6"],"直到一个外部线程向这个任务容器中扔了一个":["16.8"],"任务":["16.8"],"就会有一个消费者线程被唤醒":["16.8"],"while":["16.9","66.3","67.7","72.3"],"true":["16.9","16.27","19.46","20.7","20.14","20.21","34.6","46.3","53.14","59.9","67.2","67.5","73.1","73.2"],"task":["16.9"],"take":["16.9"],"测试类":["16.9","16.17","16.27","16.43","16.47"],"threadpooldemo01":["16.9"],"main":["16.9","16.17","16.19","16.23","16.32"],"创建线程池对象":["16.9"],"无参构造方法创建":["16.9"],"通过控制台的输出结果":["16.11"],"我们可以看到5个任务是通过3个线程进行执行的":["16.11"],"说明此线程池中存在三个线程对象":["16.11"],"案例3":["16.11"],"演示newsinglethreadexecutor方法所获取到的线程池的特点":["16.11"],"executorsdemo04":["16.11"],"任务队列":["16.13"],"不能为null":["16.13"],"创建线程工厂":["16.13","17.18"],"任务的拒绝策略":["16.13"],"案例演示通过threadpoolexecutor创建线程池":["16.13"],"threadpoolexecutordemo01":["16.13"],"演示基本使用":["16.13"],"因此只要当10个工人中有工人是空闲的":["16.14"],"来了任务就分配给空闲的工人做":["16.14"],"当10个工人都有任务在做时":["16.14"],"如果还来了任务":["16.14"],"就把任务进行排队等待":["16.14"],"如果说新任务数目增长的速度远远大于工人做任务的速度":["16.14"],"那么此时工厂主管可能会想补救措施":["16.14"],"int":["16.15"],"submit":["16.15"],"断点位置":["16.15"],"当我们使用discardpolicy这个任务处理策略的时候":["16.16"],"控制台不会报错":["16.16"],"volatilethreaddemo01":["16.17"],"static":["16.17","16.19","16.23"],"创建volatilethread线程对象":["16.17","16.19"],"所有的共享变量都存储于主内存":["16.18"],"计算机的ram":["16.18"],"这里所说的变量指的是实例变量和类变量":["16.18"],"不包含局部变量":["16.18"],"因为局部变量是线程私有的":["16.18"],"因此不存在竞争问题":["16.18"],"void":["16.19","16.30","42.25"],"throws":["16.19"],"interruptedexception":["16.19","16.28","16.49"],"volatilethread":["16.19"],"new":["16.19","16.23","16.32","18.4","19.4","20.15","21.2","67.6","67.7","70.0"],"isflag":["16.21"],"执行了":["16.21","16.22"],"控制台输出结果":["16.22"],"工作原理说明":["16.22"],"1571746088704":["16.22"],"执行流程分析":["16.22"],"volatilethread线程从主内存读取到数据放入其对应的工作内存":["16.22"],"但是这个时候flag的值还没有回写主内存":["16.22"],"此时main线程读取到了flag的值并将其放入到自己的工作内存中":["16.22"],"此时flag的值为false":["16.22"],"volatilethread线程将flag的值写到主内存":["16.22"],"创建volatileatomicthread对象":["16.23"],"开启100个线程对count进行":["16.23"],"a线程就处":["16.24"],"于就绪状态":["16.24"],"b线程处于运行状态":["16.24"],"线程b也需要从主内存中读取count变量的值":["16.24"],"由于线程a没有对count值做任何修改因此此时b读取到的数据还是100":["16.24"],"操作":["16.25","16.30"],"100次":["16.25","16.30"],"for":["16.25","16.30","22.9","51.7","69.3","70.0","75.22","75.23"],"那么同学们可能会存在一些疑问":["16.26"],"this":["16.27","34.4","34.21","44.35","69.6","71.4","71.13","71.15"],"volatileusethreaddemo01":["16.27"],"try":["16.28","17.12"],"让线程休眠100毫秒":["16.28"],"便于观察":["16.28"],"timeunit":["16.28","16.46","16.47"],"milliseconds":["16.28"],"sleep":["16.28","16.46","16.47","17.8","17.12"],"catch":["16.28","16.45","16.47","16.49","16.50","60.0"],"e":["16.28","16.42","16.45","16.47","16.49","16.50","51.7"],"printstacktrace":["16.28","16.45","16.47","16.49","16.50"],"gathertemperaturerunnable类":["16.28"],"定义一个变量":["16.28"],"表示环境初始温度":["16.28"],"引入原子性问题的案例":["16.29"],"run":["16.30"],"对该变量进行":["16.30"],"构造方法":["16.32"],"i":["16.33","53.13","66.5","69.3","69.5","69.7","70.0"],"另一个线程2抢先一步":["16.35"],"把内存值v中的变量值率先更新成了11":["16.35"],"1571817628904":["16.35"],"线程1开始提交更新":["16.35"],"首先进行a和内存值v的实际值比较":["16.35"],"发现a不等于v的值":["16.35"],"提交失败":["16.35"],"1571818176635":["16.35"],"o":["16.36","22.7","29.10"],"offset":["16.36"],"delta":["16.36"],"v":["16.36","16.39","44.27","44.32","44.59","50.2","80.8"],"do":["16.36"],"while就是自旋操作":["16.36"],"当cas成功以后":["16.36"],"循环结束":["16.36"],"获取atomicinteger类中所封装的int类型的值":["16.36"],"就相当于旧的预期值a":["16.36"],"getintvolatile":["16.36"],"用完后再把资源转让给其它线程":["16.37"],"因此synchronized我们也将其称之为悲观锁":["16.37"],"jdk中的reentrantlock也是一种悲观锁":["16.37"],"cas是从乐观的角度出发":["16.37"],"hashtable中的键就是当前循环变量的x这个数据的字符串表现形式":["16.39"],"不论该程序运行多少次":["16.39"],"都不会产生数据问题":["16.39"],"因此也就证明hashtable是线程安全的":["16.39"],"hashtable保证线程安全的原理":["16.39"],"查看hashtable的源码":["16.39"],"k":["16.39"],"extends":["16.39"],"dictionary":["16.39"],"map":["16.39","19.4","19.74","41.7"],"cloneable":["16.39"],"io":["16.39"],"serializable":["16.39"],"entry数组":["16.39"],"一个entry就相当于一个元素":["16.39"],"由于concurrenthashmap在jdk1":["16.40"],"7和jdk1":["16.40"],"对定位的segment进行判断":["16.41"],"如果segment为空":["16.41"],"调用ensuresegment进行初始化操作":["16.41"],"第一次hash定位":["16.41"],"unsafe":["16.41"],"getobject":["16.41"],"sshift":["16.41"],"sbase":["16.41"],"ensuresegment":["16.41"],"调用segment对象的put方法添加元素":["16.41"],"return":["16.41","17.13","19.54","20.30","20.31","21.5","34.8","36.16","44.35","45.7","45.8","45.15","59.7","59.8","65.4","67.2","67.3","69.2","71.12","71.15","75.4","75.5","75.9","75.14"],"false":["16.41","20.6","20.21","20.25","67.2","67.5","71.12"],"segment是一种可reentrantlock":["16.41"],"添加元素":["16.41"],"moved":["16.42"],"helptransfer":["16.42"],"oldval":["16.42"],"f为链表头结点":["16.42"],"使用synchronized加锁":["16.42"],"synchronized":["16.42"],"ek":["16.42"],"节点已经存在":["16.42"],"更新value即可":["16.42"],"equals":["16.42","16.50"],"该key对应的节点不存在":["16.42"],"则新增节点并添加到该链表的末尾":["16.42"],"3秒以后执行了countdownlatchthread02":["16.43"],"countdownlatchdemo01":["16.43"],"currentthread":["16.45","16.46"],"getname":["16.45","16.46"],"到了":["16.45"],"exception":["16.45","16.50"],"开会线程类":["16.45"],"ioexception":["16.46"],"模拟任务的执行时间":["16.46"],"seconds":["16.46","16.47"],"线程读取数据完毕":["16.46"],"await":["16.46"],"通知cyclicbarrier当前线程已经到达了屏障点":["16.46"],"start":["16.46","16.50"],"线程2":["16.46","16.50"],"驶出十字路口":["16.47"],"释放许可证":["16.47"],"得到媳妇给的":["16.49"],"womanthread类":["16.49"],"benfangelement":["16.50"],"get":["16.50","45.13","45.22","45.34"],"对方数据":["16.50"],"duifangelement":["16.50"],"比对":["16.50"],"数据存在问题":["16.50"],"else":["16.50","17.13","60.0","67.3","71.12","71.15","72.4","72.8","76.6"],"notify":["17.8"],"计时等待":["17.8"],"对象":["17.9","19.74","21.1","32.3","61.1"],"数据结构等":["17.9"],"不会被其他线程中断":["17.10"],"java提供了一些原子类":["17.10"],"如":["17.10","19.76","28.9"],"atomicinteger":["17.10"],"atomiclong":["17.10"],"等":["17.10","19.13","19.26","19.76"],"java原子类位于java":["17.11"],"util":["17.11"],"concurrent":["17.11"],"atomic包中":["17.11"],"boolean":["17.13"],"加了synchronized关键字":["17.14"],"unlock":["17.15"],"面条":["17.17"],"executors":["17.18"],"defaultthreadfactory":["17.18"],"期望cpu利用率":["17.19"],"总时间":["17.19"],"logger":["18.1"],"log":["18.1","19.22","19.27","19.28","20.3","20.12","20.16","20.25","21.7","22.4","22.5","26.4","42.6","43.5","45.7","75.15","76.2","85.4","86.1"],"value":["18.2","20.8","21.8","45.13","45.32","45.33"],"在service中调用了mapper接口在数据库中进行操作":["18.3"],"mapper接口里写sql语句往数据库发送指令":["18.3"],"emp":["18.4"],"emplist":["18.4"],"pagehelper插件进行分页查询":["18.4"],"会增加安全风险":["19.1"],"symbol":["19.2"],"null":["19.2","34.7","45.4","71.4","72.1","72.8"],"instanceof用于检测构造函数的":["19.3"],"prototype":["19.3"],"funcntion":["19.4"],"weakset":["19.4"],"nul":["19.4"],"指的是在渲染该":["19.5"],"script":["19.5"],"的加载与执行并行进行":["19.6"],"异步":["19.6"],"下载时":["19.7"],"async是下载完后立即执行":["19.8"],"defer是在html解析完后再执行":["19.8"],"var声明变量时在闭包里不会提升":["19.9"],"以箭头函数调用时this指向当前实例":["19.10"],"事件队列其实是一个":["19.11"],"先进先出":["19.11"],"的数据结构":["19.11"],"排在前面的事件会优先被主线程读取":["19.11"],"执行第一个宏任务":["19.12"],"全局script脚本":["19.12"],"产生的的宏任务和微任务进入各自的队列中":["19.12"],"执行完script后":["19.12"],"setinterval":["19.13","56.14"],"node中的setimmediate":["19.13"],"微任务比宏任务有更高优先级":["19.14"],"否则新入队的任务永远被放在队尾":["19.14"],"另外":["19.15"],"settimeout":["19.15","21.2","59.1"],"将函数插入到tick队列":["19.16","29.7"],"浅拷贝":["19.21"],"不会影响":["19.21"],"并返回一个闭包函数":["19.22"],"console":["19.22","19.27","19.28","20.3","20.16","20.18","20.25","21.7","22.2","22.4","22.5","26.4","38.7","42.6","43.5","45.7","75.7","75.15","76.2","85.4","86.1"],"输出25":["19.22"],"闭包可以像普通函数一样被调用和执行":["19.22"],"同时也可以访问其引用环境中的变量和参数":["19.22"],"这使得闭包具有一定的灵活性和可重用性":["19.22"],"闭包":["19.23"],"才会在适当的时机被":["19.25"],"gc":["19.25"],"回收":["19.25"],"参数":["19.26","41.6"],"其余情况都为false":["19.27"],"js":["19.27","28.2","32.7","36.12","41.3","41.4","43.7","44.29","44.63","45.14","45.20","55.1","67.2","80.2","80.3","80.4","80.6","82.7","83.1","83.2","84.1","84.2"],"in":["19.28"],"强转字符串优先调用tostring":["19.30"],"强转数字优先调用valueof":["19.30"],"引用数据类型":["19.31"],"指针存栈内存":["19.31"],"valueof":["19.34"],"null转数字为0":["19.35"],"undefined转数字为nan":["19.35"],"null是一个对象未初始化":["19.35"],"而null底层的二进制全都是0":["19.36"],"才能为true":["19.37"],"算术运算符":["19.38"],"关系运算符":["19.38","24.3"],"如果一个操作数是字符串":["19.39"],"另一个操作数是数值":["19.39"],"不等于":["19.40"],"左边为对象":["19.42"],"调用tostring转为":["19.42"],"需转二进制进行运算":["19.43"],"有些小数无法用二进制表示":["19.43"],"所以只能取近似值":["19.43"],"var":["19.47","20.22"],"function":["19.47","19.75","21.5","38.7","42.15","45.27","53.1"],"并往下传播":["19.48"],"dom事件流":["19.48"],"是基于promise对xhr对象的封装":["19.49"],"fetch":["19.49"],"domcontentloaded触发":["19.50"],"节省性能":["19.53"],"子元素不需要每个都去绑定同一事件":["19.53"],"push":["19.54","42.3","56.0","77.3"],"将当前元素添加到新数组中":["19.54"],"reduce方法中必须要return":["19.54"],"nan为假值":["19.55"],"转布尔值为false":["19.55"],"arr1":["19.58"],"arr2":["19.58"],"arr3":["19.58","76.2"],"连接数组":["19.58"],"arr":["19.58","75.6","75.8"],"round":["19.59","79.1"],"小数四舍五入":["19.59"],"prompt":["19.60"],"n":["19.61"],"decodeuri":["19.62"],"函数用于解码js中的url":["19.62"],"它将编码的url字符串作为参数并返回已解码的字符串":["19.62"],"host":["19.63"],"获取域名和端口":["19.63"],"hostname":["19.63"],"获取主机名":["19.63"],"port":["19.63"],"browser":["19.64"],"对象来访问":["19.64"],"控制":["19.64"],"修改客户端":["19.64"],"s":["19.66","19.67","70.0"],"hello":["19.66","19.67","42.5","42.10"],"指令的目的是强制执行严格模式下的代码":["19.68"],"用来声明允许用户输入数据的":["19.69"],"遍历字符串的索引":["19.73"],"set":["19.74","20.4","22.7","44.18","45.8","45.15","45.28","67.6"],"一组不重复的值的集合":["19.74"],"一组键值对的集合":["19.74"],"类数组对象":["19.74"],"arguments":["19.74"],"generator":["19.74"],"func":["19.75","51.7"],"let":["19.75","30.4","42.23","45.20","65.5","65.6","67.7","70.1","72.4"],"按下的键的标识符":["19.76"],"enter":["19.76"],"arrowup":["19.76"],"存在无数个":["19.77"],"只有在函数被调用的时候才会被创建":["19.77"],"用于存储在代码执行期间创建的所有执行上下文":["19.78"],"当javascript引擎开始执行你第一行脚本代码的时候":["19.78"],"类型的实例":["20.1"],"它们都会从":["20.1"],"wrapper":["20.2"],"expected":["20.3","20.19"],"output":["20.3","20.19"],"matthew":["20.4"],"a":["20.4","20.22","21.5","75.29"],"property":["20.4","45.7"],"on":["20.4"],"或者修改一个对象的现有属性":["20.5"],"writable":["20.6","20.7"],"不可写":["20.6"],"key":["20.8","22.9","22.10","71.7","85.10"],"of":["20.8","20.13","22.10","42.32","51.7","53.14","59.9"],"可配置性":["20.9"],"可写性":["20.9"],"指定对象的原型":["20.11"],"内部":["20.11"],"the":["20.13"],"to":["20.13","42.32","44.43"],"prototypal":["20.13"],"auto":["20.15"],"值作为名称的属性":["20.17"],"组成的数组":["20.17"],"objectsymbols":["20.18"],"或都是":["20.21"],"都是相同长度":["20.21"],"相同字符":["20.21"],"undefined":["20.22","59.5","75.16"],"是否可以在它上面添加新的属性":["20.23"],"方法判断一个对象是否被冻结":["20.24"],"an":["20.26"],"也就是永远不能再添加新的属性":["20.27"],"表示指定的属性是否可枚举":["20.28"],"阻止添加新属性并将所有现有属性标记为不可配置":["20.29"],"gabby":["20.30"],"dogtostring":["20.30"],"成功回调":["21.0"],"失败回调":["21.0"],"方法返回的是":["21.1"],"使用catch":["21.1"],"相当于给前面一个then方法返回的promise":["21.1"],"注册回调":["21.1"],"可以捕获到前面then没有被处理的异常":["21.1"],"如果是promise内部报错":["21.1"],"reject抛出错误后":["21.1"],"then的第二个参数就能捕获得到":["21.1"],"resolve":["21.2","86.2"],"失败":["21.2"],"3s后":["21.3"],"对象原型":["21.4"],"proto":["21.4"],"sum":["21.5"],"typeof":["21.5"],"number":["21.5","42.8"],"status":["21.8"],"rejected":["21.8","53.8"],"reason":["21.8"],"fulfilled":["21.8","56.13"],"该方法会在":["21.8"],"所有的promise都有结果":["21.8"],"无论是fulfilled":["21.8"],"还是rejected":["21.8"],"才会有最终的结果":["21.8"],"如果其中一个promise没有结果":["21.8"],"被放进微任务队列中了":["21.10"],"add":["22.1","22.3","36.9"],"p":["22.7","41.5","42.23"],"haha":["22.7"],"通过键":["22.8"],"从字典中移除对应的数据":["22.8"],"keys":["22.10","22.11","26.1"],"values":["22.11"],"来遍历键值对":["22.11"],"此外":["22.11"],"map对象有一个size属性":["22.11"],"得到的也是一个空对象":["23.1"],"在浏览器环境下":["23.1"],"指向的是":["23.1"],"的值就是该对象":["23.2"],"如果使用":["23.2"],"call":["23.2","23.3","45.4","59.6"],"apply":["23.2","23.3"],"方法调用函数":["23.2"],"的值就是传入的第一个参数":["23.2"],"bind改变this":["23.3"],"obj1":["23.3"],"林三心":["23.3"],"apply是数组":["23.4"],"而":["23.4","44.19","45.26"],"call是参数列表":["23.4"],"不同":["24.1"],"乘法运算符":["24.3"],"加法运算符":["24.3"],"session":["25.0"],"由于sso已经登录了":["25.1"],"不需要重新登录认证":["25.1"],"sso生成":["25.1"],"浏览器跳转到app2系统":["25.1"],"并将":["25.1"],"作为参数传递给app2":["25.1"],"app2拿到":["25.1"],"findindex":["26.1"],"找到符合条件的第一个数的索引":["26.1"],"indexof":["26.1"],"返回某个元素第一个索引如果没有则返回":["26.1"],"lastindexof":["26.1"],"返回某个元素最后一个索引如果没有则返回":["26.1"],"includes":["26.1","56.0"],"判断是否包含某个元素返回true或false":["26.1"],"返回数组索引的":["26.1"],"表示匹配小写字母a到z中的任何一个字符":["27.0"],"匹配重复字符":["27.0"],"用星号":["27.0"],"表示前一个字符可以重复零次或多次":["27.0"],"用加号":["27.0"],"表示前一个字符可以重复一次或多次":["27.0"],"用问号":["27.0"],"表示前一个字符可以重复零次或一次":["27.0"],"component注册组件":["28.1"],"在通过export导出":["28.1"],"进行类型的切换":["28.2"],"的值发生变化时":["28.2"],"vue":["28.2","34.10","44.24","45.4","45.16"],"的响应式更新是异步的":["28.2"],"尚未对模板进行重新渲染":["28.2"],"因此":["28.2"],"的初始类型仍然是":["28.2"],"gulp":["28.3"],"可以用series规定执行顺序":["28.4"],"在js的基础上声明了变量":["28.5"],"和一个timeout":["28.6"],"和getters":["28.7"],"设置了允许跨域的响应头":["28.8"],"通过清晰的接口定义和规范化的开发流程":["28.9"],"减少代码冲突和问题":["28.9"],"跨平台开发":["28.9"],"前后端分离可以为不同的客户端提供服务":["28.9"],"3是http协议的下一代版本":["28.10"],"目前还处于实验阶段":["28.10"],"预计基于quic":["28.10"],"quick":["28.10"],"udp":["28.10"],"攻击者试图在通信双方之间插入自己以截获":["28.11"],"篡改或窃取通信内容":["28.11"],"指示客户端在每次请求时都必须向服务器验证资源的有效性":["28.12"],"但仍然可以缓存资源文件":["28.12"],"store":["28.12","41.3","41.5","44.51"],"指示客户端不应缓存资源文件":["28.12"],"face规则":["28.13"],"提前加载字体文件":["28.13"],"确保字体在应用前已经准备就绪":["28.13"],"使用占位符":["28.13"],"在资源加载完成之前":["28.13"],"根据网络速度和设备性能动态调整视频质量":["28.14"],"缓存策略":["28.14"],"使用浏览器缓存":["28.14"],"设置合适的缓存头部":["28.14"],"利用浏览器缓存来存储静态资源":["28.14"],"减少重复请求":["28.14"],"数据缓存":["28.14"],"合理缓存数据":["28.14"],"更可编程和更现代化的图形处理能力":["28.15"],"pnpm使用一种称为":["28.16"],"锁定文件链接":["28.16"],"的机制":["28.16"],"lerna":["28.17"],"简称":["29.1"],"esm":["29.1"],"另一种是":["29.1"],"是同步加载":["29.2"],"后面的代码必须等待这个命令执行完":["29.2"],"才会执行":["29.2"],"就认为它是":["29.3"],"模块":["29.3"],"默认启用严格模式":["29.3"],"模块的输出接口是module":["29.4"],"exports":["29.4"],"是一个对象":["29.4"],"无法被静态分析":["29.4"],"所以只能整体加载":["29.4"],"上面代码指定require":["29.5"],"和import":["29.5"],"加载该模块会自动切换到不一样的入口文件":["29.5"],"总结为一句话":["29.5"],"如果是相对路径则自动转为绝对路径":["29.8"],"异步编程和事件循环等机制":["29.10"],"sessionstorage的有效期是仅保持在当前页面":["30.1"],"关闭当前会话页或者浏览器后就会失效":["30.1"],"localstorage和sessionstorage的存储容量是5mb":["30.2"],"读取":["30.4"],"data":["30.4","44.59","51.7"],"getitem":["30.4"],"清除":["30.4"],"removeitem":["30.4"],"localstorage和sessionstorage出现的时间较晚":["30.5"],"当第一次登录后":["30.7"],"客户端收到token后把它存储起来":["30.8"],"可以放在cookie或者local":["30.8"],"storage":["30.8"],"本地存储":["30.8"],"里":["30.8"],"存cookie里":["30.9"],"过期时间":["30.10"],"expires":["30.10"],"cookie的过期时间":["30.10"],"如果不设置":["30.10"],"则在":["30.10"],"浏览器关闭时失效":["30.10"],"直接用esm方式来运行项目":["31.0"],"preview":["31.1"],"defineconfig":["31.3"],"在项目中创建src目录":["32.0"],"写代码默认":["32.0"],"index":["32.0","43.7","72.4","72.7","72.8","75.4","75.5","75.9","75.14"],"里写多个入口":["32.3"],"hash":["32.4","43.4"],"支持链式调用":["32.5"],"链中的每个":["32.5"],"use":["32.6","78.2","79.2","82.2"],"loader":["32.6","32.7"],"babel":["32.6"],"无法实现的其他事":["32.7"],"plugins":["32.7"],"和socket服务":["32.8"],"socket":["32.8"],"让调试和错误定位边的非常困难":["32.9"],"源代码映射":["32.9"],"react":["33.0","34.12","37.10","38.5","39.1","39.3"],"java":["33.0"],"vuerouter的懒加载":["33.0"],"触发setstate更新seate":["34.1"],"虚拟":["34.1","44.22"],"通过":["34.2"],"is方法":["34.2"],"则可以完成对比":["34.2"],"purecomponent":["34.2"],"对":["34.2","36.15"],"componentdidmounted":["34.3"],"useeffect的回调函数":["34.3"],"increment":["34.4"],"类组件可以使用":["34.4"],"setstate":["34.4"],"来管理组件的状态":["34.4"],"statefulclasscomponent":["34.4"],"constructor":["34.4","45.14"],"super":["34.4"],"发生改变后":["34.5"],"相应改变组件的一些":["34.5"],"在这个方法中改变":["34.5"],"不会二次渲染":["34.5"],"而是直接合并":["34.5"],"nextprops":["34.5"],"nextstate":["34.5"],"确定组件是否需要重新渲染":["34.6"],"默认返回":["34.6"],"可以通过比较新旧":["34.6"],"优化渲染性能":["34.6"],"如果返回":["34.7"],"则不更新任何内容":["34.7"],"并重新渲染组件":["34.9"],"有状态组件通常用于处理复杂的业务逻辑":["34.9"],"需要管理状态或包含生命周期方法的场景":["34.9"],"无状态组件是指没有自己的状态":["34.9"],"3迁移到了proxy":["34.10","40.1"],"对数据的设置":["34.10","40.1"],"setter":["34.10","40.1"],"和获取":["34.10","40.1"],"只能从头再来一遍":["34.11"],"在新的架构中":["34.11"],"每个节点有三个指针":["34.11"],"分别指向第一个子节点":["34.11"],"下一个兄弟节点":["34.11"],"父节点":["34.11"],"这种数据结构就是fiber":["34.11"],"它的遍历规则如下":["34.11"],"没有这个压力":["34.12"],"进行浏览器兼容":["34.13","34.15"],"引入事件池避免频繁创建和回收":["34.13"],"方便事件统一管理":["34.13"],"在":["34.13","36.1","38.7","52.6"],"当事件冒泡到document时":["34.14"],"触发统一的事件回调函数reacteventlistener":["34.14"],"dispatchevent":["34.14"],"根据原生事件对象":["34.14"],"为什么使用合成事件":["34.15"],"其主要有三个目的":["34.15"],"实现更好的跨平台":["34.15"],"采用的是顶层事件代理机制":["34.15"],"事件到它对应的":["34.16"],"plugin":["34.16"],"避免频繁地去创建和销毁":["34.17"],"垃圾回收":["34.17"],"在事件处理函数执行完毕后":["34.17"],"所以原生事件会先合成事件执行":["34.18"],"然后再往父节点冒泡":["34.18"],"事件":["34.19"],"所以会先执行":["34.19"],"微前端一个前端系统中可能有多个应用":["34.20"],"如果继续采取全部绑定在document上":["34.20"],"props":["34.21","36.17","37.9","51.0"],"创建一个普通组件":["34.21"],"mycomponent":["34.21","36.10"],"会正确绑定this":["34.22"],"由于使用了":["34.22"],"es6":["34.22"],"这里会有些微不同":["34.22"],"改变的时候":["34.23"],"不可以":["34.24"],"render阶段dom还没生成":["34.24"],"算法中":["34.25"],"会借助元素的":["34.25"],"每当组件重新渲染时":["34.27"],"高阶组件都会重新生成一个新的包装组件":["34.27"],"即使传入的props没有发生变化":["34.27"],"这可能导致不必要的渲染":["34.27"],"只作用于当前组件":["34.28"],"不会影响当前组件的后代组件":["34.28"],"表示新组件先进入":["34.29"],"旧组件再移除":["34.29"],"表示就组件先移除":["34.29"],"统一导出":["34.30"],"ui":["34.31"],"而并不会渲染那些发生崩溃的子组件":["34.31"],"形成错误边界组件的两个条件":["34.31"],"对新节点进行插入操作":["35.1"],"移动":["35.1"],"move":["35.1"],"existing":["35.1"],"该节点存在于旧集合中且是可更新的类型":["35.1"],"此时可复用之前的node节点":["35.1"],"更新属性":["35.1"],"执行移动操作":["35.1"],"删除":["35.1"],"对于每对相同位置的子节点":["35.2"],"递归地应用diff算法":["35.2"],"比较它们的差异":["35.2"],"js会使用一种叫做":["35.2"],"那么旧列表的尾指针oldendindex与新列表的尾指针newendindex同时向前移动一位":["35.3"],"当旧列表的头一个节点oldstartnode与新列表的最后一个节点newendnode对比时key相同":["35.3"],"那么旧列表的头指针oldstartindex向后移动一位":["35.3"],"新列表的尾指针newendindex向前移动一位":["35.3"],"当":["35.4"],"遍历到头时":["35.4"],"还没到头":["35.4"],"当条件满足":["35.4"],"且":["35.4"],"没有找到说明该节点多余":["35.5"],"直接删除":["35.5"],"观察这个重新赋值后的source":["35.5"],"我们可以看出":["35.5"],"对默认props进行赋值":["35.6"],"并且对传入的子节点进行处理":["35.6"],"而不是聚焦在一起":["36.1"],"hooks":["36.2"],"的调用顺序":["36.2"],"不保证就会报错":["36.2"],"后状态立刻就发生变化":["36.3"],"而是需要等上一段时间":["36.3"],"当然这段时间不会很长":["36.3"],"函数":["36.4","38.1"],"调用完成并且组件开始重渲染的时候被调用":["36.4","38.1"],"但是":["36.5","38.2"],"有一个函数":["36.5","38.2"],"batchedupdates":["36.5","38.2"],"该函数会把":["36.5","38.2"],"合成事件中":["36.6","38.3"],"这些事件处理函数中的setstate都是异步处理的":["36.6","38.3"],"同步的情况":["36.6","38.3"],"react控制之外的事件中调用setstate是同步更新的":["36.6","38.3"],"则清理会在":["36.7"],"屏幕更新后运行":["36.7"],"v17之前":["36.7"],"同步执行的":["36.7"],"reder结束后立即执行":["36.7"],"接受两个参数":["36.7"],"一个回调函数和一个依赖项数组":["36.7"],"可选":["36.7"],"回调函数是要执行的副作用操作":["36.7"],"依赖项数组是一个可选的参数":["36.7"],"如果修改":["36.8"],"布局放在":["36.8"],"的具体数据":["36.9"],"initialstate":["36.9"],"张三":["36.9"],"李四":["36.9"],"any":["36.9"],"switch":["36.9"],"case":["36.9"],"remove":["36.9","72.11","72.12"],"setcount":["36.10"],"使用":["36.10","36.17"],"usecallback":["36.11"],"函数不依赖于组件的状态或属性":["36.11"],"不考虑usecallback":["36.11"],"用于执行需要缓存的计算":["36.12"],"第二个参数是一个依赖项数组":["36.12"],"不同点在于":["36.13"],"浅比较只会比较":["36.14"],"的引用":["36.14"],"而不会深入比较其内部内容":["36.14"],"所以当父组件在重新渲染时":["36.14"],"计算结果的开销还没有使用":["36.15"],"的开销大":["36.15"],"应视情况而定":["36.15"],"当父组件传了一个引用类型的结果":["36.15"],"result":["36.15","51.7"],"给子组件":["36.15"],"且子组件用":["36.15"],"包裹时":["36.15"],"需要使用":["36.15"],"button":["36.16","79.3"],"onclick":["36.16"],"参数将":["36.17"],"传递给内部的组件实例":["36.17"],"可以在组件中访问":["36.17"],"来获取组件实例":["36.17"],"例如":["36.17","56.3"],"模式下安全地有效地读取外接数据源":["36.19"],"下的异步更新":["36.20"],"再得到新的状态":["36.21"],"link":["37.2"],"如查询参数等":["37.3"],"在部署到服务器时":["37.3"],"需要配置服务器":["37.3"],"以支持":["37.3"],"重定向到应用的根路径":["37.3"],"使用url":["37.3"],"组件挂载时":["37.4"],"render对应的回调函数会被调用":["37.4"],"且函数的返回值会成为被挂载的组件":["37.4"],"student":["37.4"],"routeprops":["37.4"],"children":["37.4","44.51","52.4"],"children实际上就是组件的组件体":["37.4"],"设置方式有两种一个是通过组件体设置":["37.4"],"用来阻止用户跳转行为":["37.8"],"可以用prompt组件代替":["37.8"],"可以让组件内部直接访问history":["37.8"],"无须通过props获取":["37.8"],"jsx":["37.8","37.16"],"import":["37.8","37.16"],"match":["37.9"],"from":["37.10","37.16","38.7"],"router":["37.10","43.7"],"dom":["37.10","43.8","44.53"],"和params":["37.11"],"path":["37.11"],"detail2":["37.12"],"详情2":["37.12"],"element":["37.14"],"路径匹配后挂载的组件":["37.14"],"如果访问":["37.15"],"则会挂载studentlist组件":["37.15"],"这是因为react在比较组件状态以便决定如何更新dom节点时":["37.17"],"首先要比较组件的type和key":["37.17"],"在使用":["37.17"],"link阻止a标签默认事件":["37.18"],"然后调用":["37.18"],"则可以设置navlink的一下属性":["37.19"],"activestyle":["37.19"],"直到该组件被重新渲染":["38.0"],"所以最终":["38.0"],"每次读取":["38.0"],"的值都是":["38.0"],"并将它设为":["38.0"],"问题的修复参见下面的说明":["38.0"],"给":["38.0"],"传递一个函数":["38.0"],"就可以确保每次的调用都是使用最新版的":["38.0"],"确保":["38.4"],"不会被重新渲染两次":["38.4"],"组件都必须像纯函数一样保护它们的":["38.5"],"不被更改":["38.5"],"是传入的":["38.5"],"并且它们不能更改":["38.5"],"问题":["38.6"],"并且":["38.6"],"它还可以让程序变得更易读":["38.6"],"当然":["38.6"],"parentcomponent":["38.7"],"prop":["38.7"],"发生变化时执行的操作":["38.7"],"首次渲染":["38.8"],"这里可以执行你希望在首次渲染时进行的其他操作":["38.8"],"将":["38.8"],"设置为":["38.8"],"更精确":["39.1"],"在react中":["39.2"],"组件的状态是不能被修改的":["39.2"],"从左到右依次对比":["39.4"],"数据可变":["39.5"],"为真正改变的部分创建真实dom":["40.2"],"值是字符串":["41.0"],"多个type用action分开":["41.0"],"payload":["41.0"],"数据属性":["41.0"],"getter":["41.1","52.5"],"获取器":["41.1","52.5"],"用于从":["41.1","52.5"],"动作":["41.2"],"enhancer":["41.3"],"这个函数接收的这个回调函数就会被执行":["41.4"],"获取当前应用的状态":["41.4"],"创建redux":["41.5"],"app":["41.5"],"dispatch":["41.5"],"createstore":["41.6"],"preloadedstate":["41.6"],"用createstore生成一个新的store对象":["41.6"],"对新store对象中的dispatch方法用中间件增强":["41.6"],"返回该store对象":["41.6"],"action":["41.7"],"rootreducer":["41.8"],"reducers":["41.8"],"导入你的":["41.8"],"middleware3":["41.9"],"world":["41.10"],"也可以存储字符串类型的数据":["42.1"],"定义指定对象成员的数组":["42.1"],"剩余参数":["42.3"],"array":["42.3","44.24","53.1","53.30","76.7"],"值得注意的是":["42.7"],"方法没有返回值将得到undefined":["42.7"],"但是我们需要定义成void类型":["42.7"],"而不是undefined类型":["42.7"],"否则将报错":["42.7"],"类型的特性来实现全面性检查":["42.8"],"具体示例如下":["42.8"],"foo":["42.8","46.3"],"controlflowanalysiswithnever":["42.8"],"这种机制起到了很强的预防性":["42.10"],"更安全":["42.10"],"这就要求我们必须缩小类型":["42.10"],"我们可以使用typeof":["42.10"],"类型断言等方式来缩小未知范围":["42.10"],"空对象类型和大":["42.11"],"一样":["42.11"],"也是表示原始类型和非原始类型的集合":["42.11"],"并且在严格模式下":["42.11"],"具有初始化值的变量":["42.12"],"有默认值的函数参数":["42.12"],"将从":["42.14"],"这里表示一个字符串字面量类型":["42.17"],"的父类型":["42.17"],"implement":["42.18"],"typescript":["42.18"],"中的接口是一个非常灵活的概念":["42.18"],"ro":["42.19"],"确定属性和可选属性的类型都必须是它的类型的子集":["42.20"],"有时和":["42.24"],"很像":["42.24"],"union联合":["42.26"],"partialpoint":["42.26"],"y":["42.27"],"接口扩展类别名":["42.28"],"在定义泛型时通常用作第一个类型变量名称":["42.29"],"但实际上":["42.29"],"可以用任何有效名称代替":["42.29"],"trace":["42.30"],"报错":["42.32"],"argument":["42.32"],"not":["42.32","53.19"],"assignable":["42.32"],"parameter":["42.32"],"首先看泛型":["42.32"],"这里有t和k两种类型":["42.32"],"根据类型推断":["42.32"],"第一个参数person就是person":["42.32"],"类型会被推断为person":["42.32"],"而第二个数组参数的类型推断":["42.32"],"keyof关键字可以获取t":["42.32"],"也就是person的所有属性名":["42.32"],"即":["42.32"],"而extends关键字让泛型k继承了person的所有属性名":["42.32"],"所以当用户刷新页面时会向服务器发请求导致请求资源为404":["43.2"],"因此需要对nginx进行一个配置":["43.2"],"需要把所有路由都重定向到根页面":["43.2"],"router就会依据路由表当中声明了的路由对应匹配的组件":["43.3"],"值变化不会导致浏览器向服务器发出请求":["43.4"],"模式是用":["43.4"],"popstate":["43.5"],"replace":["43.6","59.6"],"在每次路由跳转后执行":["43.7"],"用于执行一些异步操作":["43.7"],"比如向服务器发送数据":["43.7"],"埋点等":["43.7"],"beforeenter":["43.7"],"一般配置在路由配置文件中":["43.7"],"对进入某个路由之前进行相关操作":["43.7"],"aftereach":["43.8"],"钩子":["43.8"],"触发":["43.8"],"更新":["43.8"],"即在需要的时候的时候进行加载":["43.9"],"也就是":["43.9"],"被作为分离的模块起点":["43.10"],"意思是":["43.10"],"views":["43.11"],"替换成":["43.11"],"并且它可以在路由地址和导航守卫上都被访问到":["43.12"],"然后在接下来的":["43.13"],"组件生命周期钩子中获取数据":["43.13"],"在数据获取期间显示":["43.13"],"的查询字符串传递的键值对":["43.14"],"路由对象参数":["43.14"],"路由":["44.1"],"只在第一次加载页面时":["44.2"],"dom挂载完成调用":["44.3","52.0"],"beforeupdate":["44.3","52.0"],"onbeforeupdate":["44.3","44.5","52.0"],"数据更新之前被调用":["44.3"],"updated":["44.3","44.5"],"setup执行时机在组件实例创建之前":["44.4"],"内存中的数据已经改变":["44.5"],"页面上的还没更新":["44.5"],"对组件的编辑次数":["44.5"],"甚至跟踪创建撤销功能的操作很有用":["44.5"],"父beforeupdate":["44.6"],"子beforeupdate":["44.6"],"子updated":["44.6"],"一般在频繁切换状态的地方使用v":["44.8"],"所以这样就会导致无论需不需展示这个元素":["44.9"],"都会先遍历整个列表":["44.9"],"页面多次使用addsum":["44.10"],"但是只会打印一次":["44.10"],"内部逻辑执行":["44.10"],"并在依赖发生变化时重新计算computed属性的值":["44.12"],"它可以监听特定数据的变化":["44.13"],"并在变化发生时触发回调函数":["44.13"],"这使得它能够处理异步操作":["44.13"],"的依赖追踪机制为基础":["44.14"],"当某个依赖数据发生变化时":["44.14"],"被观察者":["44.15"],"其内部监听的对象必须是已经定义响应式的属性":["44.16"],"在前":["44.17"],"将render":["44.17"],"中":["44.18"],"计算属性工作是做依赖收集":["44.18"],"watch":["44.19"],"当回调函数里面的响应数据发生变化":["44.20"],"回调函数就会立即执行":["44.20"],"watcheffect只能看到新值看不到旧值":["44.20"],"vue2将响应式数据放到data函数中":["44.21"],"而vue3则是使用ref和reactive将数据声明为响应式":["44.21"],"响应式实现方式":["44.21"],"在初始化阶段会创建":["44.22"],"它是一个轻量级的内存中表示真实":["44.22"],"结构的":["44.22"],"javascript":["44.22"],"对象树":["44.22"],"当访问或修改这些属性时":["44.23"],"可以捕捉到":["44.23"],"并执行相应的逻辑":["44.23"],"prototype方法的修改":["44.24"],"或者app":["44.25"],"具名插槽内容":["44.26"],"在slot标签绑定属性从而传递给父组件中的插槽内容":["44.26"],"首先来看下默认插槽的传值方式":["44.26"],"作用域slot":["44.27"],"scope":["44.27"],"slot":["44.27"],"子组件访问父组件":["44.27","52.4"],"这允许我们通过ref来访问和操作dom元素":["44.31"],"例如修改样式":["44.31"],"添加事件监听器或执行其他dom操作":["44.31"],"父":["44.32"],"vuex除了上面三个概念还有getters":["44.33"],"moudles":["44.33"],"getters就像vue中的计算属性computed一样用来描述依赖响应式状态state中的复杂逻辑":["44.33"],"moudles则是可以将store分割成模块":["44.33"],"module":["44.33"],"getters":["44.34"],"changenames":["44.34"],"states":["44.35"],"孙悟空":["44.35"],"usercomputed":["44.35"],"它接收组件的名字数组":["44.37"],"字符串或者正则":["44.37"],"当我们使用动态组件component或者路由router":["44.37"],"view的时候可以使用":["44.37"],"beforemount":["44.38"],"和destroyed":["44.39"],"组件销毁":["44.39"],"哪个组件需要用到时":["44.40"],"直接将提取的这部分混入到组件内部即可":["44.40"],"mixin的生命周期会在父组件生命周期之前执行":["44.40"],"的代理行为是在破坏原对象的基础上实现的":["44.41"],"popup":["44.43"],"fallback":["44.44"],"确保在访问更新后的":["44.46"],"时是准确的":["44.46"],"然后使用虚拟节点树进行渲染":["44.48"],"当某些状态发生变更时会生成新的虚拟dom节点树":["44.48"],"时间复杂度太高":["44.49"],"因此前端框架规定了只做同层":["44.49"],"还有":["44.49"],"双端比较":["44.50"],"的策略":["44.50"],"同时从新旧虚拟dom树的头部和尾部开始比较子节点":["44.50"],"以尽可能地复用已有的dom节点":["44.50"],"递归处理子节点":["44.50"],"继续递归地应用diff算法":["44.50"],"meal":["44.51"],"self":["44.52"],"可能无法获取到最新的结果":["44.53"],"因为组件的更新是异步执行的":["44.53"],"需要等待下一次":["44.53"],"更新循环结束后才能获取到更新后的":["44.53"],"for不写key默认是index":["44.54"],"fallback是占位符":["44.55"],"当异步组件一些耗时的任务是":["44.55"],"ref需要用value读取更新值":["44.56"],"子":["44.57"],"bind也是单向绑定":["44.59"],"双向绑定":["44.59"],"而真正的双向数据流":["44.60"],"比如angularjs":["44.60"],"是允许在子组件中直接更新父组件的值的":["44.60"],"渲染内容堵塞了":["44.61"],"在webpack的config文件中":["44.62"],"修改commonschunkplugin的配置":["44.62"],"里面放着所有的项目需要的资源":["44.63"],"属性决定编写的样式是否局部有效":["44.64"],"观察者":["45.2"],"observer":["45.2"],"channel":["45.3"],"订阅者":["45.3","45.5"],"发布订阅模式":["45.3","45.24"],"将依赖收集的目标对象设置成自身":["45.4"],"绑定当前":["45.4"],"实例进行一次函数执行":["45.4"],"在运行过程中收集函数中用到的数据":["45.4"],"此时会在所有用到数据的":["45.4"],"依赖管理中插入该观察者实例":["45.4"],"函数执行完毕后将依赖收集目标清空":["45.4"],"避免重复收集":["45.4"],"依赖收集器":["45.5"],"depend":["45.8","45.15"],"如果value是对象":["45.9"],"递归调用observe来监测该对象":["45.9"],"如果value不是对象":["45.9"],"observe函数会直接返回":["45.9"],"创建了arraymothods的对象以object":["45.10"],"巧妙之处":["45.11"],"watcher设置在全局中读取数据":["45.11"],"因为读取了数据":["45.11"],"所以触发getter方法":["45.11"],"通知组件":["45.12"],"通过虚拟dom和diff算法进行页面更新":["45.12"],"初始化watcher实例时订阅数据":["45.13"],"一个属性可能有多个依赖":["45.14"],"每个响应式数据都有一个dep来管理它的依赖":["45.14"],"要通知到的地方":["45.14"],"依赖":["45.14"],"本次新增":["45.15"],"newval":["45.15"],"的局限性":["45.16"],"采用了全新的":["45.16"],"deleteproperty":["45.17"],"方法会调用":["45.18"],"track":["45.18"],"进行依赖收集":["45.18"],"isobject":["45.19"],"如果当前获取的属性值是一个对象":["45.19"],"则继续将为此对象创建":["45.19"],"代理":["45.19"],"方法":["45.20"],"has":["45.21"],"副作用是一个函数包裹器":["45.23"],"在函数被调用前就启动跟踪":["45.23"],"只能针对对象的已知属性进行读取和更新的操作拦截":["45.24"],"都是通过":["45.24"],"unwrapref":["45.25"],"其实也会通过":["45.26"],"reactive":["45.26","62.0"],"方法进行深层数据处理":["45.26"],"与":["45.26"],"readonly":["45.26"],"则比较相似":["45.26"],"effect":["45.27"],"fn":["45.27","59.8"],"dep":["45.29"],"proxy的get对应reflect":["45.34"],"自动聚焦的指令":["46.2"],"directive":["46.2"],"如果有的话":["46.3"],"参数是":["46.3"],"modifiers":["46.3"],"一个包含修饰符的对象":["46.3"],"bar":["46.3"],"修饰符对象是":["46.3"],"则指令将会被忽略且抛出一个警告":["46.4"],"组件的一个根结点就是在一个":["46.4"],"vdebounce":["46.6"],"指令地址":["46.6"],"body":["47.0","63.0"],"slots":["50.1"],"default":["50.1"],"rowindex":["50.1"],"clearable":["50.2"],"transfer":["50.2"],"filterable":["50.2"],"placeholder":["50.2"],"请选择检查级别":["50.2"],"checkbox":["50.3"],"change":["50.3"],"handlerowselection":["50.3"],"all":["50.3"],"modal":["50.4"],"operflagtitle":["50.4"],"这可以通过提供组件属性":["51.0"],"主题配置":["51.0"],"样式覆盖或插槽等方式来实现":["51.0"],"放弃目标版本之后的提交":["51.2"],"8d":["51.3"],"ba":["51.3"],"bc":["51.3"],"8f":["51.3"],"那样对整个项目进行重新构建":["51.5"],"请求的选项中的":["51.6"],"函数循环执行":["51.7"],"pipe":["51.7"],"onmounted":["52.0"],"在created时":["52.1"],"data必须是一个函数且返回一个对象":["52.2"],"parent":["52.4","71.14"],"父组件访问子组件":["52.4"],"用this获取数据":["52.6"],"才会重新计算":["52.7"],"栈是一种":["53.2"],"线性数据结构":["53.2"],"栈后进先出":["53.2"],"的顺序存储":["53.2"],"他们都有各自的队列":["53.4"],"执行宏任务期间产生的微任务会放入微任务队列":["53.4"],"无连接":["53.5"],"抓包":["53.7"],"packet":["53.7"],"fuillied到rejected状态不可变":["53.8"],"脚本存在服务器里":["53.9"],"脚本在服务器返回":["53.9"],"sayhi":["53.12"],"length":["53.13","61.0","69.1","69.7","72.6","76.4"],"拷贝一份path":["53.14","59.9"],"加入解集res":["53.14","59.9"],"结束当前递归分支":["53.14","59.9"],"for枚举出每个可选的选项":["53.14","59.9"],"continue":["53.14","59.9"],"svg是一种基于矢量图形的绘图技术":["53.16"],"使用xml格式描述图形":["53.16"],"dataurl":["53.17"],"canvas":["53.17"],"会返回一个":["53.19"],"modified":["53.19"],"状态码":["53.19"],"不受实际物理内存大小的限制":["53.20"],"这样":["53.20"],"存储长期使用的数据":["53.22"],"页面关闭还会存在":["53.22"],"扩展进程":["53.23"],"每个进程有多个线程":["53.23"],"chrome浏览器将多标签设计为多进程":["53.23"],"修正每次时间间隔":["53.25"],"如果有则表示该组件有缓存":["53.26"],"即命中缓存":["53.26"],"直接从缓存中拿":["53.26"],"vnode":["53.26"],"拆分合并":["53.27"],"isarray":["53.30","76.7"],"客户端发起请求":["53.34"],"服务器返回304":["53.35"],"不返回内容":["53.35"],"浏览器直接使用本地缓存":["53.35"],"版本问题":["53.37"],"双指针":["53.38"],"更换域名vscode":["55.0"],"quokka":["55.1"],"使用includes":["56.0"],"遍历数组":["56.0"],"返回值不同":["56.2"],"watch的回调函数接收两个参数":["56.2"],"新值和旧值":["56.2"],"没有返回值":["56.2"],"这对于需要监听嵌套对象或数组的变化非常有用":["56.3"],"异步操作":["56.3"],"由于watch是在数据变化后立即执行的":["56.3"],"可以利用它来处理异步操作":["56.3"],"justify":["56.6"],"不保留原有的空间占位":["56.10"],"fixed":["56.10"],"元素的定位相对于浏览器窗口进行定位":["56.10"],"即使页面滚动":["56.10"],"元素仍然固定在相同的位置":["56.10"],"将数据传递给子组件":["56.11"],"但子组件不能直接修改父组件的数据":["56.11"],"并发和并行执行异步操作使得在同一时间可以执行多个操作":["56.12"],"从而实现并发和并行处理":["56.12"],"pending":["56.13"],"进行中":["56.13"],"已完成":["56.13"],"存储异步任务的队列":["56.14"],"常见的有宏任务队列如settimeout":["56.14"],"dom事件":["56.14"],"一定事件循环周期内":["56.15"],"date":["59.2"],"now":["59.2"],"john":["59.4","65.2"],"age":["59.4","65.1","65.6"],"syumbol等特殊类型的对象":["59.5"],"如果对象中存在循环引用":["59.5"],"返回长度":["59.7"],"maxlength":["59.7"],"error":["60.0"],"将每个元素都转换为":["61.1"],"foreach":["62.0"],"handler":["62.0"],"receiver":["62.0"],"john3":["65.5"],"j":["66.2","66.3","66.4"],"开始依次与之前的元素比较":["66.3"],"temp":["66.4"],"第二步及其后续":["67.1"],"此时temp":["67.1"],"next指向的是原链表第一个值":["67.1"],"把原链表第二个值的next指到了temp":["67.1"],"next的位置也就是指到了原链表第一个值":["67.1"],"转字符串":["67.2"],"递归":["67.3"],"当a走到头时a指向headb":["67.4"],"当b走到头时b指向heada":["67.4"],"最终会碰到一起":["67.4"],"则那个节点就是要找的节点":["67.4"],"set集合":["67.5"],"newhead":["67.6"],"listnode":["67.6","67.7"],"prehead":["67.7"],"prev":["67.7"],"不修改则插入":["69.2"],"splice":["69.4","73.1","73.2"],"isprime":["69.6"],"bucket":["69.7"],"floor":["70.1"],"bin":["70.1"],"满足以下性质":["71.1"],"非空左子树的所有键值小于其根结点的键值":["71.1"],"我们可以做什么事情呢":["71.2"],"通过先序遍历方式遍历所有结点":["71.3"],"postordertraverse":["71.3"],"通过后序遍历方式遍历所有结点":["71.3"],"root":["71.4","71.13"],"node":["71.4"],"向左查找":["71.5"],"处理经过节点的左子节点":["71.7"],"处理左子树中的节点":["71.8"],"处理右子树中的节点":["71.9"],"while循环":["71.11"],"isleftchild":["71.14"],"情况3":["71.15","71.16"],"非叶子结点":["71.15"],"有两个节点":["71.15"],"递归删除函数":["71.15"],"next":["72.1","72.8"],"current":["72.2","72.4","72.5"],"当current":["72.2"],"next不为空时":["72.2"],"情况二":["72.4"],"previous":["72.8"],"break":["73.1","73.2"],"isempty":["74.1"],"dequeue":["74.2"],"result6":["75.1"],"result7":["75.2"],"result8":["75.3"],"item":["75.4","75.5","75.9","75.14"],"填充一个数组到最后":["75.13"],"然后展平":["75.13"],"的空数组":["75.16"],"这意味着一个由":["75.16"],"个空槽组成的数组":["75.16"],"而不是具有实际":["75.16"],"result20":["75.19"],"result22":["75.22"],"result24":["75.23"],"result25":["75.24"],"result28":["75.26"],"result32":["75.29"],"infinity":["76.1"],"math":["77.2"],"cur":["77.4","77.5"],"reduce":["77.5"],"pre":["77.5"],"在组件内挂载之后只需要引用下面这行代码":["78.3"],"你就可以看到流光按钮啦":["78.3"],"添加圆角":["79.1"],"mount":["79.2"],"l":["79.3"],"刷新":["79.8"],"success":["79.8"],"br":["80.7"],"model":["80.8"],"saoyisao":["82.1"],"shibai":["82.1"],"shengyinguanbi":["82.1"],"shangchuan":["82.1"],"shezhi":["82.1"],"选择你想要的图标":["82.3"],"apple":["82.4"],"color":["82.5"],"适合多列等高布局":["85.2"],"设置宽度":["85.2"],"都不起作用":["85.2"],"td标签":["85.2"],"td":["85.2"],"tel":["85.5"],"服务器目前从不同位置的网页响应请求":["85.6"],"unshift":["85.7"],"reverse":["85.7"],"区域内的部分显示":["85.8"],"可以转换为字符串类型":["85.12"],"var没有":["85.13"],"块级作用域输出3":["85.13"],"box":["85.14"],"transition":["85.14"],"触发inpute事件":["85.15"],"使用浮动时先写left再写right再写中间的":["85.18"],"或者":["86.1"],"待更新":["90.0"],"鹏之徙于南冥也":["90.0"],"组件库":["91.0"]},{"0":["16.47","26.4","42.19","50.1","56.0","66.3","66.4","77.1"],"1":["16.9","19.11","19.66","19.67","36.3","45.2","45.21","59.6"],"2":["1.13","1.14","1.15","1.16","1.19","1.20","3.8","5.2","6.16","6.18","11.9","14.0","14.6","20.18","20.22","28.1","28.17","34.20","36.2","36.16","43.13","44.20","45.17","46.2","70.0","71.1","75.9"],"3":["0.4","1.17","3.2","5.14","6.11","6.15","7.2","8.1","9.5","9.26","9.27","14.6","14.13","16.3","16.13","16.24","16.43","17.10","19.12","19.14","19.38","21.1","23.2","30.1","41.0","44.17","44.31","44.37","44.40","45.34","56.13","70.0","71.7","71.8","71.9"],"4":["1.30","2.7","3.5","3.9","5.8","6.13","6.15","9.34","11.7","11.16","19.39","19.42","19.73","27.0","30.4","32.0","32.4","35.2","35.4","43.6","43.14","44.14","44.21","44.34","44.37","44.41","45.18","51.1","51.5","56.12","56.14"],"5":["2.10","5.7","6.9","6.14","6.19","7.5","9.25","15.7","16.3","16.8","16.9","16.22","16.32","19.30","19.50","21.8","21.10","26.1","30.8","34.22","41.1","45.11","46.3","51.0","52.5","53.28","56.3","56.10","75.4","75.5","75.14"],"6":["4.0","16.22","22.5","44.1","46.3","55.1","76.0","77.0"],"7":["19.76","28.2","42.32","76.0","77.0"],"8":["28.2","75.11","75.20","75.28","75.31"],"9":["24.3","75.11","75.17","75.19","75.20","75.27","75.28","75.31"],"10":["9.23","16.4","16.9","42.15","75.8","75.11","75.12","75.20","75.27","75.28","75.31","75.32"],"11":["9.23","11.23","25.1"],"12":["9.23","16.35","42.19","43.8"],"13":["9.23"],"14":["9.23"],"17":["34.13"],"18":["11.12","44.26"],"20":["65.2","88.1"],"23":["16.28"],"25":["42.23","69.4"],"28":["41.5"],"37":["69.1"],"60":["16.13"],"77":["20.6"],"86":["51.3"],"90":["51.3"],"100":["11.6","16.25","16.30","21.5"],"401":["0.8"],"410":["9.23"],"411":["9.23"],"412":["9.23"],"413":["9.23"],"414":["9.23"],"456":["85.10"],"1000":["16.5","50.4"],"1998":["20.15"],"2000":["53.12"],"2019":["16.46"],"3000":["21.2"],"8080":["0.5"],"x":["0.1","16.30","16.47","19.58","42.10","51.7"],"return":["0.2","20.13","36.17","37.10","38.7","45.13","45.22","50.1","72.9","75.29","77.3","77.5","88.1"],"else":["0.2","19.51","19.52","21.5","38.8","66.5","71.13","76.5","77.4"],"throw":["0.2","17.12","17.13","36.9"],"error":["0.2","20.6","42.21"],"重新then":["0.2"],"读取数据":["0.2"],"对象转字符串":["0.3"],"post传输文件大理论没有限制":["0.4"],"get传输文件小大概7":["0.4"],"8k":["0.4"],"端口号不同":["0.5"],"app":["0.6","32.3","36.17"],"module":["0.6","41.1","52.5"],"exports":["0.6"],"use":["0.6","29.3"],"访问api下的资源":["0.6"],"target":["0.6","45.14","45.25"],"主地址":["0.6"],"changeorigin":["0.6"],"true":["0.6","0.8","19.27","20.4","20.16","20.20","22.3","36.5","38.2","72.9"],"使用":["0.6","9.37","19.28"],"useeffect":["0.6"],"axios":["0.6"],"get":["0.6","0.10","22.7","45.9"],"status":["0.8"],"retry":["0.8"],"发送请求以刷新token":["0.8"],"tokenrefreshrequest":["0.8"],"post":["0.8"],"refresh":["0.8"],"then":["0.8","19.13","21.2","21.9","61.1"],"如果刷新token成功":["0.8"],"更新本地存储或全局状态管理中的token值":["0.8"],"post等方法进行一个再次封装":["0.9"],"使用起来更为方便":["0.9"],"请求拦截器":["0.9"],"根据请求的请求头设定":["0.9"],"xxxx":["0.10"],"绝对定位配合transform实现":["1.1"],"推荐":["1.1"],"触发合成层优化性能":["1.1"],"浮动元素":["1.2"],"使用父元素设置":["1.2"],"overflow":["1.2"],"caption":["1.3"],"flex":["1.3"],"inline":["1.3"],"content":["1.5","22.7","56.6"],"9999px":["1.6"],"超大负边距会将元素抛出视图":["1.6"],"因为定位本身脱离了文档流所以不占据空间":["1.6"],"translate":["1.6"],"区域外会隐藏":["1.7"],"为80px":["1.8"],"那么子元素1em就表示大小和父元素一样为80px":["1.8"],"就等于可视窗口高度的百分之一":["1.9"],"对于":["1.9"],"position":["1.9","6.10"],"absolute":["1.9","2.10"],"宽度为10倍基准字体大小":["1.10"],"height":["1.10"],"5rem":["1.10"],"高度为5倍基准字体大小":["1.10"],"如果一条轴线排不下":["1.11"],"如何换行":["1.11"],"flow属性是flex":["1.11"],"direction属性和flex":["1.11"],"wrap属性的简写形式":["1.11"],"指定了对应元素的收缩规则":["1.12"],"只有在所有元素的默认宽度之和大于容器宽度时才会触发":["1.12"],"basis为0":["1.13","1.15"],"auto是根据内容的大小来分":["1.14"],"basis为auto":["1.16"],"repeat":["1.17"],"200px":["1.17"],"gap":["1.17"],"ellipsis":["1.18"],"repaint":["1.19","6.14"],"left属于布局属性":["1.19"],"该属性的变化会导致重排":["1.19"],"该元素并不脱离文档流":["1.20"],"仍然保留元素原本在文档流中的位置":["1.20"],"当元素在容器中被滚动超过指定的偏移值时":["1.20"],"元素在容器内固定在指定位置":["1.20"],"而space":["1.21"],"around是每个子项目左右方向的":["1.21"],"margin":["1.21","2.1"],"相等":["1.21"],"设置动画在启动前的延迟间隔":["1.22"],"iteration":["1.22"],"count":["1.22","14.6","14.10","14.13","16.33","69.2","69.4"],"定义动画的播放次数":["1.22"],"img":["1.23"],"它们一般用于包裹文本或者嵌套在块级元素中":["1.24"],"默认样式":["1.24"],"lowercase":["1.25"],"self":["1.26"],"属性定义flex子项单独在侧轴":["1.26"],"纵轴":["1.26"],"方向上的对齐方式":["1.26"],"fill":["1.27"],"mode":["1.27"],"last":["1.30"],"选择作为父元素的最后一个子元素的元素":["1.30"],"nth":["1.30"],"n":["1.30"],"选择作为父元素的第n个子元素的元素":["1.30"],"表单伪类选择器":["1.30"],"form":["1.30","6.18"],"line":["1.31","82.4"],"选择元素的第一行":["1.31"],"增加或减少单词间的空白":["1.32"],"letter":["1.32"],"增加或减少字符间的空白":["1.32"],"transform":["1.32","6.14"],"合理使用选择器":["1.34"],"减少使用昂贵的属性":["1.34"],"如果设备的属性或特征发生改变":["1.35"],"如屏幕旋转":["1.35"],"属性上下左右边框交界处会呈现出平滑的斜线这个特点":["2.0"],"或者":["2.1"],"auto":["2.2"],"居中方式失效":["2.2"],"给父级添加":["2.2"],"而ie盒模型的大小计算方式是":["2.3"],"元素的内容区域":["2.3"],"不计算外边距":["2.4"],"表示使用标准盒模型":["2.5"],"移动或者给页面中的dom节点添加动画":["2.6"],"添加一个样式表":["2.6"],"调整样式属性":["2.6"],"缺点就是兼容性并不好":["2.7"],"小图使用":["2.7"],"png":["2.7","44.63"],"渐变":["2.8"],"线性渐变":["2.8"],"径向渐变":["2.8"],"字体":["2.8"],"font":["2.8","6.8","16.35"],"face":["2.8"],"600px":["2.9"],"body":["2.9"],"background":["2.9"],"定位position":["2.10"],"利用绝对定位的方式":["2.10"],"好处":["2.10"],"这种实现方式的三栏html结构可以任意摆放":["2.10"],"不用考虑先后次序":["2.10"],"直接导入并执行模块中的代码":["3.3"],"默认导入时的接收名称可以任意名称":["3.4"],"关键字进行重命名":["3.5"],"全局作用域中":["3.6"],"var声明的变量":["3.6"],"通过function声明的函数":["3.6"],"中新增了块级作用域":["3.7"],"使用let声明的变量只能在块级作用域里访问":["3.7"],"有":["3.7"],"暂时性死区":["3.7"],"的特性":["3.7"],"而箭头函数是不可以的":["3.9"],"类名":["3.11","15.2"],"构造函数和方法":["3.11"],"括起来":["3.12"],"在用import接受的时候也得用":["3.12"],"接受":["3.12"],"iterator":["3.14","26.1"],"函数默认返回一个迭代器对象":["3.14"],"可以通过":["3.14"],"entries":["3.15"],"函数":["3.15","36.10","44.34"],"函数的参数设置默认值":["3.15"],"函数的length属性":["3.15"],"for":["4.0","16.41","16.47","56.0"],"keyfor":["4.0"],"这里的symbol":["4.0"],"创建的都是symbol":["4.0"],"类型":["4.0","42.8","85.5"],"但是他们的创建机制有所不同":["4.0"],"的创建方式会在":["4.0"],"创建之前在全局中寻找":["4.0"],"有没有用symbol":["4.0"],"的方式":["4.0"],"并且key是":["4.0"],"dom树":["5.1"],"栈结构":["5.2"],"该":["5.2"],"栈主要用来计算节点之间的父子关系":["5.2"],"在第一个阶段中生成的":["5.2"],"会被按照顺序压到这个栈中":["5.2"],"通过分词器产生的新":["5.2"],"就这样不停地压栈和出栈":["5.2"],"整个解析过程就这样一直持续下去":["5.2"],"直到分词器将所有字节流分词完成":["5.2"],"解析为":["5.2"],"最终css":["5.3"],"cssom":["5.3"],"会开启一个预解析线程":["5.4"],"用来分析":["5.4"],"html":["5.4"],"defer":["5.5"],"html所有资源都加载完毕之后":["5.6"],"load":["5.6"],"加载图片等外部文件":["5.7"],"将不会依赖于任何js和css的执行":["5.8"],"此js下载完成后立刻执行":["5.8"],"不会修改dom和样式的js":["5.8"],"故不必依赖其它的js和css":["5.8"],"html转换为dom":["5.8"],"css转换为cssom":["5.8"],"文档解析完成之后才开始构建":["5.9"],"会一边加载":["5.10"],"树开始从头到尾执行一遍流程":["5.12"],"需要更新":["5.12"],"对象模拟":["5.13"],"节点的好处是":["5.13"],"页面的更新可以先全部反映在":["5.13"],"对象":["5.13","23.1","26.1","44.34"],"将两个虚拟":["5.14"],"vdom":["5.16"],"create":["5.16","20.26"],"表示当前页面的":["5.17"],"url":["5.17","5.19","9.22"],"信息":["5.17"],"提供了操作和访问":["5.17"],"从当前节点中移除指定的子节点":["5.18"],"addeventlistener":["5.18","19.45"],"type":["5.18","41.4","44.49","79.3"],"listener":["5.18"],"注册事件监听器":["5.18"],"获取或设置文档的标题":["5.19"],"返回当前文档的完整":["5.19"],"检查是否存在指定属性名的属性":["5.20"],"removeattribute":["5.20"],"包括内容区域和内边距":["5.21"],"不包括滚动条":["5.21"],"边框和外边距":["5.21"],"clientheight":["5.21"],"获取元素的内部高度":["5.21"],"scrollwidth":["5.21"],"获取元素内容的总宽度":["5.21"],"innerhtml":["5.22"],"innertext":["5.22"],"方法和属性":["5.23"],"方法设置的定时器":["5.24"],"clearinterval":["5.24"],"intervalid":["5.24"],"获取关于用户屏幕的信息":["5.25"],"如屏幕宽度":["5.25"],"高度等":["5.25"],"bubbling":["5.27"],"bubbles":["5.27","5.28"],"cancelable":["5.28"],"此时":["6.1"],"大部分浏览器将开启最大兼容模式来解析网页":["6.1"],"而b是展示强调内容":["6.2"],"是italic":["6.2"],"斜体":["6.2"],"的简写":["6.2"],"行内元素":["6.3"],"和其它元素都会在一行显示":["6.3"],"高":["6.3"],"行高以及外边距和内边距可以设置":["6.3"],"宽度就是文字或者图片的宽度":["6.3"],"不能改变":["6.3"],"行级元素只能容纳文本或者其它行内元素":["6.3"],"female":["6.4"],"女":["6.4","14.10"],"还有邮件等等":["6.5"],"当然":["6.5"],"title表示标题标签":["6.6"],"description是描述标签":["6.6"],"js":["6.7","32.0","75.16"],"if":["6.7","16.19","42.4","42.8","45.7","45.8","53.35","61.0","66.2","69.5","69.7"],"拖拽释放":["6.8"],"移除的元素":["6.8"],"纯表现的元素":["6.8"],"basefont":["6.8"],"s":["6.8","59.6"],"计算元素位置":["6.9"],"绘制网页repaint":["6.9"],"hidden":["6.10"],"定位":["6.10"],"便会触发重排":["6.11"],"不会触发":["6.13"],"layout":["6.13"],"paint":["6.13"],"提升合成层的最好":["6.13"],"元素提升为合成层后":["6.14"],"使用iframe元素":["6.15"],"将一些常用的元素或动画效果放置在iframe中":["6.15"],"可以减少对页面的影响":["6.15"],"浏览器的自动层压缩并不是万能的":["6.16"],"有很多特定情况下":["6.16"],"的条件":["6.17"],"也就是说让其他元素不要和合成层元素重叠":["6.17"],"语义元素":["6.18"],"语义化使得代码更具有可读性":["6.19"],"让其他开发人员更加理解你的html结构":["6.19"],"减少差异化":["6.19"],"可以有自己的css样式":["6.20"],"javascript脚本等":["6.20"],"安全性":["6.20"],"iframe元素中嵌入的文档来自其他域名或者服务器":["6.20"],"内容建设方案":["7.1"],"用户互动传播":["7.1"],"描述":["7.2"],"尽量覆盖每个关键词":["7.3"],"通过这样的方式":["7.4"],"域名选择":["7.5"],"后缀选择":["7.5"],"一般选择":["7.5"],"com":["7.5","80.7"],"行为":["8.1"],"gt":["8.2"],"任何与号":["8.2"],"不是实体的一部分的":["8.2"],"amp":["8.2"],"使结构与表现分离":["8.3"],"标签的id和class等属性命名要做到见文知义":["8.3"],"标签越少":["8.3"],"如请求的文件":["9.1"],"错误消息":["9.1"],"或者其它信息":["9.1"],"客户端":["9.1"],"服务器":["9.1"],"无状态是指协议对于事物处理没有记忆能力":["9.2"],"不对请求和响应之间的通信状态进行保存":["9.2"],"缺少状态意味着如果后续处理需要前面的信息":["9.2"],"则它必须重传":["9.2"],"smtp":["9.3"],"udp":["9.3"],"重传的过程可能会导致数据传输的阻塞":["9.4"],"关闭连接阻塞":["9.4"],"信息是明文传输":["9.5"],"https则是具有安全性的":["9.5"],"加密传输协议":["9.5"],"http的连接很简单":["9.5"],"如果证书验证通过":["9.6"],"客户端会生成一个随机的对称密钥":["9.6"],"并使用服务器的":["9.6"],"公钥对其进行加密":["9.6"],"然后将":["9.6"],"从而提高性能并减少延迟":["9.9"],"这对于加载复杂网页或处理大量资源请求时特别有用":["9.9"],"2还引入了":["9.9"],"头部压缩":["9.9"],"如果发现某些头部字段和值是自定义的或者是没出现过的新内容":["9.11"],"那么可以将这些新内容添加到动态表中":["9.11"],"并生成对应的索引":["9.11"],"或者已经缓存了相同资源的情况下":["9.12"],"就近访问cdn的缓存代理":["9.13","53.21"],"缓存代理":["9.13","53.21"],"缓存系统会有选择地缓存那些最常用的那些资源":["9.13","53.21"],"命中率":["9.13","53.21"],"与":["9.16"],"方法一样":["9.16"],"都是向服务器发出指定资源的请求":["9.16"],"只不过服务器将不传回资源的本文部分":["9.16"],"它的好处在于":["9.16"],"使用这个方法可以在不必传输全部内容的情况下":["9.16"],"就可以获取其中关于该资源的信息":["9.16"],"服务器响应200":["9.17"],"返回数据":["9.17","53.34"],"而对于post":["9.17"],"浏览器先发送header预检请求":["9.17"],"服务器响应100":["9.17"],"continue":["9.17","69.7"],"发送包含未知字符的用户输入时":["9.18"],"用":["9.19"],"英文逗号":["9.19"],"分开":["9.19"],"length":["9.19","16.41","20.18","22.2","56.0","69.3","74.1"],"响应体的长度":["9.19"],"单位字节":["9.19"],"encoding":["9.19"],"响应体的编码格式":["9.19"],"gzip":["9.19"],"如果请求当中请求体":["9.20"],"那么在请求头当中的":["9.20"],"也就是所谓的重定向":["9.22"],"4xx":["9.22"],"服务器必须在响应中包含有关冲突的信息":["9.23"],"已删除":["9.23"],"如果请求的资源已永久删除":["9.23"],"服务器就会返回此响应":["9.23"],"需要有效长度":["9.23"],"服务器不接受不含有效内容长度标头字段的请求":["9.23"],"未满足前提条件":["9.23"],"服务器未满足请求者在请求中设置的其中一个前提条件":["9.23"],"请求实体过大":["9.23"],"服务器无法处理请求":["9.23"],"因为请求实体过大":["9.23"],"超出服务器的处理能力":["9.23"],"请求的":["9.23"],"uri":["9.23"],"过长":["9.23"],"通常为网址":["9.23"],"http协议":["9.25"],"服务器处理请求":["9.25"],"访问页面":["9.26"],"浏览器还会进行一些额外的操作":["9.26"],"服务器发送查询请求":["9.27"],"会应答一个报文给客户端":["9.33"],"服务端的接收":["9.33"],"发送能力是正常的":["9.33"],"此时服务端处于last":["9.34"],"ack的状态":["9.34"],"客户端收到":["9.34"],"和公网":["9.35"],"而":["9.36","45.23"],"没有这些开销":["9.36"],"传输效率较高":["9.36"],"应用场景":["9.36"],"适用于要求数据传输的可靠性和顺序性的应用":["9.36"],"如文件传输":["9.36"],"网页浏览":["9.36"],"电子邮件等":["9.36"],"适用于实时性要求较高":["9.36"],"不需要为每个客户端维护状态信息":["9.37"],"从而更容易实现负载均衡和横向扩展":["9.37"],"中":["9.38","34.13","52.6"],"需要在服务器上维护状态":["9.38"],"可以存储更多敏感的用户信息":["9.38"],"无状态的身份验证机制":["9.38"],"在用户":["9.38"],"服务器会生成一个加密的令牌":["9.38"],"并返回给客户端":["9.38"],"是进程中的执行单元":["9.39"],"应用程序交互":["10.1"],"例如在搜索框中输入特定的恶意代码":["10.1"],"攻击者可以构造包含恶意代码的搜索字符串":["10.1"],"当用户输入该字符串并提交搜索表单时":["10.1"],"恶意代码会在其浏览器中执行":["10.1"],"为了防止":["10.1"],"可以采取以下措施":["10.1"],"对用户输入的数据进行过滤和验证":["10.1"],"网络安全":["10.2"],"web应用程序的安全还涉及网络安全":["10.2"],"包括网络拓扑":["10.2"],"网络协议":["10.2"],"网络访问控制等方面":["10.2"],"这可以确保web应用程序免受网络层面的攻击":["10.2"],"如拒绝服务攻击":["10.2"],"dos":["10.2"],"用户当前已经登录的身份":["10.3"],"伪造请求并以用户的名义":["10.3"],"执行恶意操作":["10.3"],"例如cookie":["10.4"],"恶意请求发送":["10.4"],"恶意网页中的恶意代码会自动":["10.4"],"触发用户的浏览器向目标网站发送请求":["10.4"],"这些请求包含攻击者精心构造的参数和数据":["10.4"],"strict":["10.5","29.3"],"或":["10.5","22.4","25.0"],"lax":["10.5"],"以":["10.5"],"标记为":["10.6"],"这样它们就无法通过":["10.6"],"javascript":["10.6"],"sql服务器上解析执行进行的攻击":["10.7"],"development":["11.1"],"kit":["11.1"],"静态多态性":["11.2"],"通过重载实现":["11.2"],"相同的方法有不同的參数列表":["11.2"],"可以根据参数的不同":["11.2"],"包装类":["11.3"],"为了让基本类型也具有对象的特征":["11.5"],"就出现了包装类型":["11.5"],"a":["11.6","19.27","41.6","53.14","59.9","67.2","67.4"],"b":["11.6","41.6","53.14","59.9","67.2","75.29"],"system":["11.6","11.18","11.21","16.9","16.19","16.25","16.33"],"out":["11.6","11.18","11.21","16.9","16.25","16.33"],"直到垃圾收集器把它清除":["11.7"],"假如string类不是固定不变的":["11.7"],"那么这个密码可能会被改变":["11.7"],"导致出现安全隐患":["11.7"],"字符串常量池优化":["11.7"],"string对象创建之后":["11.7"],"会缓存到字符串常量池中":["11.7"],"因此是线程安全的":["11.8"],"不是线程安全的":["11.8"],"字符串字面量":["11.9"],"如果该字符串已经存在池中":["11.10"],"则返回其引用":["11.10"],"先进行hashcode":["11.11"],"的比较":["11.11"],"如果不相同":["11.11"],"new":["11.12","16.17","16.27","16.43","17.12","19.54","20.31","23.2","32.7","36.9","59.4","65.5","65.6","67.5"],"ljt":["11.12","74.2"],"sonmethod":["11.14"],"不同包的无关类":["11.15"],"内容可以改变":["11.16"],"eat":["11.17"],"抽象类存在构造方法的":["11.17"],"交给子类通过super进行访问":["11.17"],"抽象类可以有普通方法":["11.17"],"println":["11.18","16.9","16.15","16.25","16.33"],"inter3":["11.19"],"extends":["11.19","11.21","45.25"],"只能定义抽象方法":["11.20"],"没有":["11.20"],"override":["11.21"],"z":["11.22"],"tt":["11.23"],"优先执行":["11.23"],"this":["11.24","44.31","45.14","50.3","52.6","53.26","59.1","85.4"],"外部类的变量调用":["11.24"],"内部类直接访问外部类方法":["11.24"],"静态内部类":["11.24"],"static修饰的内部类":["11.24"],"static":["11.25","16.27","16.43","16.45","16.47","34.31"],"匹配一个非单词字符":["11.26"],"除了大小写字母":["11.26"],"下划线之外的字符":["11.26"],"等同于":["11.26"],"个":["11.26"],"表示匹配零个或多个字母":["11.26"],"表示匹配任何字符串":["11.26"],"表示匹配一个或多个字母":["11.26"],"结束方法":["11.28"],"将编译后的文件打包":["12.1"],"标准接口":["13.1"],"begin":["13.3"],"and":["13.3"],"end":["13.3"],"between":["13.3"],"order":["13.3","14.5"],"by":["13.3","14.6"],"desc":["13.3"],"插入":["13.3"],"insert":["13.3"],"into":["13.3"],"show":["14.0"],"dcl":["14.1"],"性别":["14.2"],"用户表":["14.2"],"约束":["14.2"],"非空约束":["14.2"],"not":["14.2","20.4"],"decimal":["14.3"],"cct":["14.4"],"cc涛":["14.4"],"改":["14.4"],"set":["14.4","22.10","45.7","45.9","45.19","67.5"],"eet":["14.4"],"in":["14.6","14.12","20.6","24.3","45.17"],"like":["14.6"],"查询三个字符的名字的员工":["14.6"],"匹配单个字符":["14.6"],"吕":["14.6"],"查询姓吕的员工":["14.6"],"匹配任意字符":["14.6"],"group":["14.6","14.10"],"聚合函数":["14.6"],"将一列数据作为一个整体纵向计算":["14.6"],"null不参与计算":["14.6"],"不计算null":["14.6"],"只计算非空":["14.6"],"max":["14.6","71.3"],"where不能对聚合函数进行判断":["14.7"],"男":["14.10"],"逻辑外连接":["14.11"],"学生":["14.12"],"having":["14.13"],"查询商务套餐a中包含了那些菜品":["14.13"],"套餐和菜品是多对多的关系":["14.13"],"需要通过中间表setmeal":["14.13"],"dish查询对应关系":["14.13"],"要么全部成功":["14.14"],"要么全部失败":["14.14"],"一致性":["14.14"],"事务完成时":["14.14"],"from":["14.15","37.8"],"删除":["14.15"],"提高优先级":["15.2"],"qualifier":["15.2"],"resource":["15.2"],"name":["15.2","19.47","42.1","44.57"],"切面":["15.3"],"aspect":["15.3"],"描述通知与切入点的对应关系":["15.3"],"返回后通知":["15.4"],"有异常不会执行":["15.4"],"num":["15.5","19.59"],"conditional开头的类":["15.7"],"条件判断":["15.7"],"conditional类":["15.7"],"按照一定的条件进行判断":["15.7"],"在满足给定条件后才会注册对应的bean对象到spring":["15.7"],"当一个线程试图获取一个对象锁":["16.1"],"而该对象锁被其他的线程持有":["16.1"],"则该线程进入blocked状态":["16.1"],"当该线程持有锁时":["16.1"],"该线程将变成runnable状态":["16.1"],"一个正在等待的线程的状态":["16.1"],"也称之为等待状态":["16.1"],"造成线程等待的原因有两种":["16.1"],"分别是调用object":["16.1"],"wait":["16.1"],"join":["16.1"],"方法":["16.1"],"处于等待状态的线程":["16.1"],"下面通过三个案例演示线程间中的状态转换":["16.2"],"时":["16.3","16.4","35.4"],"thread1和main线程主动休眠150毫秒":["16.3"],"所以在第150毫秒":["16.3"],"thread早已执行完毕":["16.3"],"执行object":["16.4"],"声明另一个线程进行解锁":["16.4"],"唤醒等待的线程":["16.4"],"main线程休眠10毫秒等待thread1线程能够苏醒":["16.4"],"获取thread1运行结束之后的状态":["16.4"],"t2":["16.5"],"线程开启之后的状态":["16.5"],"进入之后的状态":["16.5"],"为了提高性能":["16.6"],"我们就可以采用线程池":["16.6"],"线程池在启动的时":["16.6"],"会创建大量空闲线程":["16.6"],"这个消费者线程取出":["16.8"],"并且执行这个任务":["16.8"],"提交任务":["16.9"],"currentthread":["16.9","16.15"],"getname":["16.9","16.15"],"处理了任务":["16.9"],"使用无参构造方法创建线程池对象":["16.9"],"控制台输出结果":["16.9","16.21"],"我们可以看到5个任务是通过1个线程进行执行的":["16.11"],"说明此线程池中只存在一个线程对象":["16.11"],"案例4":["16.11"],"演示newsinglethreadscheduledexecutor方法所获取到的线程池的特点":["16.11"],"executorsdemo05":["16.11"],"演示":["16.11"],"newsinglethreadscheduledexecutor方法所获取到的线程池的第一个特点":["16.11"],"void":["16.13"],"main":["16.13","16.27","16.43","16.45","16.47"],"string":["16.13","16.27","16.43","16.45","16.47","73.1","73.2"],"args":["16.13","16.27","16.43","16.45","16.47"],"通过threadpoolexecutor创建一个线程池对象":["16.13"],"seconds":["16.13","16.28"],"比如重新招4个临时工人进来":["16.14"],"然后就将任务也分配":["16.14"],"给这4个临时工人做":["16.14"],"如果说着14个工人做任务的速度还是不够":["16.14"],"此时工厂主管可能就要考虑不再接收新的任务或者抛弃前面的一些任务了":["16.14"],"当这14个工人当中有人空闲时":["16.14"],"而新任务增长的速度":["16.14"],"thread":["16.15","16.23","17.13"],"执行了任务":["16.15"],"初次debug方式启动线程":["16.15"],"查看变量值":["16.15"],"1571735388181":["16.15"],"由于此时还没有提交任务":["16.15"],"因此线程池中的线程数量为0":["16.15"],"工作队列的任务数量也为0":["16.15"],"控制台没有报错":["16.16"],"案例演示3":["16.16"],"discardoldestpolicy任务处理策略":["16.16"],"定义一个变量":["16.16"],"来指定指定当前执行的任务":["16.16"],"这个变量需要被final修饰":["16.16"],"final":["16.16","16.39"],"y":["16.16"],"start":["16.17","16.19"],"在main线程中获取开启的线程中flag的值":["16.17"],"while":["16.17","16.19","16.36","71.11","72.4","72.5","72.7","72.8"],"每一个线程还存在自己的工作内存":["16.18"],"线程的工作内存":["16.18"],"保留了被线程使用的变量的工作副本":["16.18"],"main方法":["16.19"],"isflag":["16.19"],"flag":["16.21"],"工作原理说明":["16.21"],"main线程工作内存中的flag变量副本失效":["16.22"],"main线程再次使用flag时":["16.22"],"main线程会从主内存读取最新的值":["16.22"],"放入到工作内存中":["16.22"],"然后在进行使用":["16.22"],"总结":["16.22"],"volatile保证不同线程对共享变量操作的可见性":["16.22"],"也就是说一个线程修改了volatile修饰的变量":["16.22"],"当修改写回主内存时":["16.22"],"另外一个线程立即看到最新的值":["16.22"],"但是volatile不保证原子性":["16.22"],"关于原子性问题":["16.22"],"我们在下面的小节中会介绍":["16.22"],"volatile与synchronized的区别":["16.22"],"volatile只能修饰实例变量和类变量":["16.22"],"而synchronized可以修饰方法":["16.22"],"以及代码块":["16.22"],"volatile保证数据的可见性":["16.22"],"线程b工作内存中对count执行了":["16.24"],"1操作":["16.24"],"但是未刷新之主内存中":["16.24"],"此时cpu的执行权切换到了a线程上":["16.24"],"volatile关键字在什么情况下进行使用呢":["16.26"],"throws":["16.27","20.6"],"interruptedexception":["16.27","17.12","17.13"],"创建线程任务类对象":["16.27","16.43"],"不断进行数据采集":["16.28"],"将采集到的数据设置给温度传感器":["16.28"],"采集到的数据为":["16.28"],"线程休眠2秒":["16.28"],"模拟每隔两秒采集一次数据":["16.28"],"环境温度改变":["16.28"],"测试类":["16.28"],"的解决方案":["16.29"],"synchronized":["16.30","16.39"],"incrementandget":["16.33"],"线程1重新获取内存值v作为当前a的值":["16.35"],"并重新计算想要修改的新值":["16.35"],"此时对线程1来说":["16.35"],"这个重新尝试的过程被称为":["16.35"],"color":["16.35"],"red":["16.35","82.5"],"调用本类的weakcompareandsetint方法实现比较在交换":["16.36"],"atomicinteger对象":["16.36"],"相当于旧的预期值a":["16.36"],"新值b":["16.36"],"weakcompareandsetint":["16.36"],"总是假设最好的情况":["16.37"],"每次去拿数据的时候都认为别人不会修改":["16.37"],"所以不会上锁":["16.37"],"private":["16.39"],"transient":["16.39"],"entry":["16.39"],"table":["16.39"],"entry类的定义":["16.39"],"hash":["16.39"],"当前key的hash码值":["16.39"],"key":["16.39","71.4","71.8","75.22"],"键":["16.39","71.3"],"value":["16.39","22.9","62.0","75.23"],"值":["16.39"],"next":["16.39","43.8","72.2"],"下一个节点":["16.39"],"存储数据":["16.39"],"获取数据":["16.39"],"object":["16.39","45.25","85.11"],"获取长度":["16.39"],"对应的结构如下图所示":["16.39"],"1571905221097":["16.39"],"hashtable保证线程安全性的是使用方法全局锁进行实现的":["16.39"],"在线程竞争激烈的情况下hashtable的效率非常低下":["16.39"],"因为当一个线程访问hashtable的同步方法":["16.39"],"其他线程也访问hashtable":["16.39"],"的同步方法时":["16.39"],"会进入阻塞状态":["16.39"],"如线程1使用put进行元素添加":["16.39"],"线程2不但不能使用put方法添加元素":["16.39"],"也不能使用get方法来获取元素":["16.39"],"所以竞争越激烈效率越低":["16.39"],"8的时候实现原理不太相同":["16.40"],"boolean":["16.41"],"onlyifabsent":["16.41"],"尝试对该段进行加锁":["16.41"],"如果加锁失败":["16.41"],"则调用scanandlockforput方法":["16.41"],"在该方法中就要进行再次尝试或者进行自旋等待":["16.41"],"node":["16.41","35.1"],"trylock":["16.41"],"scanandlockforput":["16.41"],"oldvalue":["16.41","45.4"],"try":["16.41","17.13","43.2"],"获取hashentry数组对象":["16.41"],"tab":["16.41"],"根据key的hashcode值计算索引":["16.41"],"第二次hash定位":["16.41"],"index":["16.41","37.14","72.5","75.1","75.2","75.3"],"first":["16.41"],"entryat":["16.41"],"pred":["16.42"],"instanceof":["16.42","24.3"],"treebin":["16.42"],"红黑树节点":["16.42"],"则往该红黑树更新或添加该节点即可":["16.42"],"p":["16.42"],"puttreeval":["16.42"],"判断是否需要将链表转为红黑树":["16.42"],"treeify":["16.42"],"threshold":["16.42"],"treeifybin":["16.42"],"创建一个countdownlatch对象":["16.43"],"countdownlatch中的计数器的默认值就是2":["16.43"],"并且把这个countdownlatch对象作为构造方法的参数进行传递":["16.43"],"好了":["16.45"],"人都到了":["16.45"],"开始开会":["16.45"],"cyclicbarrierdemo01":["16.45"],"semaphoredemo01":["16.47"],"铝戒":["16.49"],"cpu的执行权被其他线程抢走":["17.8"],"此线程又处于就绪状态":["17.8"],"执行完毕":["17.8"],"的访问和操作能够正确地进行":["17.9"],"而不会出现意外的结果或导致程序的异常行为":["17.9"],"来支持原子操作":["17.10"],"使用线程安全的数据结构":["17.10"],"vector":["17.10"],"常见的原子类包括atomicinteger":["17.11"],"atomiclong":["17.11"],"atomicboolean等":["17.11"],"这些原子类提供了一系列的原子操作方法":["17.11"],"catch":["17.12","17.13"],"e":["17.12","17.13"],"runtimeexception":["17.12"],"sleep":["17.13"],"释放锁":["17.15"],"food":["17.17"],"take":["17.17"],"abortpolicy":["17.18"],"任务工厂拒绝策略":["17.18"],"不断提交任务":["17.18"],"会有三个临界点":["17.18"],"当核心线程满时":["17.18"],"cpu计算时间":["17.19"],"loggerfactory":["18.1"],"getlogger":["18.1"],"method":["18.2"],"查询到的信息封装到了list集合里":["18.3"],"最终把list返回到了service":["18.3"],"设置分页参数":["18.4"],"传统浏览器是单线程的":["19.1"],"现代浏览器已经引入了一些新的机制来处理多线程":["19.1"],"采用web":["19.1"],"bigint":["19.2"],"引用数据类型":["19.2"],"属性是否出现在某个实例对象的原型链上":["19.3"],"tostringtag":["19.4"],"自定义类型":["19.4"],"是一个内置符号属性":["19.4"],"它的值是一个字符串":["19.4"],"用于表示一个对象的默认描述":["19.4"],"也就是调用":["19.4"],"会返回的内容":["19.4"],"let":["19.4","42.17","50.3","56.0","66.1","71.11","75.16"],"abc":["19.4"],"console":["19.4","19.61","20.8","20.10","20.15","20.30","21.2","22.6","65.1","70.0","74.2","75.5","75.6","75.8","75.24","76.1","77.1","77.2","85.9"],"log":["19.4","19.61","20.8","20.10","20.15","20.18","20.30","22.2","22.6","38.7","70.0","74.2","75.6","75.7","75.24","76.1","85.9"],"对于自定义对象":["19.4"],"调用上面的方法":["19.4"],"都只会返回":["19.4"],"此时就可以使用":["19.4"],"来指定一个确定的类型了":["19.4"],"标签之下的文档元素之前":["19.5"],"也就是说不等待后续载入的文档元素":["19.5"],"解析html和下载async脚本同时进行":["19.6"],"解析html和下载defer脚本同时进行":["19.7"],"在dom树构建完成":["19.8"],"私有属性":["19.9"],"执行一个宏任务":["19.11"],"如果遇到微任务就将它放到微任务的事件队列中":["19.11"],"把当前的微任务队列清空":["19.12"],"完成一次事件循环":["19.12"],"接着再取出一个宏任务":["19.12"],"同样把在此期间产生的回调入队":["19.12"],"微任务":["19.13"],"promise":["19.13"],"区分了微任务和宏任务后":["19.14"],"0ms":["19.15"],"也不是立刻执行":["19.15"],"它有一个默认最小时间":["19.15"],"拷贝后原对象改变":["19.21"],"通过使用闭包":["19.22"],"可以创建出一个独立的作用域":["19.22"],"避免变量污染和冲突":["19.22"],"同时也可以实现代码的分离和重用":["19.22"],"闭包的应用场景非常广泛":["19.22"],"例如":["19.22","44.24","56.12"],"封装私有变量":["19.22"],"对dom元素的引用":["19.23"],"垃圾清除":["19.24"],"回收那些不再使用的内存":["19.25"],"本质上是找到内存中可以释放的变量":["19.25"],"然后再进行释放回收内存":["19.25"],"所谓的内存泄漏是程序认为一个变量已经没有用了":["19.25"],"在执行时":["19.26"],"会首先查找当前作用域下的变量":["19.26"],"a为假时执行b":["19.29"],"正常情况下":["19.30"],"运算操作符情况下优先调用valueof":["19.30"],"指向堆内存中一块地址":["19.31"],"undefined是初始化了":["19.35"],"但未定义赋值":["19.35"],"那前三位肯定也是000":["19.36"],"在比较相等性之前先将字符串转换为数值":["19.39"],"如果一个操作数是对象":["19.39"],"等于":["19.41"],"转换为":["19.42"],"所以造成误差":["19.43"],"解决方法":["19.43"],"先变成整数运算":["19.43"],"click":["19.45"],"或冒泡阶段":["19.46"],"false":["19.46","38.8","53.14","59.9"],"是window的一个方法":["19.49"],"也是基于promise":["19.49"],"ready触发":["19.50"],"window":["19.51","19.52","23.1","37.18"],"如果后续又有新的子元素添加":["19.53"],"的作用是将累加器的值传递给下一次迭代":["19.54"],"作为":["19.54"],"方法的初始值":["19.54"],"nan本质是一个number":["19.55"],"typeof":["19.55","42.4","42.8"],"将arr数组元素连接成字符串并返回这个字符串":["19.58"],"map":["19.58","36.9","45.28","50.2"],"操作数组每一项并返回一个新数组":["19.58"],"foreach":["19.58","42.3"],"遍历数组":["19.58"],"没有返回值":["19.58"],"sqrt":["19.59"],"对num进行开方":["19.59"],"pow":["19.59"],"yyyy":["19.61"],"获取端口号":["19.63"],"pathname":["19.63","37.12","43.5"],"获取url的路径":["19.63"],"search":["19.63"],"获取":["19.63"],"浏览器":["19.64"],"由于bom的window包含了document":["19.64"],"window对象的属性和方法是直接可以使用而且被感知的":["19.64"],"因此可以直接使用window对象的document属性":["19.64"],"通过document属性就可以访问":["19.64"],"在严格模式下":["19.68"],"咱们不能在不声明变量的情况下使用变量":["19.68"],"控件":["19.69"],"输入字段可通过多种方式改变":["19.69"],"输出":["19.71","45.17"],"遍历数组的元素":["19.73"],"element":["19.73"],"使用生成器函数创建的对象":["19.74"],"可以通过迭代来获取生成器函数的值序列":["19.74"],"字符串迭代器":["19.74"],"proto":["19.75","20.12"],"prototype":["19.75","20.11"],"result":["19.75","75.13"],"clientx":["19.76"],"鼠标事件中":["19.76"],"鼠标指针相对于浏览器窗口可视区域左上角的水平坐标":["19.76"],"clienty":["19.76"],"每次调用函数都会创建一个新的执行上下文":["19.77"],"执行上下文的生命周期包括三个阶段":["19.77"],"它就会创建一个全局执行上下文然后将它压到执行栈中":["19.78"],"传入的参数":["20.2"],"but":["20.4"],"inherited":["20.4"],"并返回此对象":["20.5"],"an":["20.6"],"property2":["20.7"],"hello":["20.7","20.13","34.21"],"以及不能修改已有属性的值":["20.9"],"此外":["20.9","34.25"],"expected":["20.10","20.16","20.20","20.25","20.30"],"inheritance":["20.13"],"chain":["20.13"],"speak":["20.13"],"says":["20.13"],"honda":["20.15"],"accord":["20.15"],"configurable":["20.16"],"output":["20.16","20.20","20.30"],"返回一个数组":["20.17"],"tostring":["20.19"],"按相同顺序排列的字符串":["20.21"],"都是相同对象":["20.21"],"意味着都是同一个对象的值引用":["20.21"],"都是数字且":["20.21"],"signed":["20.22"],"zero":["20.22"],"getfoo":["20.26"],"is":["20.26"],"property":["20.26"],"which":["20.26"],"isn":["20.26"],"t":["20.26"],"enumerable":["20.26"],"my":["20.26","36.17","44.43"],"当前属性的值只要原来是可写的就可以改变":["20.29"],"判断类型":["20.30"],"const":["20.31","34.21","36.12","37.8","41.8","42.27","44.29","45.20","46.6"],"object1":["20.31"],"当执行了reslove函数":["21.0"],"会回调promise对象的":["21.0"],"如果then的第二个参数不存在":["21.1"],"则catch方法会捕获到":["21.1"],"如果是then的第一个参数函数":["21.1"],"resolve":["21.1"],"中抛出了异常":["21.1"],"即成功回调函数出现异常后":["21.1"],"then的第二个参数reject":["21.1"],"捕获捕获不到":["21.1"],"catch方法可以捕获到":["21.1"],"区别":["21.1"],"成功":["21.2"],"res":["21.2","47.0","63.0"],"如果resolve中传入的是一个对象":["21.3"],"并且这个对象有实现then方法":["21.3"],"那么会执行该then方法":["21.3"],"then方法会传入resolve":["21.3"],"reject函数":["21.3"],"此时的promise状态取决于你调用了resolve":["21.3"],"还是reject函数":["21.3"],"这种模式也称之为":["21.3"],"thenable":["21.3"],"原型对象":["21.4"],"即new出来实例对象的":["21.4"],"输入正确数字":["21.5"],"settimeout":["21.5","36.6","38.3"],"finally":["21.7"],"什么都不打印":["21.8"],"race":["21.8"],"优先获取第一个返回的结果":["21.8"],"无论结果是fulfilled还是rejectd":["21.8"],"set1":["22.1"],"undefined":["22.2","42.7","42.20"],"clear":["22.8","30.4","36.9"],"将这个字典中的所有元素删除":["22.8"],"keys":["22.8"],"将字典中包含的所有键名以迭代器形式返回":["22.8"],"of":["22.9","75.22","75.23"],"maps":["22.9"],"可以获取键值对的数量":["22.11"],"而weakmap没有提供直接的迭代方法":["22.11"],"也没有size属性":["22.11"],"因为由于键的弱引用性质":["22.11"],"如果在浏览器环境下直接访问":["23.1"],"关键字创建对象实例时调用函数":["23.2"],"的值就是新创建的对象实例":["23.2"],"事件处理函数中的":["23.2"],"在事件处理函数中调用":["23.2"],"sayname":["23.3"],"obj2":["23.3"],"sunshin":["23.3"],"lin":["23.3"],"改变sayname的this指向obj2":["23.3"],"且apply和call是一次性传入参数":["23.4"],"它会比较不同类型的操作数":["24.1"],"相等运算符":["24.3"],"token":["25.0"],"后台访问sso":["25.1"],"验证成功后":["25.1"],"app2将登录状态写入":["25.1"],"app2系统的session":["25.1"],"并在":["25.1"],"app2域下写入cookie":["25.1"],"这样":["25.1","32.9"],"values":["26.1"],"返回数组值的":["26.1"],"扁平化":["26.1"],"flat":["26.1"],"将从":["26.5"],"号位直到数组结束的成员":["26.5"],"和":["26.5","44.34"],"表示匹配任意数量的a":["27.0"],"表示匹配至少一个a":["27.0"],"表示匹配0或1个a":["27.0"],"匹配位置":["27.0"],"正则表达式还可以匹配特定的位置":["27.0"],"例如开头":["27.0"],"和结尾":["27.0"],"text":["28.2"],"通过将设置密码框类型的逻辑放入微任务队列中":["28.2"],"可以确保在下一轮事件循环开始之前进行密码框类型的切换":["28.2"],"这种做法可以避免在":["28.2"],"同一轮事件循环中执行密码框类型切换的逻辑":["28.2"],"从而确保正确的初始密码框类型":["28.2"],"如果在同一轮事件循环中意味着在切换密码框类型之后":["28.2"],"模板中对应的元素可能仍然是使用旧的类型进行渲染":["28.2"],"从而无法立即反映出切换后的效果":["28.2"],"注意icon放在后面时要用计算属性做一个判断":["28.2"],"因为会与一键清空":["28.2"],"密码显示隐藏图标冲突":["28.2"],"进行打包":["28.3"],"样式打包和组件打包通过parallel并行执行":["28.4"],"和一个获取数据之前的拦截器":["28.6"],"获取器":["28.7","41.2"],"web":["28.9"],"应用":["28.9"],"移动应用和其他第三方集成":["28.9"],"通过提供统一的后端":["28.9"],"internet":["28.10"],"connections":["28.10"],"协议":["28.10"],"quic是基于udp协议的传输协议":["28.10"],"相较于基于tcp的http":["28.10"],"quic在网络层上提供更好的性能和连接管理能力":["28.10"],"正常的https通信是经过加密和身份验证的":["28.11"],"基于使用公钥加密的ssl":["28.11"],"并且每次都必须从服务器获取最新的文件副本":["28.12"],"使用expires字段":["28.12"],"expires":["28.12"],"date":["28.12"],"指定资源文件过期的日期和时间":["28.12"],"使用占位符或固定尺寸的元素来预留空间":["28.13"],"以避免后续内容加载时的布局偏移":["28.13"],"使用动画和过渡":["28.13"],"如果有元素在网页加载后需要进行动画或过渡效果":["28.13"],"减少对后端接口的请求次数":["28.14"],"提高数据加载速度":["28.14"],"响应式设计和布局优化":["28.14"],"自适应布局":["28.14"],"使用响应式设计":["28.14"],"根据不同设备和屏幕大小":["28.14"],"自动适应布局和样式":["28.14"],"将项目的依赖版本信息存储在单独的pnpm":["28.16"],"lock":["28.16"],"专用的":["29.1"],"import命令则是异步加载":["29.2"],"或者更准确地说":["29.2"],"不必在每个模块文件顶部指定":["29.3"],"不能":["29.4"],"mjs文件总是以":["29.5"],"es6":["29.5"],"模块加载":["29.5"],"nexttick的优先级比promise":["29.7"],"then高":["29.7"],"mkdir":["29.9"],"以及多进程和集群的方式":["29.10"],"官方介绍":["30.2"],"localstorage和sessionstorage是单纯的前端存储":["30.3"],"移除所有":["30.4"],"localstorage的相关操作":["30.4"],"localstorage":["30.4"],"对于版本较低的浏览器不支持":["30.5"],"服务器生成一个token便将此token返回给客户端":["30.7"],"以后客户端只需带上这个token前来请求数据即可":["30.7"],"客户端存储token":["30.8"],"客户端每次向服务端发送请求的时候都需要带上服务端发给的token":["30.8"],"会自动发送":["30.9"],"缺点不能跨域":["30.9"],"域":["30.10"],"domain":["30.10"],"cookie所属的域名":["30.10"],"则默认为当前域名":["30.10"],"路径":["30.10"],"在项目部署再打包":["31.0"],"工具函数":["31.3"],"打包成多个文件":["32.3"],"有可能有多个name":["32.4"],"path":["32.4"],"会将转换应用在已处理过的资源上":["32.5"],"一组链式的":["32.5"],"将按照相反的顺序执行":["32.5"],"链中的第一个":["32.5"],"将其结果":["32.5"],"也就是应用过转换后的资源":["32.5"],"options":["32.6"],"presets":["32.6"],"progressplugin":["32.7"],"是一个":["32.8"],"用于将生产环境中的压缩代码映射回原始的源代码":["32.9"],"当你在浏览器的开发者工具中设置断点":["32.9"],"扩展运算符":["33.0"],"nexttick":["33.0"],"xss攻击":["33.0"],"csrf攻击":["33.0"],"伪数组数组":["33.0"],"虚拟dom":["33.0"],"dom":["34.1","37.8","37.16","42.26"],"state的浅比较结果来实现":["34.2"],"react":["34.2","34.5","36.1","37.8","37.16","38.4"],"memo":["34.2"],"缓存子组件":["34.2"],"配合usecallback":["34.2"],"避免使用内联函数":["34.2"],"react将组件的数据绑定和更新放在":["34.3"],"setstate":["34.3"],"incrementcount":["34.4"],"这个钩子相当于一个阀门":["34.5"],"返回一个布尔值":["34.5"],"决定是否更新组件":["34.5"],"由于":["34.5"],"父组件更新":["34.5"],"必然会导致子组件更新":["34.5"],"因此我们可以":["34.5"],"在子组件中通过手动对比":["34.5"],"getsnapshotbeforeupdate":["34.6"],"用于在组件更新前获取":["34.6"],"快照":["34.6"],"snapshot":["34.6"],"它在":["34.6"],"方法执行后":["34.6"],"这个生命周期主要为我们提供了一个可以在组件实例化或":["34.7"],"props":["34.7"],"组件更新成功钩子":["34.8"],"这种组件":["34.9"],"通常是一个纯函数":["34.9"],"接收一些输入":["34.9"],"即props":["34.9"],"并返回一个":["34.9"],"getter":["34.10","40.1"],"做了劫持":["34.10","40.1"],"也就是说":["34.10","38.5","40.1"],"vue能准确知道视图模版中哪一块用到了这个数据":["34.10","40.1"],"从根节点开始":["34.11"],"依次遍历该节点的子节点":["34.11"],"兄弟节点":["34.11"],"如果两者都遍历了":["34.11"],"则回到它的父节点":["34.11"],"当一个节点的所有子节点遍历完成":["34.11"],"才认为该节点遍历完成":["34.11"],"根据这个规则":["34.11"],"fiber这种数据结构使得节点可以回溯到其父节点":["34.12"],"将不再向":["34.13"],"nativeevent":["34.14"],"找到事件触发节点对应的组件":["34.14"],"开始事件的合成":["34.14"],"根据当前事件类型生成指定的合成对象":["34.14"],"封装原生事件和冒泡机制":["34.14"],"能够保证冒泡一致性":["34.15"],"避免垃圾回收":["34.15"],"事件对象可能会被频繁创建和回收":["34.15"],"因此":["34.15"],"引入事件池":["34.15"],"的映射":["34.16"],"registrationnamedependencies":["34.16"],"会释放事件源到事件池中":["34.17"],"清空属性":["34.17"],"这时":["34.17"],"所以原生事件阻止冒泡会阻止合成事件的触发":["34.18"],"原生事件":["34.19"],"然后处理":["34.19"],"那么可能多应用下会出现问题":["34.20"],"取消事件池":["34.20"],"div":["34.21","36.17","46.4"],"world":["34.21"],"使用高阶组件包装原始组件":["34.21"],"将原始组件传递mycomponent给withlogger函数":["34.21"],"获得了增强后的组件enhancedcomponent":["34.21"],"属性并不会自动绑定到":["34.22"],"类的实例上":["34.22"],"会重新渲染":["34.23"],"shouldcomponentupdate方法默认返回true":["34.23"],"无法获取dom":["34.24"],"不能在函数组件上使用":["34.24"],"值来判断元素是新近创建的还是被移动而来的元素":["34.25"],"从而减少不必要的元素重渲染":["34.25"],"增加了渲染的开销":["34.27"],"如果在hoc中对props做了某些变换":["34.27"],"会导致组件的props变化":["34.27"],"对于类选择器有效":["34.28"],"元素选择器无效":["34.28"],"新组建再进入":["34.29"],"switchtransition组件里面要有csstransition":["34.29"],"key取代in":["34.29"],"transitiongroup":["34.29"],"将多个动画组件包裹在其中":["34.29"],"一般用于列表中元素的动画":["34.29"],"views":["34.30"],"包含功能模块中所有的react组件":["34.30"],"使用了":["34.31"],"remove":["35.1"],"原节点不在新的集合中":["35.1"],"或者在新的集合中不能直接复用或更新":["35.1"],"对原节点执行删除操作":["35.1"],"规则说明":["35.1"],"若当前访问的节点在旧集合中的位置比lastindex大":["35.1"],"的策略":["35.2"],"同时从新旧虚拟dom树的头部和尾部开始比较子节点":["35.2"],"以尽可能地复用已有的dom节点":["35.2"],"递归处理子节点":["35.2"],"当旧列表的最后一个节点oldendnode与新列表的头一个节点newstartnode对比时key相同":["35.3"],"那么旧列表的尾指针oldendindex向前移动一位":["35.3"],"新列表的头指针newstartindex向后移动一位":["35.3"],"表示只有新的一组的子节点还有未处理的节点":["35.4"],"我们需要循环":["35.4"],"中的节点进行插入":["35.4"],"只有老的一组的子节点有剩余":["35.4"],"如果是全新的节点的话":["35.5"],"其在source数组中对应的值就是初始的":["35.5"],"通过这一步我们可以区分出来哪个为全新的节点":["35.5"],"哪个是可复用的":["35.5"],"最终构造成一个虚拟dom对象":["35.6"],"reactdom":["35.6"],"中使用":["36.1"],"内部可以使用链表来实现":["36.2"],"setcount":["36.3"],"prevstate":["36.3"],"我们可以用该函数来":["36.4","38.1"],"修改为":["36.5","38.2"],"而当":["36.5","38.2"],"在调用事件处理函数之前就会先调用这个":["36.5","38.2"],"比如原生js绑定的事件":["36.6","38.3"],"setinterval":["36.6","38.3"],"ajax":["36.6","38.3"],"用于指定在依赖项发生变化时才触发副作用操作":["36.7"],"当组件被渲染后":["36.7"],"中的回调函数将会被执行":["36.7"],"如果提供了依赖项数组":["36.7"],"则":["36.7"],"会比较前后两次渲染的依赖项是否有变化":["36.7"],"只有当依赖项发生变化时":["36.7"],"才会重新执行副作用操作":["36.7"],"如果依赖项数组为空":["36.7"],"则副作用操作只会在组件首次渲染时执行一次":["36.7"],"那":["36.8"],"执行是在浏览器绘制视图之后":["36.8"],"接下来又改":["36.8"],"filter":["36.9"],"item":["36.9","50.2","75.1","75.2","75.3","75.12"],"update":["36.9","45.4","45.13"],"default":["36.9","44.32"],"缓存":["36.10"],"handleclick":["36.10"],"只有在函数被":["36.11"],"频繁传递给子组件":["36.11"],"getnumusememo":["36.12"],"usememo缓存的计算结果":["36.13"],"如果传给子组件的":["36.14"],"是一个新的函数引用":["36.14"],"即使其功能与之前的函数完全相同":["36.14"],"因为":["36.15","38.0","44.18"],"只对":["36.15"],"当父组件重新渲染时":["36.15"],"会重新在内存中开辟一个地址赋值给":["36.15"],"此时地址发生改变":["36.15"],"子组件会重新渲染":["36.15"],"缓存值":["36.16"],"可以用来":["36.16"],"缓存某个值":["36.16"],"在组件的多次渲染之间保持数据的稳定":["36.16"],"somemethod":["36.17"],"component":["36.17"],"function":["36.17","37.16","42.7","44.29","45.20"],"mycomponentref":["36.17"],"handlebuttonclick":["36.17"],"在组件渲染过程中能够检测到变化":["36.19"],"并且在数据源发生变化的时候":["36.19"],"允许我们在渲染过程中控制异步更新的优先级":["36.20"],"而这个新的状态就称之为":["36.21"],"navlink":["37.2"],"switch":["37.2"],"哈希":["37.3"],"部分":["37.3"],"来实现路由导航":["37.3"],"通过监听浏览器的":["37.3"],"hashchange":["37.3"],"你可以检测到哈希部分的变化":["37.3"],"一个是通过children属性设置":["37.4"],"它的值也有两种方式":["37.4"],"一种直接传递组件":["37.4"],"这样当路径匹配时组件会自动挂载":["37.4"],"一种是传递一个回调函数":["37.4"],"这样它和render的特点是一样的":["37.4"],"直接设置组件":["37.4"],"router":["37.8","37.16"],"contact":["37.8","37.10"],"history":["37.8"],"params":["37.9"],"fragment":["37.9","37.10"],"john":["37.9","65.3","65.5"],"doe":["37.9"],"url等信息":["37.11"],"to传入对象":["37.12"],"uselocation":["37.12"],"直接传jsx":["37.14"],"则会自动在studentlist组件中对student组件进行挂载":["37.15"],"在studentlist组件中就可以使用outlet来引用这些被挂载的组件":["37.15"],"由于调用了react":["37.17"],"组件的type不是bar这个类":["37.17"],"而是一个匿名函数":["37.17"],"app组件每次render时都生成一个新的匿名函数":["37.17"],"导致生成的组件的type总是不相同":["37.17"],"location":["37.18","43.5"],"活跃时":["37.19"],"匹配时":["37.19"],"传递一个函数可以让你在函数内访问到当前的":["38.0"],"的值":["38.0"],"的调用是分批的":["38.0"],"所以你可以链式地进行更新":["38.0"],"并确保它们是一个建立在另一个之上的":["38.0"],"这样才不会发生冲突":["38.0"],"重要":["38.0"],"在更新的时候读取":["38.0"],"取而代之的是":["38.4"],"会将该":["38.4"],"因此我们可以将任何仅使用":["38.5"],"组件视为":["38.5"],"purecomponent":["38.5"],"如果项目汇中使用了":["38.6"],"typescript":["38.6"],"那么就可以不用":["38.6"],"父组件的":["38.7"],"发生变化":["38.7"],"这里可以执行你希望在":["38.7"],"变化时进行的其他操作":["38.7"],"表示首次渲染已经完成":["38.8"],"推崇函数式编程":["39.1"],"setstate没有修改原来那块内存中的变量":["39.2"],"而是去新开辟一块内存":["39.2"],"jsx":["39.3"],"最后一个放到最前面":["39.4"],"直接修改":["39.5"],"并且在这个数据修改时":["40.1"],"把他们挂载到文档":["40.2"],"可选":["41.0"],"表示本次动作携带的数据":["41.0"],"reducer":["41.0"],"中派生出一些衍生状态":["41.1","52.5"],"类似于组件中的计算属性":["41.1","52.5"],"模块":["41.1","52.5"],"getters":["41.2"],"createstore":["41.3"],"state":["41.4"],"add":["41.4","45.21"],"例如派发":["41.4"],"button":["41.5"],"onclick":["41.5"],"猪八戒":["41.5"],"改name":["41.5"],"改age":["41.5"],"复合函数":["41.6"],"也就是洋葱模型":["41.6"],"compose":["41.6","41.7","51.7"],"c":["41.6"],"的返回值是":["41.6"],"middleware":["41.8"],"interface":["42.1"],"arrobj":["42.1"],"any":["42.3"],"items":["42.3"],"ts":["42.7"],"fun":["42.7"],"这里":["42.8"],"被收窄为":["42.8"],"这让":["42.9"],"getdogname":["42.10"],"dogname":["42.10"],"直接使用":["42.10"],"也不能赋给":["42.11"],"综上结论":["42.11"],"大":["42.11"],"是比小":["42.11"],"函数返回的类型都可以根据上下文推断出来":["42.12"],"比如我们能根据":["42.12"],"值域中排除":["42.14"],"通过":["42.15"],"specifiednum":["42.16"],"类型的父类型":["42.17"],"number":["42.17"],"除了可用于对类的一部分行为进行抽象以外":["42.18"],"也常用于对":["42.18"],"这里真实的类型应该为":["42.20"],"上面代码":["42.21"],"在参数里写对象就相当于是直接给labeledobj赋值":["42.21"],"这个对象有严格的类型定义":["42.21"],"所以不能多参或少参":["42.21"],"而当你在外面将该对象用另一个变量myobj接收":["42.21"],"myobj不会经过额外属性检查":["42.21"],"但会根据类型推论为let":["42.21"],"索引签名":["42.22"],"兔神":["42.23"],"但是可以作用于原始值":["42.24"],"基本类型":["42.24"],"联合类型":["42.24"],"元组以及其它任何你需要手写的类型":["42.24"],"tuple":["42.26","69.3"],"data":["42.26","44.16","50.3","72.3"],"除了":["42.29"],"之外":["42.29"],"以下是常见泛型变量代表的意思":["42.29"],"k":["42.29"],"arg":["42.30"],"这三个特性组合保证了代码的动态性和准确性":["42.32"],"也让代码提示变得更加丰富了":["42.32"],"映射类型":["42.32"],"我们可以通过":["42.32"],"来指定添加还是删除":["42.32"],"optionaltestinterface":["42.32"],"newtestinterface":["42.32"],"testinterface":["42.32"],"readonly":["42.32"],"nginx":["43.2"],"config的对应location里配置一行代码":["43.2"],"files":["43.2"],"然后使用routerview组件来对vue":["43.3"],"createwebhashhistory":["43.4"],"创建的":["43.4"],"在你的服务器上添加一个简单的回退路由":["43.5"],"如果":["43.5"],"beforerouteenter":["43.7"],"进入该组件之前调用":["43.7"],"无法获取到vue实例":["43.7"],"因为没有this":["43.7"],"所以支持给":["43.7"],"传递回调":["43.7"],"调用":["43.8"],"守卫中传给":["43.8"],"的回调函数":["43.8"],"创建好的组件实例会作为回调函数的参数传入":["43.8"],"组件现在路由里注册但不进行组件的加载与执行":["43.9"],"被请求的模块和它引用的所有子模块":["43.10"],"会分离到一个单独的":["43.10"],"import":["43.11"],"加载中":["43.13"],"之类的指示":["43.13"],"可以通过在编程式导航中传递query一个包含参数的路由对象来传递参数":["43.14"],"是通过路由的路径进行传递":["43.15"],"的查询字符串进行传递":["43.15"],"状态管理":["44.1"],"返回唯一的html页面和它的公共静态资源":["44.2"],"后续的页面跳转都不会从服务端拿html文件":["44.2"],"onupdated":["44.3","44.5","52.0"],"数据更新之后被调用":["44.3","52.0"],"beforedestroy":["44.3","44.5"],"onbeforeunmount":["44.3","44.5"],"页面上数据和内存中的一致":["44.5"],"移除":["44.5"],"父updated":["44.6"],"更新":["44.6"],"销毁过程":["44.6"],"在vue3中v":["44.9"],"if的优先级会更高":["44.9"],"但是当我们遍历一个数组的时候":["44.9"],"侦听器可以检测某个响应式数据的变化并执行副作用":["44.10"],"常见用法是传递一个函数":["44.10"],"执行副作用":["44.10"],"watch没有返回值":["44.10"],"但可以执行异步操作等复杂逻辑":["44.10"],"一般用来请求接口":["44.10"],"依赖关系是同步跟踪的":["44.12"],"例如发送网络请求":["44.13"],"操作定时器等":["44.13"],"所有依赖这个数据的相关数据或函数都会自动发生变化或调用":["44.14"],"侦听器watch常用场景是状态变化之后做一些异步操作":["44.14"],"的":["44.15","45.26"],"的属性":["44.16"],"在后":["44.17"],"这样就能实现":["44.17"],"计算属性重要工作是重新执行计算方法":["44.18"],"这里需要多补充一句":["44.18"],"vue2中是通过object":["44.21"],"defineproperty对数据劫持实现的":["44.21"],"vue3中则是使用proxy对数据代理实现的":["44.21"],"生命周期区别":["44.21"],"挂载":["44.22"],"在创建":["44.22"],"实例后":["44.22"],"可以选择手动挂载到一个特定的":["44.22"],"元素上":["44.22"],"或者使用":["44.22"],"提供的":["44.22"],"中有一个":["44.23"],"watcher":["44.23","45.12"],"3对一些数组方法进行了修改":["44.24"],"使其更符合规范并提供更好的类型推导":["44.24"],"会调用我们插件的install属性的函数":["44.25"],"personname":["44.26"],"xiaoyue":["44.26"],"age":["44.26","65.2"],"parent":["44.27","71.15"],"父组件访问子组件":["44.27"],"children":["44.27"],"emits":["44.29"],"defineemits":["44.29"],"vue2使用":["44.31"],"refs":["44.31","50.3"],"slotprops":["44.32"],"每个模块都拥有自己的state":["44.33"],"actions等":["44.33"],"在大型应用中经常用到":["44.33"],"孙行者":["44.34"],"多条数据修改":["44.34"],"patch":["44.34","52.6"],"方法可以接受两个类型的参数":["44.34"],"appstore":["44.35"],"pinia其实就是vuex5":["44.35"],"它和vuex的主要区别有以下几点":["44.35"],"pinia使用更简单":["44.35"],"alive还接收max属性表示最大缓存实例数":["44.37"],"如果超出这个数则最久没有被访问的缓存实例将被销毁":["44.37"],"都不会触发":["44.38"],"因为组件没被销毁":["44.39"],"如果mixin中的属性或者方法与父组件冲突则会使用父组件中的":["44.40"],"优点":["44.40"],"则不会破坏原对象":["44.41"],"只是在原对象上覆盖了一层":["44.41"],"video":["44.43"],"src":["44.43"],"模板用于展示一个占位符":["44.44"],"表示正在等待异步操作完成":["44.44"],"这是什么意思呢":["44.46"],"其实vue中修改data不会立刻触发dom更新":["44.46"],"而是把需要更新的watcher加入到queuewatcher队列中":["44.46"],"然后与上一次虚拟dom节点树进行比较":["44.48"],"diff":["44.48"],"不一样就认为节点不一样":["44.49"],"不再对比子节点":["44.49"],"这样时间复杂度一下子就降到了":["44.49"],"比较每对相同位置的子节点的差异":["44.50"],"在比较子节点的过程中":["44.50"],"js会使用一些优化策略":["44.50"],"例如为每个子节点添加唯一的key属性":["44.50"],"以便更精确地定位和复用已有的dom节点":["44.50"],"filltermeals":["44.51"],"子组件":["44.51"],"父组件":["44.52"],"father":["44.52"],"在这种情况下":["44.53"],"可以使用":["44.53"],"来确保在":["44.53"],"index的效率低":["44.54"],"先在fallback插槽显示占位符例如加载中":["44.55"],"reactive可以直接读取更新":["44.56"],"表单的v":["44.59"],"model":["44.59","50.2","50.4"],"用户对view层的更改会直接同步到model层":["44.59"],"实际上v":["44.59"],"总得来说":["44.60"],"数据绑定是view与model之间的映射关系":["44.60"],"单双向数据绑定与数据流是两个不同维度的概念":["44.60"],"minchunks为3表示会把使用3次及以上的包抽离出来":["44.62"],"放进公共依赖文件":["44.62"],"svg":["44.63"],"等等":["44.63"],"lang":["44.64"],"观察者模式":["45.2"],"一个被观察对象对应多个观察者":["45.2"],"被观察对象与观察者之间可能是":["45.3"],"多对多":["45.3"],"的关系":["45.3"],"两者都可以绑定多个另一角色":["45.3"],"依赖更新时会调用":["45.4"],"执行回调函数":["45.4"],"依赖收集管理者的构造函数":["45.4"],"保存所有":["45.4"],"观察者依赖数组":["45.4"],"subs":["45.4"],"插入一个观察者到依赖数组中":["45.4"],"addsub":["45.4","45.14"],"被观察者":["45.5"],"是在":["45.5"],"执行响应式时候调用":["45.5"],"newval":["45.7"],"下文中该方法统称为setter":["45.7"],"reactivesetter":["45.8","45.9"],"newvalue":["45.8","45.9"],"这里第一次调用来监测该对象":["45.9"],"defineproperty":["45.9"],"reactivegetter":["45.9"],"setprototypeof强制让vue的数据指向了新定义的arraymothods":["45.10"],"在getter中就能得到当前正在读取数据的watcher":["45.11"],"并把这个watcher收到dep中":["45.11"],"改变数据":["45.11"],"注意":["45.12"],"parsepath":["45.13"],"当收到数据变化的消息时执行该方法":["45.13"],"从而调用cb":["45.13"],"depend":["45.14"],"notify":["45.14"],"被改变了":["45.15"],"通知依赖去更新":["45.15"],"proxy":["45.16","45.26"],"对象来实现整个响应式系统基础":["45.16"],"是":["45.16"],"delete":["45.17"],"建立一个对象":["45.18"],"属性":["45.18"],"副作用函数的依赖关系":["45.18"],"执行完成成后我们得到一个如下的数据结构":["45.21"],"集合":["45.21"],"effects":["45.22"],"收集数据依赖":["45.24"],"因为发布者和观察者之间多了一个":["45.24"],"dependence":["45.24"],"依赖收集者":["45.24"],"返回一个对象的响应式代理":["45.25"],"unwrapnestedrefs":["45.25"],"都是通过":["45.26"],"createreactiveobject":["45.26"],"方法来创建一个":["45.26"],"对象返回":["45.26"],"只是":["45.26"],"dep":["45.28"],"trigger":["45.32"],"设置target的key属性为value":["45.33"],"等常用的指令":["46.0"],"除此之外vue":["46.0"],"mounted":["46.2"],"el":["46.2"],"mount":["46.2","78.2","82.2"],"instance":["46.3"],"使用该指令的组件实例":["46.3"],"dir":["46.3"],"指令的定义对象":["46.3"],"代表绑定元素的底层":["46.3"],"prevnode":["46.3"],"之前的渲染中代表指令所绑定元素的":["46.3"],"钩子中可用":["46.3"],"vue":["46.3"],"select":["47.0","63.0"],"execcommand":["47.0","63.0"],"null":["50.1","60.0","69.7","72.4"],"第一行不渲染输入框":["50.1"],"input":["50.1"],"createmodal":["50.4"],"width":["50.4"],"on":["50.4"],"cancel":["50.4"],"cancelhandler":["50.4"],"可访问性":["51.0"],"高性能和优化":["51.0"],"组件库应该追求高性能和优化":["51.0"],"文档维护":["51.1"],"revert":["51.2"],"8e":["51.3"],"9f":["51.3"],"e7":["51.3"],"md":["51.3"],"webpack是commonjs":["51.4"],"内置了一个轻量级的开发服务器":["51.5"],"利用浏览器的原生模块解析能力":["51.5"],"实现了快速的热模块替换":["51.5"],"字段":["51.6"],"我们可以调用":["51.6"],"redux的compose函数":["51.7"],"中间件串联":["51.7"],"funcs":["51.7"],"reduce":["51.7"],"g":["51.7"],"通俗易懂写法":["51.7"],"函数接收多个函数作为参数":["51.7"],"并返回一个新的函数":["51.7"],"compose1":["51.7"],"数据更新之前被调用":["52.0"],"updated":["52.0"],"视图中的html并没有渲染出来":["52.1"],"此时如果直接操作dom节点一定找不到相关元素":["52.1"],"这是因为在vue中每一个组件都是一个单独的实例":["52.2"],"全局拦截":["52.3"],"对所有的axios获取数据时都拦截":["52.3"],"特定拦截":["52.3"],"ref":["52.4"],"expose":["52.4"],"在模板中使用computed属性时":["52.7"],"你可以像使用普通属性一样获取它们的值":["52.7"],"typeof判断基本null返回object":["53.1"],"引用类型会把array判断成object":["53.1"],"而且栈":["53.2"],"内存是连续分配的":["53.2"],"堆是一种":["53.2"],"非线性数据结构":["53.2"],"宏任务执行完毕后执行为任务":["53.4"],"不可靠":["53.5"],"capture":["53.7"],"all":["53.8"],"在浏览器执行":["53.9"],"去重":["53.14","59.9"],"permuteunique":["53.14","59.9"],"sort":["53.14","59.9"],"排序":["53.14","59.9"],"图形是矢量形式":["53.16"],"todataurl":["53.17"],"并且不返回资源内容":["53.19"],"浏览器会直接使用本地缓存":["53.19"],"etag和if":["53.19"],"none":["53.19"],"多个进程可以在有限的物理内存上运行":["53.20"],"存储的信息在同一域中是共享的":["53.22"],"无法像cookie一样设置过期时间":["53.22"],"每个标签页运行在独立的渲染进程中":["53.23"],"提高安全性":["53.23"],"提高性能":["53.23"],"多个标签页可以并行处理":["53.23"],"前面耽误了时间":["53.25"],"的组件实例":["53.26"],"cache对象中没有该key值的情况":["53.26"],"concat":["53.30","76.4"],"服务端响应":["53.34"],"etag":["53.35"],"服务端为每个资源都有一个唯一的标识":["53.35"],"客户端和服务器之间建立一次连接后激励关闭链接":["53.36"],"测试用例":["53.37"],"服务器配置":["53.37"],"分治都用了":["53.38"],"cdn":["55.0"],"azure":["55.0"],"tabnine":["55.1"],"ai":["55.1"],"i":["56.0"],"而computed定义的计算属性会返回计算的结果":["56.2"],"可以像访问普通属性一样使用":["56.2"],"综上所述":["56.2"],"在监听到某个数据变化后":["56.3"],"可以发送异步请求到服务器获取数据":["56.3"],"并在数据返回后更新其他相关数据或界面":["56.3"],"路由监听":["56.3"],"在vue路由中":["56.3"],"align":["56.6"],"sticky":["56.10"],"元素在滚动时表现为":["56.10"],"的混合":["56.10"],"元素在滚动到指定阈值前表现为":["56.10"],"任何修改都必须通过向父组件发送事件来触发":["56.11"],"简化了组件之间的数据传递和维护":["56.11"],"处理外部事件和回调":["56.12"],"异步操作还用于处理外部事件和回调函数":["56.12"],"和rejected":["56.13"],"已失败":["56.13"],"并行和串行操作":["56.13"],"和微任务队列如promise的回调函数":["56.14"],"异步任务完成后他们的回调函数或者结果会被放入相应的任务队列中":["56.14"],"先处理微任务队列中的任务在处理宏任务":["56.15"],"apply":["59.1","59.8"],"timmer":["59.2"],"hobbies":["59.4"],"reading":["59.4"],"swimming":["59.4"],"address":["59.4"],"city":["59.4"],"york":["59.4"],"country":["59.4"],"usa":["59.4"],"copiedobj":["59.4"],"将导致无限循环的序列化":["59.5"],"可能会导致错误":["59.5"],"对象的键名将被强制转换为字符串":["59.5"],"可能会导致类型信息丢失":["59.5"],"分组匹配字符串":["59.6"],"endindex":["59.7"],"indexof":["59.7"],"longestsubsequence":["59.7"],"根据调用方式":["59.8"],"传入不同绑定值":["59.8"],"math":["59.10","69.4","75.29"],"第一个完成的":["61.1"],"执行":["61.1"],"reflect":["62.0"],"john2":["65.4"],"john4":["65.6"],"temp":["66.1"],"push":["66.5","69.2","76.5","76.6"],"迭代法":["67.1"],"让当前指针curr":["67.1"],"next指向前一个指针prev":["67.1"],"然后不断让prev":["67.1"],"curr":["67.1"],"next向后移动":["67.1"],"直到curr为null":["67.1"],"cur":["67.6","75.26"],"charcodeat":["69.1"],"是否需要扩容":["69.2"],"newsize":["69.4"],"floor":["69.4"],"j":["69.7"],"isempty":["70.1"],"非空右子树的所有键值大于其根结点的键值":["71.1"],"查找效率非常高":["71.2"],"min":["71.3"],"返回树中最小的值":["71.3"],"left":["71.7"],"处理经过节点的右子节点":["71.7"],"处理当前节点":["71.8"],"处理右子树中的节点":["71.8"],"right":["71.9"],"whilesearch":["71.11"],"在上面的代码中":["71.12"],"我们先保存了一些临时变量":["71.12"],"用于一会儿找到的要删除的节点对应的node":["71.12"],"用于保存current节点的父节点":["71.12"],"因为如果current有子节点":["71.12"],"那么在删除current节点的时候":["71.12"],"左为空":["71.14"],"root":["71.15"],"isleftchild":["71.15"],"有两个节点":["71.16"],"递归删除函数":["71.16"],"successor":["71.16"],"getsuccessor":["71.16"],"head":["72.1"],"让current指到下一个data":["72.2"],"直到current":["72.2"],"next为空":["72.2"],"最后把新节点赋值给current":["72.2"],"新节点就加入到了最后":["72.2"],"后一个":["72.4"],"prev":["72.4"],"前一个":["72.4"],"从头开始找位置":["72.4"],"break":["72.9"],"previous":["72.11","72.12"],"removedata":["72.11","72.12"],"size":["74.1","79.1"],"endname":["74.2"],"front":["74.2"],"result27":["75.10"],"result26":["75.12"],"f":["75.15"],"值的槽":["75.16"],"result17":["75.16"],"result19":["75.18"],"result34":["75.21"],"pre":["75.26"],"result29":["75.27"],"result31":["75.28"],"abs":["75.29"],"result33":["75.30"],"result36":["75.32"],"全局挂载之后在组件内就可以直接使用了":["78.2","79.2","82.2"],"或者直接写disabled":["78.4"],"primary":["79.0"],"禁用":["79.1"],"disabled":["79.1"],"选择大小":["79.1"],"只需要引用下面这行代码":["79.2"],"你就可以看到按钮啦":["79.2"],"success":["79.3","79.5","79.6","79.7"],"plain":["79.3"],"dianhua":["79.8"],"电话":["79.8"],"append":["80.7"],"shanchu":["82.1"],"shaixuan":["82.1"],"shandian":["82.1"],"pinglun":["82.1"],"shengyin":["82.1"],"你就可以看到图标啦":["82.3"],"dot":["82.4"],"td默认继承tr的高度":["85.2"],"且平分table的宽度":["85.2"],"若table":["85.2"],"不存在":["85.2"],"给td设置的宽高不能用百分比只能用准确的数":["85.2"],"object小写":["85.3"],"但请求者应继续使用原有位置来进行以后的请求":["85.6"],"sort会影响原数组":["85.7"],"区域外的隐藏":["85.8"],"转为字符串都是":["85.11"],"判断数据类型得用":["85.12"],"hight":["85.14"],"1s":["85.14"],"且当标签失焦后触发change事件":["85.15"],"顺序不能乱":["85.18"],"挂载到原型上":["86.2"],"水击三千里":["90.0"],"抟扶摇而上者九万里":["90.0"],"温故而知新":["91.0"]},{"0":["1.8","6.10","16.28","20.21","36.16","69.5","75.21","85.1"],"1":["9.2","9.16","17.17","20.30","26.4","36.10","42.16","42.27","72.6","75.16"],"2":["3.12","19.11","19.54","20.30","21.6","69.2","69.4","72.12","75.16"],"3":["1.20","5.2","9.33","11.8","11.26","16.9","19.72","20.30","20.31","22.3","34.4","36.9","38.5","44.13","45.17","46.2","71.1","71.15","71.16","75.16","85.1"],"4":["0.4","9.26","9.27","16.43","17.10","19.12","19.15","19.66","19.67","20.31","21.10","22.11","23.2","44.10","44.33","44.40","45.25","45.26","51.3","85.2"],"5":["1.30","3.6","5.8","6.15","9.34","16.4","16.24","16.37","21.9","27.0","28.16","42.19","43.6","44.10","44.14","44.21","44.50","51.3","56.0"],"6":["2.10","3.15","5.7","5.8","6.9","9.25","10.2","19.50","21.8","26.1","30.8","51.0","53.34","56.10"],"7":["5.17","21.5","44.1","51.0","85.17"],"8":["19.76","21.5","42.32","76.0","77.0"],"9":["6.7","8.2","28.2","42.32","76.0","77.0"],"10":["5.12","8.2","16.46","24.3","75.17","82.4"],"11":["8.2","11.21","24.3"],"12":["24.3","28.12","75.17"],"14":["75.17"],"15":["9.23"],"16":["9.23"],"17":["9.23","34.20"],"20":["65.3","65.4","65.5"],"22":["11.21"],"30":["37.12"],"50":["1.1"],"60":["73.2"],"75":["69.2"],"98":["37.12"],"100":["16.19"],"200":["11.6"],"415":["9.23"],"416":["9.23"],"417":["9.23"],"500":["9.23"],"501":["9.23"],"2000":["16.5"],"2023":["14.4","28.12"],"9997":["16.25"],"9998":["16.33"],"9999":["16.33"],"100000":["42.23"],"xml":["0.1"],"ajax用来与后台交互":["0.1"],"catch":["0.2","16.42","21.2","61.1"],"err":["0.2","21.2"],"axios":["0.2"],"baseurl":["0.2"],"url":["0.2","5.24"],"stringify":["0.3","36.9"],"ie4k左右":["0.4"],"get获取数据":["0.4"],"post上传数据":["0.4"],"上传的数据比较多":["0.4"],"then":["0.6","14.10"],"res":["0.6"],"websocket":["0.6","32.8"],"websocket是html5中引入的一种双向通信协议":["0.6"],"它支持跨域请求":["0.6"],"可以在不同域名的页面之间进行实时通信":["0.6"],"websocket是一种长连接":["0.6"],"可以持续地发送和接收数据":["0.6"],"而不需要每次请求都建立新的连接":["0.6"],"websocket协议有以下特点":["0.6"],"全双工通信":["0.6"],"websocket允许客户端和服务器之间实现双向通信":["0.6"],"可以在任何时候发送和接收数据":["0.6"],"不需要等待请求或响应":["0.6"],"newtoken":["0.8"],"data":["0.8","44.5"],"setitem":["0.8"],"更新本地存储中的token":["0.8"],"或者使用全局状态管理库更新token":["0.8"],"this":["0.8","20.26","36.1","42.7","50.4","59.2"],"store":["0.8","41.0","41.1","41.8","44.34","52.5"],"commit":["0.8"],"updatetoken":["0.8"],"更新请求的authorization头部":["0.8"],"来决定哪些请求可以访问":["0.9"],"响应拦截器":["0.9"],"这块就是根据":["0.9"],"token":["0.10","9.37"],"取消请求":["0.10"],"请求原因是可选的":["0.10"],"属性":["1.2","6.13","34.24","44.31"],"父元素使用":["1.2"],"弹性盒子布局":["1.2"],"overflow除visible以外的值":["1.3"],"hidden":["1.3"],"设置元素内容可见性":["1.5"],"设置的元素本身不受影响":["1.5"],"隐藏效果与":["1.5"],"利用偏移抛出视图":["1.6"],"空间会占据":["1.6"],"z":["1.7","6.17"],"index":["1.7","6.17","43.2","43.5","69.1","75.10","75.12"],"层叠上下文在合适的情况下可以遮挡住元素":["1.7"],"5em就表示字体大小是父元素的一半为40px":["1.8"],"如果自身定义了font":["1.8"],"的元素是相对于已":["1.9"],"定位的父元素":["1.9"],"对于position":["1.9"],"fixed":["1.9"],"在不同屏幕尺寸下":["1.10"],"浏览器会自动根据基准字体大小进行缩放":["1.10"],"从而实现自适应布局":["1.10"],"默认值为row":["1.11"],"nowrap":["1.11"],"content属性定义了项目在主轴上的对齐方式":["1.11"],"items属性定义项目在交叉轴上如何对齐":["1.11"],"basis":["1.12"],"不管内容多少":["1.13"],"一般都是平分空间":["1.13"],"不是均分的":["1.14"],"除非内容都是一样":["1.14"],"不可扩大":["1.15","1.16"],"5px":["1.17"],"rows":["1.17"],"white":["1.18"],"space":["1.18"],"reflow":["1.19"],"relayout":["1.19"],"所谓重排即指对这些节点以及受这些节点影响的其它节点":["1.19"],"进行css计算":["1.19"],"布局":["1.19"],"亦即如果你设置了top":["1.20"],"50px":["1.20"],"那么在sticky元素到达距离相对定位的元素顶部50px的位置时固定":["1.20"],"不再向上移动":["1.20"],"所以两个item中间的间距会比较大":["1.21"],"边缘空间是两个item之间空间大小的一半":["1.21"],"direction":["1.22","1.32"],"指定是否应该轮流反向播放动画":["1.22"],"fill":["1.22"],"mode":["1.22","20.6"],"规定当动画不播放时":["1.22"],"当动画完成时":["1.22"],"circle":["1.23"],"块级元素的默认显示方式为":["1.24"],"block":["1.24"],"而行内元素的默认显示方式为":["1.24"],"capitalize":["1.25"],"每个单词的首字母大写":["1.25"],"注意":["1.26","71.15"],"属性可重写灵活容器的":["1.26"],"play":["1.27"],"state":["1.27","37.12","38.4","44.35"],"选择已选中的复选框或单选按钮":["1.30"],"disabled":["1.30"],"选择禁用的表单元素":["1.30"],"目标伪类选择器":["1.30"],"target":["1.30","5.24"],"letter":["1.31"],"控制文本大小写":["1.32"],"规定文本的书写方向":["1.32"],"color":["1.32","2.9","46.3"],"文本颜色":["1.32"],"元素可见性":["1.32"],"不要使用":["1.34"],"import":["1.34"],"窗口大小变化等":["1.35"],"浏览器会重新计算媒体查询条件":["1.35"],"通过设置不同的上下左右边框宽度或者颜色即可得到三角形或者梯形":["2.0"],"padding":["2.1"],"的百分比计算是参照父元素的":["2.1"],"width":["2.1"],"清除浮动方法":["2.2"],"万能清除法":["2.2"],"after":["2.2"],"和外边距":["2.3"],"margin":["2.4"],"ie盒模型包含内边距":["2.4"],"而border":["2.5"],"box表示使用ie盒模型":["2.5"],"用户行为":["2.6"],"例如调整窗口大小":["2.6"],"改变字号":["2.6"],"其实对于大部分图标这类图片":["2.7"],"完全可以使用":["2.7"],"svg":["2.7"],"代替":["2.7"],"2d":["2.8"],"3d转换":["2.8"],"transform":["2.8"],"过渡与动画":["2.8"],"red":["2.9"],"当设备屏幕宽度小于等于600px时":["2.9"],"弹性布局":["2.10"],"flex":["2.10","56.6"],"利用flex布局的方式":["2.10"],"左右两栏设置固定宽度":["2.10"],"中间一栏设置为flex":["2.10"],"这种实现方式代码非常简洁":["2.10"],"display":["2.10","56.10"],"向外共享模块成员使用":["3.2"],"export关键字":["3.2"],"只要是合法的成员名称即可":["3.4"],"按需导入可以和默认导入一起使用":["3.5"],"es6新增":["3.5"],"会自动变为window对象的变量":["3.6"],"属性或方法":["3.6"],"但const和let不会":["3.6"],"也就是说声明前不可用":["3.7"],"大部分包含":["3.7"],"的都可以构成块级作用域":["3.7"],"但是函数和对象不构成块级作用域":["3.7"],"user":["3.8"],"obj":["3.8","45.13"],"箭头函数没有arguments":["3.9"],"要接受所有的参数用":["3.9"],"rest":["3.9"],"通过extends关键字实现继承":["3.11"],"default是以整体的方式抛出":["3.12"],"next":["3.14","72.3","72.5","72.7","75.24"],"方法逐步遍历生成器函数中的每个值":["3.14"],"状态机":["3.14"],"由于":["3.14"],"length将返回没有指定默认值的参数个数":["3.15"],"作用域":["3.15"],"箭头函数":["3.15"],"set":["3.15","17.11"],"map":["3.15","56.0"],"promise":["3.15","36.6","38.3"],"的字符串创建了":["4.0"],"symbol类型":["4.0"],"创建了就会在全局中登记":["4.0"],"如果有则不重复创建":["4.0"],"已登记的":["4.0"],"然而symbol":["4.0"],"的创建是":["4.0"],"不会去检索全局":["4.0"],"的":["4.0","5.2","6.13"],"是":["4.0","21.1","44.53"],"直接创建一个新的symbol类型":["4.0"],"这也是用symbol":["4.0"],"创建的两个":["4.0"],"类型不相等的根本原因":["4.0"],"方法返回一个已登记的":["4.0"],"类型值的":["4.0"],"key":["4.0","14.2","42.29","50.2","71.9"],"是表述":["5.1"],"的内部数据结构":["5.1"],"节点":["5.2"],"并将dom":["5.2"],"节点添加到":["5.2"],"树中":["5.2"],"解析器开始工作时":["5.2"],"会默认创建了一个根为":["5.2"],"document":["5.2","34.21","42.26","53.13"],"的空":["5.2"],"同时会将一个":["5.2"],"starttag":["5.2"],"会影响dom树的渲染":["5.3"],"也可以说最终会影响渲染树的生成":["5.3"],"文件中包含的":["5.4"],"css":["5.4","6.13","28.13"],"等相关文件":["5.4"],"来标记代码":["5.5"],"事件触发":["5.6"],"页面加载完毕":["5.7","19.50"],"将dom和cssom合并成一棵渲染render树":["5.8"],"对渲染树进行reflow":["5.8"],"回流":["5.8"],"重排":["5.8"],"计算元素位置":["5.8"],"render":["5.9","35.6","37.17","43.3","45.24"],"树和布局":["5.9"],"一边解析":["5.10"],"以及一边渲染":["5.10"],"个":["5.12"],"上":["5.13"],"操作内存中的":["5.13"],"对象的速度显然要更快":["5.13"],"等更新完成后":["5.13"],"对象的差异应用到真正的":["5.14"],"elemenet":["5.16"],"js":["5.16","19.30","34.28","67.1"],"的方法和属性":["5.17"],"xmlhttprequest":["5.17"],"表示":["5.17","19.4"],"ajax":["5.17"],"当指定类型的事件触发时执行相应的回调函数":["5.18"],"removeeventlistener":["5.18"],"移除事件监听器":["5.18"],"cookie":["5.19","9.2","9.37"],"获取或设置文档的":["5.19"],"移除指定属性名的属性":["5.20"],"包括被隐藏的部分":["5.21"],"如果有":["5.21"],"scrollheight":["5.21"],"获取元素内容的总高度":["5.21"],"scrollleft":["5.21"],"获取或设置元素内容在水平方向上滚动的像素数":["5.21"],"scrolltop":["5.21"],"获取或设置元素内容在垂直方向上滚动的像素数":["5.21"],"textcontent":["5.22"],"appendchild":["5.22"],"open":["5.24","13.3"],"打开一个新窗口或标签页":["5.24"],"localstorage":["5.25"],"提供了对本地存储的访问":["5.25"],"可以存储和读取数据":["5.25"],"sessionstorage":["5.25"],"对象的属性和方法可以用于事件处理":["5.26"],"事件传播和事件信息的获取":["5.26"],"指示事件是否会冒泡的布尔值":["5.27"],"cancelable":["5.27"],"指示事件是否可以取消的布尔值":["5.27"],"defaultprevented":["5.27"],"初始化事件对象":["5.28"],"设置事件的类型":["5.28"],"我们一般称为怪异模式":["6.1"],"这不仅会降低解析效率":["6.1"],"而且会在解析过程中产生一些难以预知的bug":["6.1"],"是早期的斜体元素":["6.2"],"表示内容展示为斜体":["6.2"],"而":["6.2","21.1","34.4"],"是emphasize":["6.2"],"使用行内元素需要注意的是":["6.3"],"行内元素设置宽度width无效":["6.3"],"行内元素设置height无效":["6.3"],"但是可以通过line":["6.3"],"height来设置":["6.3"],"设置margin只有左右有效":["6.3"],"上下无效":["6.3"],"设置padding只有左右有效":["6.3"],"a元素最常见的就是用来做锚点和":["6.5"],"下载文件":["6.5"],"锚点可以在点击时快速定位到一个页面的某个位置":["6.5"],"keywords是关键词标签":["6.6"],"lt":["6.7"],"ie":["6.7"],"strike":["6.8"],"tt":["6.8"],"u":["6.8","16.42"],"big":["6.8"],"center":["6.8"],"重绘":["6.9"],"根据浏览器提供各层的信息合成图层":["6.9"],"obsity":["6.10"],"这三个占位置":["6.10"],"每次修改样式都会触发重排":["6.11"],"重排非常耗费资源":["6.11"],"式是使":["6.13"],"will":["6.13"],"change":["6.13"],"和":["6.14","9.9","19.4","42.14","44.35","44.59"],"opacity":["6.14"],"才不会触发":["6.14"],"使用video":["6.15"],"canvas等元素":["6.15"],"这些元素通常都是单独的合成层":["6.15"],"可以减少对其他元素的影响":["6.15"],"浏览器是无法进行层压缩的":["6.16"],"比如":["6.16"],"video":["6.16"],"譬如巧妙的使用":["6.17"],"table":["6.18"],"以及":["6.18"],"img":["6.18"],"方便其他设备解析":["6.19"],"如屏幕阅读器":["6.19"],"盲人阅读器":["6.19"],"需要遵循同源策略":["6.20"],"从而保证网页的安全性":["6.20"],"高度和宽度的控制":["6.20"],"可以通过设置height和width属性来控制iframe元素的大小":["6.20"],"网页性能的影响":["6.20"],"页面等角度进行合理规划":["7.1"],"使网站更适合搜索引擎的索引原则的行为":["7.1"],"用自然语言描述页面的主要内容":["7.2"],"description就是用自然语言描述页面的主要内容":["7.3"],"这里注意一点就是把每个关键词至少覆盖一遍才能达到最佳效果":["7.3"],"还可以在不同的页面之间相互投权重":["7.4"],"短域名":["7.5"],"越短越好记":["7.5"],"域名历史":["7.5"],"买之前":["7.5"],"在搜索引擎搜索以下":["7.5"],"主要是有js":["8.1"],"dom组成":["8.1"],"所有属性必须有属性值":["8.2"],"所有的标签都必须有相应的结束标签":["8.2"],"所有的标签都必须合理嵌套":["8.2"],"加载越快":["8.3"],"用户体验提高":["8.3"],"服务器监听客户端的请求":["9.1"],"收到请求":["9.1"],"状态码":["9.1"],"无状态协议解决办法":["9.2"],"通过":["9.2","9.11","36.17","53.2"],"ip等协议构成的协议簇":["9.3"],"只是因为在tcp":["9.3"],"ip协议中tcp协议和ip协议最具代表性":["9.3"],"在关闭连接时":["9.4"],"如果对方的确认未及时到达":["9.4"],"tcp会等待一段时间进行重传":["9.4"],"是无状态的":["9.5"],"协议是由":["9.5"],"协议构建的可进行加密传输":["9.5"],"加密后的密钥发送给服务器":["9.6"],"服务器解密":["9.6"],"服务器使用自己的":["9.6"],"私钥对客户端发送的密钥进行解密":["9.6"],"得到对称密钥":["9.6"],"安全通信":["9.6"],"header":["9.9"],"compression":["9.9"],"服务器推送":["9.9"],"server":["9.9"],"压缩":["9.11"],"算法对头部信息进行压缩":["9.11"],"可以":["9.12"],"忽略服务器推送":["9.12"],"用户访问的资源恰好在缓存系统里":["9.13","53.21"],"可以直接返回给用户":["9.13","53.21"],"命中次数与所有访问次数之比":["9.13","53.21"],"回源率":["9.13","53.21"],"缓存里没有":["9.13","53.21"],"原信息或称元数据":["9.16"],"trace":["9.16"],"显示服务器收到的请求":["9.16"],"主要用于测试或诊断":["9.16"],"connect":["9.16"],"http":["9.16"],"浏览器再发送data":["9.17"],"ok":["9.17"],"预检请求的目的是检查服务器是否支持实际的请求":["9.17"],"以及是否允许跨域请求":["9.17"],"比":["9.18"],"get":["9.18","18.2"],"deflate":["9.19"],"告知对方我方接受的":["9.19"],"给当前资源的标识":["9.19"],"和last":["9.19"],"content":["9.20","10.1"],"length":["9.20","19.71","42.19","72.1"],"客户端错误":["9.22"],"请求有语法错误或者请求无法实现":["9.22"],"5xx":["9.22","9.23"],"服务器无法处理":["9.23"],"不支持的媒体类型":["9.23"],"请求的格式不受请求页面的支持":["9.23"],"请求范围不符合要求":["9.23"],"如果页面无法提供请求的范围":["9.23"],"则服务器会返回此状态代码":["9.23"],"未满足期望值":["9.23"],"服务器未满足":["9.23"],"期望":["9.23"],"请求标头字段的要求":["9.23"],"服务器错误":["9.23"],"服务器内部错误":["9.23"],"服务器遇到错误":["9.23"],"无法完成请求":["9.23"],"尚未实施":["9.23"],"返回响应":["9.25"],"客户端接受响应":["9.25"],"比如安全检查":["9.26"],"访问限制":["9.26"],"路由器缓存":["9.27"],"isp":["9.27"],"会话层":["9.28"],"session":["9.28","9.37"],"不过此时服务器并不能确认客户端的接收能力是否正常":["9.33"],"第三次握手就是客户端收到报文后再给服务器发送一个报文":["9.33"],"三次握手就成功了":["9.33"],"一样发送一个":["9.34"],"报文作为应答":["9.34"],"此时客户端处于time":["9.34"],"同时还有子网掩码用于定义":["9.35"],"对数据可靠性要求较低的应用":["9.36"],"如音频和视频流媒体":["9.36"],"实时游戏等":["9.36"],"总结来说":["9.36"],"提供可靠的":["9.36"],"面向连接的数据传输":["9.36"],"适用于对数据可靠性和顺序性有要求的应用":["9.36"],"提供无连接的":["9.36"],"客户端在后续的请求中将该":["9.38"],"包含在请求头":["9.38"],"中发送给服务器进行身份验证":["9.38"],"服务器在接收到":["9.38"],"后解密并验证其有效性":["9.38"],"从而确定用户的身份":["9.38"],"可以包含一些用户信息":["9.38"],"但通常不存储在服务器端":["9.38"],"而是在令牌本身进行加密和验证":["9.38"],"常见的":["9.38"],"一个进程可以拥有多个线程":["9.39"],"防止恶意代码注入":["10.1"],"对输出到":["10.1"],"页面的数据进行编码":["10.1"],"避免恶意代码在浏览器中执行":["10.1"],"使用":["10.1","11.9","14.0","34.22","34.27","41.9","44.31","46.2","51.7","59.6"],"security":["10.1"],"policy":["10.1"],"csp":["10.1"],"策略":["10.1"],"限制页面中可以执行的脚本":["10.1"],"端口扫描等":["10.2"],"应用程序架构和设计":["10.2"],"web应用程序的架构和设计也可以影响安全性":["10.2"],"例如":["10.2","16.1","19.74"],"使用安全的框架":["10.2"],"设计模式和最佳实践":["10.2"],"可以降低应用程序受攻击的风险":["10.2"],"xss":["10.3"],"是指攻击者将":["10.3"],"恶意脚本":["10.3"],"目标网站接收请求并执行":["10.4"],"目标网站接收到请求后":["10.4"],"浏览器在发送请求时会自动附上用户的会话信息":["10.4"],"导致目标网站无法区分正常请求和恶意请求":["10.4"],"限制":["10.5"],"的跨站请求":["10.5"],"访问":["10.6"],"安全编码实践":["10.6"],"遵循安全编码实践":["10.6"],"包括对输入进行严格验证":["10.6"],"就是":["11.1","44.34"],"开发工具包":["11.1"],"做出不同的处理":["11.2"],"动态多态性":["11.2"],"在子类中重写父类的方法":["11.2"],"character":["11.3"],"integer":["11.3"],"相当于将基本类型包装起来":["11.5"],"使得它具有了对象的性质":["11.5"],"并且为其添加了属性和方法":["11.5"],"println":["11.6","11.12","11.21","16.19","16.30","17.12","17.13"],"true":["11.6","20.3","20.15","22.7","34.5","45.32","50.3","50.4","62.0"],"c":["11.6","16.21","45.9","73.2"],"d":["11.6"],"下次需要创建同样的对象时":["11.7"],"可以直接返回缓存的引用":["11.7"],"既然我们的string是不可变的":["11.7"],"它内部还有很多substring":["11.7"],"replace":["11.7"],"replaceall这些操作的方法":["11.7"],"这些方法好像会改变string对象":["11.7"],"是线程安全的":["11.8"],"内部使用":["11.8"],"的方式会在":["11.9"],"如果不存在":["11.10"],"则创建此字符串并放入池中":["11.10"],"那就不必在进行equals的比较":["11.11"],"这样就大大减少了equals比较的次数":["11.11"],"system":["11.12","16.30","17.12","17.13"],"out":["11.12","16.19","16.30","17.12","17.13"],"方法改写":["11.14"],"override":["11.14","11.19"],"final修饰成员变量时":["11.16"],"不允许修饰默认值":["11.16"],"子类可以继承":["11.17"],"冲突":["11.17"],"final":["11.17"],"被abstract修饰的方法":["11.17"],"强制要求子类重写":["11.17"],"被final修饰的方法子类不能重写":["11.17"],"private":["11.17","16.42"],"接口的子类要强制重写接口的抽象方法":["11.18"],"或者子类也是抽象类":["11.18"],"意义不大":["11.18"],"接口没有构造方法":["11.18"],"接口的成员变量":["11.18"],"只能定义常量":["11.18"],"系统会默认加入":["11.18"],"implements":["11.19"],"抽象类是对事物进行描述":["11.20"],"接口是制定规则":["11.20"],"多态成员访问特点":["11.21"],"可以抽取重复代码":["11.23"],"静态只能访问外部的静态类":["11.24"],"非要调用需要先创建外部类对象再调用":["11.24"],"引用时":["11.24"],"valueof":["11.25"],"个或":["11.26"],"表示匹配":["11.26"],"个字母":["11.26"],"只匹配":["11.26"],"个字符":["11.26"],"手动抛出异常":["11.28"],"install":["12.1"],"安装项目到本地仓库":["12.1"],"datesource":["13.1"],"values":["13.3","22.8"],"批量删除":["13.3"],"collection":["13.3"],"要遍历集合":["13.3"],"item":["13.3","42.3","75.10"],"遍历出来的元素":["13.3"],"separator":["13.3"],"分隔符":["13.3"],"便利开始前拼接的sql字段":["13.3"],"close":["13.3"],"便利结束后拼接的sql字段":["13.3"],"databases":["14.0"],"use":["14.0","46.6"],"数据控制语言":["14.1"],"null":["14.2","37.9","72.10"],"唯一约束":["14.2"],"unique":["14.2"],"主键约束":["14.2"],"primary":["14.2","79.2"],"char":["14.3"],"定长字符串":["14.3"],"varchar":["14.3"],"where":["14.4"],"07":["14.4"],"排序字段列表":["14.5"],"limit":["14.5"],"min":["14.6"],"avg":["14.6"],"sum":["14.6","60.0"],"而having可以":["14.7"],"update":["14.9"],"time":["14.9"],"case":["14.10"],"job":["14.10","14.12"],"when":["14.10"],"学生":["14.10"],"字段名写为":["14.11"],"要关联的表":["14.11"],"要关联的表的字段":["14.11"],"老师":["14.12"],"列子查询":["14.12"],"entrydate":["14.12"],"吕江涛":["14.12"],"行子查询":["14.12"],"s":["14.13","45.14"],"sd":["14.13"],"copies":["14.13"],"setmeal":["14.13"],"必须使所有数据都保持一致状态":["14.14"],"隔离性":["14.14"],"数据库系统提供的隔离机制":["14.14"],"保证事务在不受外部操作影响的独立环境下运行":["14.14"],"drop":["14.15"],"resource与":["15.2"],"autowired区别":["15.2"],"默认是按照名称进行":["15.2"],"目标对象":["15.3"],"afterthrowing":["15.4"],"异常通知":["15.4"],"控制执行顺序":["15.5"],"ioc容器中":["15.7"],"conditionalonclass":["15.7"],"判断当前环境中是否有对应的字节码文件":["15.7"],"才注册bean到ioc容器中":["15.7"],"conditionalonmissingbean":["15.7"],"正在等待其他线程去执行一个特定的操作":["16.1"],"因为wait":["16.1"],"而等待的线程正在等待另一个线程去调用notify":["16.1"],"或notifyall":["16.1"],"一个因为join":["16.1"],"而等待的线程正在等待另一个线程结束":["16.1"],"一个在限定时间内等待的线程的状态":["16.1"],"也称之为限时等待状态":["16.1"],"造成线程限时等待状态的原因有三种":["16.1"],"分别是":["16.1"],"sleep":["16.1","16.19"],"线程执行完毕之后":["16.3","16.4"],"n":["16.3","16.4"],"控制台输出":["16.3"],"控制台输出结果":["16.4","16.5","16.17","16.19","16.25","16.30","16.33","16.47"],"创建线程对象后":["16.5"],"但是不调用start方法的状态":["16.5"],"当我们向线程池提交任务的时":["16.6"],"线程池就":["16.6"],"会启动一个线程来执行该任务":["16.6"],"等待任务执行完毕以后":["16.6"],"执行完毕后":["16.8"],"继续等待下一次任务的到来":["16.8"],"在整个过程中":["16.8"],"都不需要创建新的线程":["16.8"],"通过控制台的输出":["16.9"],"我们可以看到在线程池中存在两个线程":["16.9"],"通过这2个线程处理了10个任务":["16.9"],"使用有参构造方法创建线程池对象":["16.9"],"传递的参数是5":["16.9"],"案例5":["16.11"],"scheduledexecutorservice中和定时以及周期性执行相关的方法":["16.11"],"定时执行":["16.11"],"command":["16.11"],"任务类对象":["16.11"],"delay":["16.11"],"延迟多长时间开始执行任务":["16.11"],"任务提交到线程池以后我们需要等待多长时间开始执行这个任务":["16.11"],"unit":["16.11"],"指定时间操作单元":["16.11"],"scheduledfuture":["16.11"],"schedule":["16.11"],"long":["16.11","16.42"],"周期性执行":["16.11"],"initialdelay":["16.11"],"延迟多长时间开始第一次该执行任务":["16.11"],"任务提交到线程池以后我们需要等待多长时间开始第一次执行这个任务":["16.11"],"period":["16.11"],"下一次执行该任务所对应的时间间隔":["16.11"],"scheduleatfixedrate":["16.11"],"测试类1":["16.11"],"演示定时执行":["16.11"],"arrayblockingqueue":["16.13"],"executors":["16.13"],"defaultthreadfactory":["16.13"],"abortpolicy":["16.13"],"以上代码表示的意思是":["16.13"],"核心线程池中的线程数量最大为1":["16.13"],"整个线程池中最多存在3个线程":["16.13"],"空闲线程最大的存活时间为60":["16.13"],"时间单位为秒":["16.13"],"阻塞队列使用的是有界阻塞队列":["16.13"],"容量为3":["16.13"],"使用默认的线程工厂":["16.13"],"又比较缓慢":["16.14"],"工厂主管可能就考虑辞掉4个临时工了":["16.14"],"只保持原来的10个工人":["16.14"],"毕竟请额外的工人是要花钱的":["16.14"],"这里的工厂可以看做成是一个线程池":["16.14"],"每一个工人可以看做成是一个线程":["16.14"],"其中10个正式员工":["16.14"],"提交一个任务":["16.15"],"1571735465100":["16.15"],"再次查看各个值的变化":["16.15"],"1571735607347":["16.15"],"再次提交一个任务":["16.15"],"1571735715977":["16.15"],"此时会把第二个任务存储到工作队列中":["16.15"],"因此工作队列的值为1了":["16.15"],"执行了任务2":["16.16"],"执行了任务0":["16.16"],"执行了任务3":["16.16"],"执行了任务4":["16.16"],"由于任务1在线程池中等待时间最长":["16.16"],"因此任务1被丢弃":["16.16"],"案例演示4":["16.16"],"callerrunspolicy任务处理策略":["16.16"],"threadpoolexecutordemo04":["16.16"],"main线程中获取开启的线程中flag的值为":["16.17"],"前面是false":["16.17"],"过了一段时间之后就变成了true":["16.17"],"按照我们的分析":["16.17"],"当我们把volatilethread线程启动起来以后":["16.17"],"那么volatilethread线程开始执行":["16.17"],"在volatilethread线程的run方法中":["16.17"],"线程对变量的所有的操作":["16.18"],"读":["16.18"],"写":["16.18"],"都必须在工作内存中完成":["16.18"],"而不能直接读写主内存中的变量":["16.18"],"执行了":["16.19"],"让线程休眠100毫秒":["16.19"],"timeunit":["16.19"],"milliseconds":["16.19"],"对上述代码加锁完毕以后":["16.21"],"某一个线程支持该程序的过程如下":["16.21"],"a":["16.21","42.3","60.0","74.2"],"线程获得锁":["16.21"],"b":["16.21","60.0","67.4","75.15"],"清空工作内存":["16.21"],"从主内存拷贝共享变量最新的值到工作内存成为副本":["16.21"],"但是不保证原子性":["16.22"],"多线程进行写操作":["16.22"],"不保证线程安全":["16.22"],"而synchronized是一种排他":["16.22"],"互斥":["16.22"],"的机制":["16.22"],"因此有时我们也将synchronized这种锁称":["16.22"],"之为排他":["16.22"],"锁":["16.22"],"synchronized修饰的代码块":["16.22"],"被修饰的代码块称之为同步代码块":["16.22"],"无法被中断可以保证原子性":["16.22"],"也可以间接的保证可见性":["16.22"],"原子性":["16.22"],"概述":["16.22"],"所谓的原子性是指在一次操作或者多次操作中":["16.22"],"要么所有的操作全部都得到了执行并且不会受到任何因素的干扰而中断":["16.22"],"要么所有的操作都不执行":["16.22"],"多个操作是一个不可以分割的整体":["16.22"],"比如说":["16.22"],"start":["16.23","16.27","16.43","16.47"],"程序分析":["16.23"],"我们在主线程中通过for循环启动了100个线程":["16.23"],"每一个线程都会对volatileatomicthread类中的count加100次":["16.23"],"那么直接结果应该是10000":["16.23"],"但是真正的执行结果和我们分析":["16.23"],"的是否一样呢":["16.23"],"运行程序":["16.23"],"多运行几次":["16.23"],"查看控制台输出结果":["16.23"],"由于此时线程b没有将工作内存中的数据刷新到主内存":["16.24"],"因此a线程工作内存中的变量值还是100":["16.24"],"没有失效":["16.24"],"a线程对工作内存中的数据进行了":["16.24"],"需要运行多次":["16.25"],"这里我们举两个基本的使用场景":["16.26"],"创建线程对象":["16.27","16.43"],"thread":["16.27"],"启动线程":["16.27"],"主线程休眠":["16.27"],"static":["16.28","16.49","17.17"],"main":["16.28","16.49","17.17"],"args":["16.28","16.49","17.17"],"new":["16.28","16.45","17.13","20.13","24.2","36.12","72.12","73.2"],"for":["16.28"],"x":["16.28","16.36"],"size":["16.35","72.11","72.12"],"自旋":["16.35"],"1571818465276":["16.35"],"这一次比较幸运":["16.35"],"没有其他线程改变v的值":["16.35"],"线程1进行compare":["16.35"],"发现a和v的值是相等的":["16.35"],"1571818597998":["16.35"],"unsafe类中的weakcompareandsetint方法":["16.36"],"boolean":["16.36","16.46"],"expected":["16.36","20.4","20.8","20.15"],"compareandsetint":["16.36"],"但是在更新的时候会判断一下在此期间别人有没有去更新这个数据":["16.37"],"cas这种机制我们也可以将其称之为乐观锁":["16.37"],"并发工具类":["16.37"],"案例3":["16.39"],"演示concurrenthashmap线程安全":["16.39"],"concurrenthashmapdemo01":["16.39"],"创建一个concurrenthashmap集合对象":["16.39"],"concurrenthashmap":["16.39","17.10"],"因此需要分别来讲解一下两个不同版本的实现原理":["16.40"],"e":["16.41","21.8","34.17"],"若不为null":["16.41"],"判读当前节点的key是否和链表头节点的key相同":["16.41"],"依赖于hashcode方法和equals方法":["16.41"],"如果相同":["16.41"],"值进行更新":["16.41"],"equals":["16.41"],"break":["16.41","72.11","72.12"],"else":["16.41","42.8","53.30","67.5"],"若头结点为null":["16.41"],"将新节点添加到链表中":["16.41"],"setnext":["16.41"],"addcount":["16.42"],"1l":["16.42"],"cas算法的核心类":["16.42"],"sun":["16.42"],"misc":["16.42"],"unsafe":["16.42"],"try":["16.42"],"getunsafe":["16.42"],"exception":["16.42"],"error":["16.42","36.9","42.5","42.19"],"原子获取链表节点":["16.42"],"getobjectvolatile":["16.42"],"ashift":["16.42"],"abase":["16.42"],"cas更新或新增链表节点":["16.42"],"并启动线程":["16.43"],"t1":["16.43"],"t2":["16.43"],"在主线程中调用":["16.43"],"countdownlatch中的await让主线程处于阻塞状态":["16.43"],"thread1":["16.45"],"thread2":["16.45"],"thread3":["16.45"],"获取concurrenthashmap中的数据进行汇总":["16.46"],"enumeration":["16.46"],"keys":["16.46"],"获取concurrenthashmap中所有的键":["16.46"],"这个enumeration的使用和我们之前所学习过的迭代器类似":["16.46"],"hasmoreelements":["16.46"],"判断集合中是否存在下一个元素":["16.46"],"把铝戒给老公":["16.49"],"得到老公给的":["16.49"],"exchangerdemo01":["16.49"],"线程死亡":["17.8"],"死亡":["17.8"],"六大状态":["17.8"],"可能导致数据损坏":["17.9"],"不一致的状态":["17.9"],"这些数据结构在内部实现上已经考虑了线程安全性":["17.10"],"避免共享资源":["17.10"],"如get":["17.11"],"compareandset":["17.11"],"等":["17.11","44.5"],"getname":["17.12"],"runtimeexception":["17.13"],"lock是一个接口":["17.15"],"需要reentrantlock实现类":["17.15"],"test":["17.17"],"在提交就会排队":["17.18"],"队伍满时":["17.18"],"会创建临时线程":["17.18"],"当核心线程满":["17.18"],"等待时间":["17.19"],"deptcontroller":["18.1"],"class":["18.1","19.4","36.1"],"requestmethod":["18.2"],"service又返回到了deptcontroller方法里":["18.3"],"再返回给前端":["18.3"],"pagehelper":["18.4"],"startpage":["18.4"],"执行查询":["18.4"],"需要强转为page类型":["18.4"],"p":["18.4","36.10","37.10","44.32"],"workers是完全独立的线程":["19.1"],"不能访问dom":["19.1"],"object":["19.2","19.30"],"function":["19.2","20.26","45.13"],"可以准确地判断复杂引用数据类型":["19.3"],"但是不能正确判断基础数据类型":["19.3"],"person":["19.4"],"getsymbol":["19.4"],"return":["19.4","19.75","20.26","36.7","36.10","36.12","37.8","37.15","38.0","42.4","42.12","69.5","69.6","70.1","72.3","72.6","74.2","75.1","75.2","75.3","75.26","76.5","76.6","77.4"],"isprototypeof":["19.4"],"类似":["19.4","36.15"],"isarray":["19.4"],"专业检测数组三十年":["19.4"],"isnan":["19.4"],"属于":["19.4"],"es6":["19.4","45.16"],"标准":["19.4"],"中有一个特殊的":["19.4"],"数字":["19.4"],"nan":["19.4","20.21"],"not":["19.4"],"不是一个数字":["19.4"],"但它却归属于数字类型":["19.4"],"读到就加载并执行":["19.5"],"先执行下载js脚本然后执行然后再解析html":["19.5"],"async脚本下载完成后立即执行":["19.6"],"然后开始解析剩下的html":["19.6"],"执行时会在html页面解析完毕之后再去执行":["19.7"],"domcontentloaded之前执行":["19.8"],"当前宏任务执行完成后":["19.11"],"会查看微任务的事件队列":["19.11"],"然后将里面的所有微任务依次执行完":["19.11"],"再把当前的微任务队列清空":["19.12"],"以此往复":["19.12"],"宏任务队列只有一个":["19.12"],"mutationobserver":["19.13"],"监听dom":["19.13"],"node":["19.13"],"中的":["19.13"],"本轮循环中的微任务实际上就是在插队":["19.14"],"这样微任务中所做的状态修改":["19.14"],"为4ms":["19.15"],"所以执行第一个宏任务的script的时间大于4ms执行settimeout的回调":["19.15"],"将函数插入到微任务队列":["19.16"],"tick队列比微任务队列先执行":["19.16"],"也不会影响":["19.21"],"和方法":["19.22"],"实现模块化开发":["19.22"],"保存函数执行状态和数据":["19.22"],"实现记忆化和缓存":["19.22"],"创建多个具有相同功能的函数":["19.22"],"实现":["19.22"],"柯里化和高阶函数":["19.22"],"处理":["19.22"],"释放内存":["19.24"],"垃圾回收机制认为他还在用":["19.25"],"从而导致这段内存无法释放":["19.25"],"程序对一段内存失去了控制":["19.25"],"如果找不到":["19.26"],"就会沿着作用域链中查找":["19.26"],"a为真时执行a":["19.29"],"prototype":["19.30","20.1","53.1","85.12"],"内容存在堆内存中":["19.31"],"tostring":["19.34","20.20","26.1","53.1","85.12"],"所以被判断为object":["19.36"],"转成boolean类型":["19.38"],"逻辑非运算符":["19.38"],"另一个操作数不是":["19.39"],"则调用对象的tostring":["19.39"],"方法":["19.39","45.4"],"也不大于":["19.40"],"所以是false":["19.40"],"所以是true":["19.41"],"左边为字符串":["19.42"],"转换为0":["19.42"],"最终为":["19.42"],"然后再变回小数":["19.43"],"tofixed":["19.43"],"性能不好":["19.43"],"false":["19.45","20.7","20.20","22.3","34.5","69.5"],"执行":["19.46"],"目标阶段":["19.48"],"但是与xhr无关":["19.49"],"不支持ie":["19.49"],"加载图片等外部文件":["19.50"],"event":["19.51","19.52","34.14"],"cancelbubble":["19.51"],"returnvalue":["19.52"],"会由于事件委托的原因":["19.53"],"自动接收到父元素的事件监听":["19.53"],"返回去重后的新数组":["19.54"],"number":["19.55","42.21","60.0"],"filter":["19.58"],"对数组所有项进行判断":["19.58"],"返回符合规则的新数组":["19.58"],"every":["19.58"],"数组每一项都符合规则才返回true":["19.58"],"some":["19.58","53.8"],"数组有符合规则的一项就返回true":["19.58"],"reduce":["19.58","41.7"],"m":["19.59"],"对num取m次幂":["19.59"],"random":["19.59"],"mm":["19.61"],"ddthh":["19.61"],"开始的部分":["19.63"],"href":["19.63"],"获取整个url":["19.63"],"hash":["19.63"],"检索":["19.64"],"修改xhtml文档内容与结构":["19.64"],"因为":["19.64"],"document对象又是dom的根节点":["19.64"],"可以说":["19.64"],"bom包含了dom":["19.64"],"ello":["19.66"],"ell":["19.67"],"早期版本的js忽略了":["19.68"],"取决于":["19.69"],"type":["19.69","50.3","79.2"],"具有":["19.71"],"属性和按索引访问属性的能力":["19.71"],"使用扩展运算符":["19.72"],"遍历字符串的字符":["19.73"],"可以通过调用字符串的":["19.74"],"方法获得的迭代器对象":["19.74"],"typedarray":["19.74"],"int32array":["19.74"],"apply":["19.75","59.2"],"鼠标指针相对于浏览器窗口可视区域左上角的垂直坐标":["19.76"],"pagex":["19.76"],"鼠标指针相对于整个文档页面左上角的水平坐标":["19.76"],"创建阶段":["19.77"],"执行阶段":["19.77"],"每当引擎碰到一个函数的时候":["19.78"],"它就会创建一个函数执行上下文":["19.78"],"继承属性和方法":["20.1"],"properties":["20.4"],"can":["20.4"],"be":["20.4"],"overwritten":["20.4"],"output":["20.4","20.8","20.10","20.15","20.25"],"strict":["20.6"],"console":["20.6","20.31","34.8","36.16","42.7","42.30","65.2","65.3","65.4","65.5","65.6","70.1","75.1","75.2","75.3","75.4","75.9","75.10","75.14","75.16","75.18","75.19","75.20","75.21","75.26","75.27","75.28","75.30","75.31","75.32","76.4","76.5","76.6","76.7","77.3","77.4","77.5"],"log":["20.6","20.31","21.2","34.8","36.16","42.7","42.30","65.1","65.2","65.3","65.5","65.6","75.4","75.5","75.8","75.9","75.14","75.16","75.18","75.19","75.21","75.27","75.30","75.32","76.4","76.5","76.6","76.7","77.1","77.2","77.3","77.5"],"etc":["20.7"],"冻结一个对象后该对象的原型也不能被修改":["20.9"],"属性的值":["20.11"],"fly":["20.13"],"is":["20.13","42.7","44.26"],"flying":["20.13"],"const":["20.13","24.2","37.15","45.14","73.1","73.2"],"superman":["20.13"],"备注":["20.14"],"与":["20.14","34.5","36.15"],"instanceof":["20.14","59.8"],"运算符不同":["20.14"],"在表达式":["20.14"],"afunction":["20.14"],"value":["20.16","42.29","44.29","44.59","45.19","45.21","50.2","75.24","86.2"],"该数组对元素是":["20.17"],"obj自身拥有的枚举或不可枚举属性名称字符串":["20.17"],"0n":["20.22"],"array":["20.25"],"non":["20.26"],"arr":["20.30","22.4"],"then函数":["21.0"],"当执行了reject函数":["21.0"],"reject":["21.1"],"的状态":["21.1"],"实例的方法":["21.1"],"是用来抛出异常":["21.1"],"rej":["21.3"],"hi":["21.3"],"指向了promise原型对象":["21.4"],"then的返回值":["21.5"],"then方法是有返回值的":["21.5"],"catch的返回值":["21.6"],"execute":["21.7"],"any":["21.8"],"与race类似":["21.8"],"只获取第一个状态为fulfilled":["21.8"],"如果全部为rejected则报错aggregateerror":["21.8"],"then调用后变为异步微任务":["21.9"],"has":["22.7","67.5","67.6"],"delete":["22.7"],"将字典中包含的所有数值以迭代器形式返回":["22.8"],"entries":["22.8"],"返回所有成员的迭代器":["22.8"],"无法准确地确定键值对的数量":["22.11"],"weakset等都是弱引用":["22.11"],"得到的是":["23.1"],"在浏览器中":["23.1"],"所有的全局变量和全局函数都会成为":["23.1"],"它的值指向触发事件的对象":["23.2"],"箭头函数中的":["23.2"],"在箭头函数中调用":["23.2"],"bind可以分为多次传入":["23.4"],"bind是返回绑定this之后的函数":["23.4"],"并尝试强制类型转换":["24.1"],"看看逻辑非运算符":["24.2"],"number1":["24.2"],"逻辑与运算符":["24.3"],"逻辑或运算符":["24.3"],"保存到父域中":["25.0"],"这样所有的子域应用就都可以访问到这个cookie":["25.0"],"app2系统不需要走登录流程":["25.1"],"就已经是登录了":["25.1"],"sso":["25.1"],"app和app2在不同的域":["25.1"],"它们之间的session不共享也是没问题的":["25.1"],"访问子系统1没有登录":["25.1"],"跳转sso系统登录":["25.1"],"登录状态写入":["25.1"],"sso的session":["25.1"],"生成token给子系统1":["25.1"],"数组扁平化":["26.1"],"返回一个新数组":["26.1"],"字符串相关":["26.1"],"join":["26.1","73.1","73.2"],"将数组拼接成字符串":["26.1"],"tolocalstring":["26.1"],"本地化格式转字符串":["26.1"],"用":["26.1"],"分隔成字符串":["26.1"],"复制到从":["26.5"],"号位开始的位置":["26.5"],"结果覆盖了原来的":["26.5"],"表示匹配以hello开头的字符串":["27.0"],"world":["27.0"],"表示匹配以world结尾的字符串":["27.0"],"匹配分组":["27.0"],"用圆括号":["27.0"],"表示分组":["27.0"],"可以将多个字符视为一个整体进行匹配":["27.0"],"创建一个声明文件":["28.1"],"作用是为了让组件有属性提示":["28.1"],"具名插槽做的":["28.2"],"文本域自适应高度":["28.2"],"比较复杂":["28.2"],"通过创建一个虚拟文本域":["28.2"],"通过window":["28.2"],"getcomputedstyle":["28.2"],"获取原生css对象":["28.2"],"getpropertyvalue":["28.2"],"获取css属性值":["28.2"],"把当前文本域的属性和值赋给虚拟文本域":["28.2"],"通过计算虚拟文本域的":["28.2"],"scrollhight":["28.2"],"总高度":["28.2"],"来计算真实文本域高度这里要判断":["28.2"],"actions写一些复杂的逻辑和异步逻辑":["28.7"],"不同平台可以共享相同的业务逻辑和数据处理功能":["28.9"],"更好的用户体验":["28.9"],"前后端分离可以通过前端技术的灵活性和交互性":["28.9"],"3的一个重要特性是使用quic代替了tcp作为传输层协议":["28.10"],"quic通过减少连接建立时间":["28.10"],"降低丢包重传延迟等优化":["28.10"],"提供更快的数据传输和更可靠的连接":["28.10"],"tls协议来确保通信的安全性和完整性":["28.11"],"然而":["28.11"],"中间人攻击利用了攻击者能够截取和篡改通信流量的位置":["28.11"],"wed":["28.12"],"may":["28.12"],"08":["28.12"],"00":["28.12"],"尽量使用":["28.13"],"动画或过渡":["28.13"],"以平滑地过渡":["28.13"],"避免突然的布局变化":["28.13"],"优化css和布局":["28.14"],"减少css文件的大小":["28.14"],"使用合适的选择器和样式规则":["28.14"],"避免过度嵌套和复杂的布局结构":["28.14"],"性能监测和优化":["28.14"],"使用性能分析工具":["28.14"],"使用工具如chrome开发者工具":["28.14"],"yaml文件中":["28.16"],"从而更好地管理依赖版本":["28.16"],"yarn":["28.17"],"commonjs":["29.1","29.5"],"模块有一个独立的静态解析阶段":["29.2"],"依赖关系的分析是在那个阶段完成的":["29.2"],"br":["29.3"],"如果不希望将后缀名改成":["29.3"],"mjs":["29.3"],"可以在项目的package":["29.3"],"require":["29.4","42.32"],"不支持":["29.4"],"模块的一个原因是":["29.4"],"它是同步加载":["29.4"],"cjs文件总是以":["29.5"],"优先输出process":["29.7"],"nexttick的值":["29.7"],"dirname":["29.8"],"rmdir":["29.9"],"实现了高并发处理能力":["29.10"],"localstorage的有效期是在不进行手动删除的情况下是一直有效的":["30.1"],"可能和浏览器有部分差异性":["30.2"],"不参与与服务端的通信":["30.3"],"比如ie8版本以下的都不支持":["30.5"],"无需再次带上用户名和密码":["30.7"],"然后去验证客户端请求里面带着token":["30.8"],"如果验证成功":["30.8"],"会有csrf攻击":["30.9"],"path":["30.10","43.11"],"cookie的使用路径":["30.10"],"则默认为当前路径":["30.10"],"安全标志":["30.10"],"secure":["30.10"],"vite启动开发服务器":["31.1"],"preview命令作用是实时预览打包后代码":["31.1"],"可以获取类型提示":["31.3"],"在终端执行pnpm":["32.0"],"默认在dist的main":["32.0"],"adminapp":["32.3"],"必须要绝对路径":["32.4"],"传递给下一个":["32.5"],"依此类推":["32.5"],"最后":["32.5"],"链中的最后一个":["32.5"],"返回":["32.5"],"preset":["32.6"],"env":["32.6"],"在package":["32.6"],"json中设置兼容列表":["32.6"],"htmlwebpackplugin":["32.7"],"template":["32.7","46.2","46.3"],"src":["32.7"],"的长连接":["32.8"],"查看堆栈跟踪或查看日志时":["32.9"],"你将看到原始的":["32.9"],"易于阅读的代码":["32.9"],"设置localstorage时间":["33.0"],"浏览器输入url发生了什么":["33.0"],"vue的keepalive":["33.0"],"垃圾回收":["33.0"],"三栏布局实现":["33.0"],"diff":["33.0"],"vue数据双向绑定":["33.0"],"eventloop宏任务微任务":["33.0"],"声明式编程":["34.1"],"component":["34.1"],"使用内联函数":["34.2"],"则每次调用render函数时都会创建一个新的函数实例":["34.2"],"fragments":["34.2"],"避免额外标记":["34.2"],"在":["34.2","34.14","36.2","37.3"],"render方法中":["34.2"],"使用bind和render方法中使用箭头函数这两种形式在每次组件render的时候都会生成新的方法实例":["34.2"],"中":["34.3","43.10"],"需要手动调用来进行状态更新":["34.3"],"生命周期":["34.4"],"类组件提供了一系列的生命周期方法":["34.4"],"如":["34.4"],"componentdidmount":["34.4"],"componentdidupdate":["34.4","34.6"],"componentwillunmount":["34.4"],"用于处理组件的不同生命周期阶段":["34.4"],"函数组件没有生命周期方法":["34.4"],"但可以使用":["34.4"],"useeffect":["34.4"],"来确定是否需要重新渲染子组件":["34.5"],"如果需要则返回true":["34.5"],"不需要则返回":["34.5"],"该函数默认返回":["34.5"],"更新前被调用":["34.6"],"并且返回一个值作为componentdidupdate第三个参数":["34.6"],"在组件更新后调用":["34.6"],"可以进行":["34.6"],"操作":["34.6"],"网络请求等副作用操作":["34.6"],"发生变化后根据":["34.7"],"修改":["34.7"],"snapshot":["34.8"],"jsx":["34.9"],"元素":["34.9"],"由于无状态组件没有状态":["34.9"],"所以它的性能通常比有状态组件高":["34.9"],"因为它":["34.9"],"不需要进行额外的状态管理和更新":["34.9"],"并且在这个数据修改时":["34.10"],"告诉这个视图":["34.10","40.1"],"你需要重新渲染了":["34.10","40.1"],"react的组件渲染是很消耗性能的":["34.10","40.1"],"父组件的状态更新了":["34.10","40.1"],"同样在图中标出了节点遍历完成的顺序":["34.11"],"跟树结构对比会发现":["34.11"],"虽然数据结构不同":["34.11"],"但是节点的遍历开始和完成顺序一模一样":["34.11"],"不同的是":["34.11"],"当遍历发生中断时":["34.11"],"只要保留下当前节点的索引":["34.11"],"断点是可以恢复的":["34.11"],"只要保留下中断的节点索引":["34.12"],"就可以恢复之前的工作进度":["34.12"],"附加事件处理器":["34.13"],"而会将事件处理器附加到渲染":["34.13"],"查找当前元素以及它所有父级":["34.14"],"事件池中查找事件回调并合成到":["34.14"],"合成事件结束":["34.14"],"在事件池中获取或释放事件对象":["34.15"],"即":["34.15","41.6"],"事件对象不会被释放掉":["34.15"],"而是存放进一个数组中":["34.15"],"当事件触发":["34.15"],"合成事件到原生事件的映射":["34.16"],"plugins":["34.16"],"在事件处理函数运行之后获取不到事件对象的属性":["34.17"],"需要用":["34.17"],"而合成事件的阻止冒泡不会影响原生事件":["34.18"],"最后真正执行":["34.19"],"react":["34.20","36.2","36.6","38.3"],"enhancedcomponent":["34.21"],"渲染增强后的组件":["34.21"],"reactdom":["34.21"],"getelementbyid":["34.21"],"root":["34.21"],"的话":["34.22"],"我们可以在创建组件时添加一个叫做":["34.22"],"这就是导致每次更新都重新渲染的原因":["34.23"],"ref":["34.24","44.27","50.1","62.0"],"还需要借助":["34.25"],"值来判断元素与本地状态的关联关系":["34.25"],"因此我们决不可忽视转换函数中":["34.25"],"卸载子组件":["34.26"],"从而导致组件不断地重新渲染":["34.27"],"进而导致无限循环":["34.27"],"in":["34.28"],"本质是通过函数的调用":["34.28"],"最终创建出一个组件":["34.28"],"当有一组动画的时候":["34.29"],"就可将这些csstransition放入到一个transitiongroup中来完成动画":["34.29"],"用到了key属性":["34.29"],"插入的节点":["34.29"],"先渲染dom":["34.29"],"包括展示组件和容器组件":["34.30"],"getderivedstatefromerror":["34.31"],"即节点在原集合中比在新集合中靠右":["35.1"],"说明该元素不会影响到其他元素的位置":["35.1"],"因此不会被添加到差异队列中":["35.1"],"不执行移动操作":["35.1"],"反之":["35.1"],"进行移动操作":["35.1"],"也就是说旧集合的节点的index在新集合节点的index的右边":["35.1"],"oldindex":["35.1"],"newindex":["35.1"],"那这个节点不移动":["35.1"],"当旧集合的节点的index在对应新集合节点的index的左边":["35.1"],"继续递归地应用diff算法":["35.2"],"比较每对相同位置的子节点的差异":["35.2"],"在比较子节点的过程中":["35.2"],"js会使用一些优化策略":["35.2"],"例如为每个子节点添加唯一的key属性":["35.2"],"如果一开始没有找到相同的节点":["35.3"],"则":["35.3"],"在旧列表中找与新列表头一个节点相同的节点":["35.3"],"找到则移到头部":["35.3"],"判断是否需要移动节点":["35.5"],"如果是升序的则不需要移动":["35.5"],"利用最长递增子序列来优化移动逻辑":["35.5"],"通过最长递增子序列获取到升序列表存放的是索引":["35.5"],"将生成好的虚拟dom渲染到指定容器上":["35.6"],"组件需要时时刻刻考虑事件的绑定":["36.1"],"的函数组件中调用":["36.2"],"时除了直接传递一个指定值以外":["36.3"],"react还允许我们通过一个回调函数来修改state":["36.3"],"回调函数的返回值就是新的state的值":["36.3"],"使用回调函数的好处是":["36.3"],"监听渲染是否完成":["36.4","38.1"],"batchedupdates将isbatchingupdates修改为true":["36.5","38.2"],"这样由":["36.5","38.2"],"控制的事件处理过程":["36.5","38.2"],"then内等":["36.6","38.3"],"无法掌控的":["36.6","38.3"],"在每次渲染后执行副作用操作":["36.7"],"在依赖项发生变化时执行副作用操作":["36.7"],"dependency1":["36.7"],"dependency2":["36.7"],"对应类组件中的componentdidmount生命周期":["36.7"],"在下次执行副作用操作之前进行清除操作":["36.7"],"就可能会导致浏览器再次回流和重绘":["36.8"],"而且由于两次绘制":["36.8"],"视图上可能会造成闪现突兀的效果":["36.8"],"list":["36.9"],"dispatch":["36.9"],"json":["36.9"],"button":["36.9","37.8","46.3","78.2","79.2"],"onclick":["36.9","37.8"],"周五":["36.9"],"div":["36.10","37.15","42.26","44.51"],"并且子组件做了大量渲染优化时":["36.11"],"才需要考虑使用":["36.11"],"usecallback缓存的函数":["36.13"],"也无法感知到这个细微的变化":["36.14"],"导致子组件被重新渲染":["36.14"],"确保将相同的函数引用传递给子组件":["36.14"],"以避免不必要的重新渲染":["36.14"],"只不过是":["36.15"],"对函数进行缓存":["36.15"],"可以单独使用":["36.15"],"但是单独使用的使用对性能优化并没有实质的提升":["36.15"],"且父组件此时重新渲染":["36.15"],"子组件同样会渲染":["36.15"],"countref":["36.16"],"handleclick":["36.16"],"组件实例的方法":["36.17"],"属性将":["36.17"],"传递给":["36.17"],"能够调度更新":["36.19"],"从而改善用户体验":["36.20"],"deferredvalue":["36.21"],"redirect":["37.2","37.9","43.6"],"中添加":["37.3"],"后的部分作为路由路径":["37.3"],"传递回调函数":["37.4"],"fragment":["37.8"],"h1":["37.8","37.9","37.10","46.3"],"to":["37.9"],"current":["37.10"],"router6时被废弃":["37.11"],"用usematch代替":["37.11"],"query":["37.12"],"kobe":["37.12"],"height":["37.12"],"address":["37.12"],"洛杉矶":["37.12"],"布尔值":["37.14"],"路由是否作为默认组件显示":["37.14"],"blogpost":["37.16"],"let":["37.16","42.3","42.26"],"match":["37.16","53.19"],"就会触发diff算法的删除老组件并添加新组件的操作":["37.17"],"所以会产生重复的unmounting和mounting":["37.17"],"children":["37.17"],"优先级是最高的":["37.17"],"用法跟":["37.17"],"一样":["37.17"],"或者window":["37.18"],"history":["37.18"],"pushstate":["37.18"],"的样式":["37.19"],"activeclassname":["37.19"],"而不是":["38.0"],"等到":["38.4"],"浏览器事件结束的时候":["38.4"],"在相同的输入下":["38.5"],"它将始终呈现相同的输出":["38.5"],"是在组件中创建的":["38.5"],"一般在":["38.5"],"constructor中初始化":["38.5"],"来校验":["38.6"],"而使用":["38.6"],"使用了":["38.7"],"钩子函数":["38.7"],"它接收两个参数":["38.7"],"一个是回调函数":["38.7"],"另一个是依赖数组":["38.7"],"依赖数组是一个包含需要监视的变量的数组":["38.7"],"当数组中的变量发生变化时":["38.7"],"将会运行回调函数":["38.7"],"非首次渲染的操作":["38.8"],"非首次渲染":["38.8"],"这里可以执行你希望在非首次渲染时进行的其他操作":["38.8"],"数据不可变":["39.1"],"该组件以及它的子组件全部需要渲染":["39.2"],"需要额外的方法避免":["39.2"],"inlinestyle相对复杂":["39.3"],"会把前面的节点依次移动":["39.4"],"实现页面重渲染":["40.2"],"仓库":["41.0"],"的核心":["41.0"],"整合":["41.0"],"可以将":["41.1","52.5"],"分割成多个小模块":["41.1","52.5"],"每个模块都有自己的":["41.1","52.5"],"mutations没有了":["41.2"],"用this获取数据":["41.2"],"reducer是一个函数":["41.3"],"是state操作的整合函数":["41.3"],"每次修改state时都会触发该函数":["41.3"],"它的返回值会成为新的state":["41.3"],"来修改状态":["41.4"],"subscribe":["41.4"],"女":["41.5"],"改gender":["41.5"],"高老庄":["41.5"],"改address":["41.5"],"hr":["41.5"],"高老庄小学":["41.5"],"arg":["41.6"],"内函数的输出就是外函数的输入":["41.6"],"action":["41.6"],"返回给全局store的是经过中间件增强的dispatch":["41.7"],"funcs":["41.7"],"将需要的中间件放入数组中":["41.8"],"组合中间件":["41.9"],"chain":["41.9"],"创建":["41.9"],"redux":["41.9"],"时":["41.9"],"applymiddleware":["41.9"],"应用中间件":["41.9"],"使用这个函数":["41.10"],"先传递":["41.10"],"再传递":["41.10"],"最后传递":["41.10"],"age":["42.1"],"接口类型定义":["42.2"],"interface":["42.2"],"serachfunc":["42.2"],"类型成为了类型系统的顶级类型":["42.9"],"upname":["42.10"],"tolowercase":["42.10"],"typeof":["42.10"],"if":["42.10","44.51","53.19"],"string":["42.10"],"更宽泛的类型":["42.11"],"least":["42.11"],"specific":["42.11"],"和大":["42.11"],"可以互相代替":["42.11"],"用来表示原始类型":["42.11"],"语句推断函数返回的类型":["42.12"],"specifiedboolean":["42.16"],"对象的形状":["42.18"],"shape":["42.18"],"push":["42.19","44.24","45.4","53.30","59.4","75.22","75.23"],"girl":["42.23"],"起别名不会新建一个类型":["42.24"],"它创建了一个新":["42.24"],"名字来引用那个类型":["42.24"],"createelement":["42.26"],"类别名扩展接口":["42.28"],"表示对象中的键类型":["42.29"],"v":["42.29","46.2"],"表示对象中的值类型":["42.29"],"partial":["42.32"],"requird":["42.32"],"将类型的属性变成可选":["42.32"],"是代表移除":["42.32"],"pick":["42.32"],"uri":["43.2"],"html":["43.2"],"page的一个渲染":["43.3"],"改变会触发":["43.4"],"onhashchange":["43.4"],"不匹配任何静态资源":["43.5"],"它应提供与你的应用程序中的":["43.5"],"go":["43.6"],"在导航确认后被调用":["43.7"],"通常用于在组件实例化之":["43.7"],"前获取数据或执行其他异步操作":["43.7"],"当异步操作完成后":["43.7"],"通过调用next函数来确认导航":["43.7"],"beforerouteupdate":["43.7"],"在当前路由改变":["43.7"],"但是该组件被复用时调用":["43.7"],"因为在这种情况发生的时候":["43.7"],"组件已经挂载好了":["43.7"],"导航守卫可以访问组件实例":["43.7"],"失活的组件beforerouteleave":["43.8"],"复用的组件beforerouteupdate":["43.8"],"不会在组件的初始加载时被触发":["43.8"],"组件解析后beforeresolve":["43.8"],"等到需要访问组件的时候才进行真正的加载":["43.9"],"chunk":["43.10"],"router":["43.11"],"createrouter":["43.11"],"routes":["43.11"],"导航完成之前获取":["43.13"],"导航完成前":["43.13"],"在路由进入的守卫中获取数据":["43.13"],"命名路由参数":["43.14"],"可以在路由定义中使用命名的路由参数":["43.14"],"适用于标识资源的唯一性":["43.15"],"适用于传递可选参数":["43.15"],"过渡和动画":["44.1"],"hash和history路由实现浏览器url变化而不刷新页面":["44.2"],"组件销毁前调用":["44.3","52.0"],"destroyed":["44.3","52.0"],"onunmounted":["44.3"],"组件销毁完成调用":["44.3"],"还没开始销毁":["44.5"],"此时刚刚脱离运行阶段":["44.5"],"父beforedestroy":["44.6"],"子beforedestroy":["44.6"],"子destroyed":["44.6"],"if则更适合条件不经常改变的场景":["44.8"],"因为它切换开销相对较大":["44.8"],"根据数组中的某个元素进行v":["44.9"],"if判断的时候就会报错":["44.9"],"因为v":["44.9"],"watch在页面首次加载的时候默认不会执行":["44.10"],"需要设置immediate":["44.10"],"true首次才会执行监听":["44.10"],"所以computed属性的计算也是同步进行的":["44.12"],"以确保数据的一致性":["44.12"],"computed有返回值":["44.13"],"你可以在模板中像访问普通属性一样访问计算属性":["44.13"],"有异步请求的用wach":["44.14"],"vuex":["44.16"],"当data属性值变化后":["44.17"],"render函数执行":["44.17"],"是懒执行":["44.18"],"也就是说第一次初始化之后":["44.18"],"便不会执行计算":["44.18"],"本身所有数据对应一个":["44.19"],"在响应数据初始化时是不会执行回调函数的":["44.20"],"vue3中将beforecreate和created合并到了setup函数中":["44.21","51.3"],"根节点":["44.21"],"vue3组件允许多个根节点":["44.21"],"而vue2只允许一个":["44.21"],"el":["44.22"],"选项来自动挂载":["44.22"],"一旦挂载完成":["44.22"],"将开始监视数据变化":["44.22"],"并将模板渲染为真实":["44.22"],"生命周期钩子函数":["44.22"],"会依次调用":["44.22"],"实例的生命周期钩子函数":["44.22"],"观察者对象":["44.23"],"它会订阅":["44.23"],"被劫持的属性":["44.23"],"的变化":["44.23"],"pop":["44.24","70.1"],"shift":["44.24"],"并且将当前组件的实例传进来":["44.25"],"所以在插件中就可以对这个实例进行一些操作来实现我们插件的功能":["44.25"],"slotprops":["44.26"],"my":["44.26"],"and":["44.26"],"i":["44.26"],"expose":["44.27"],"兄弟组件传值":["44.27","52.4"],"eventbus":["44.27","52.4"],"getfileslist":["44.29"],"fileslist":["44.29"],"父":["44.29"],"vue3直接用":["44.31"],"场景":["44.33"],"当我们异步获取结果并赋值给state的时候":["44.33"],"比如数据请求":["44.33"],"count":["44.34"],"通过函数方式去使用的时候":["44.34"],"函数接受一个":["44.34"],"的参数":["44.34"],"仓库中的":["44.34"],"更符合开发者的开发习惯":["44.35"],"pinia中抛弃传统的":["44.35"],"mutation":["44.35"],"只有":["44.35"],"getter":["44.35"],"简化状态管理库":["44.35"],"状态state的修改可以直接进行修改":["44.35"],"alive有两个生命周期":["44.37"],"分别是activated和deactivated":["44.37"],"activated钩子会在首次挂载或者每次从缓存中被重新插入的时候调用":["44.37"],"执行顺序":["44.38"],"被缓存起来了":["44.39"],"可以降低代码冗余提高逻辑复用性":["44.40"],"缺点":["44.40"],"命名容易冲突":["44.40"],"数组新增修改":["44.41"],"movie":["44.43"],"mp4":["44.43"],"模板用于渲染实际内容":["44.44"],"然后在合适的时机在nexttick中调用这些watcher的更新函数进行dom更新":["44.46"],"所以在data刚被修改的时候":["44.46"],"我们是获取不到更新后的dom的":["44.46"],"从而找到差异的部分":["44.48"],"最后渲染到真实的dom节点上面":["44.48"],"其实":["44.49"],"完成diff过程":["44.50"],"当所有子节点都比较完成后":["44.50"],"diff算法就完成了":["44.50"],"js会根据diff算法生成一系列需要进行的dom操作":["44.50"],"如添加":["44.50"],"删除":["44.50"],"showdatils":["44.52"],"更新后执行相关操作":["44.53"],"提供的方法":["44.53"],"如果在列表中添加一个数据后面的index就要重新排列":["44.54"],"所以说能加key就加key":["44.54"],"拿到数据后再default":["44.55"],"显示出来":["44.55"],"子组件的内容":["44.57"],"model只是v":["44.59"],"bind":["44.59"],"因此":["44.60"],"单向数据流也可有双向绑定":["44.60"],"避免了重复加载组件":["44.62"],"开启gzip压缩":["44.62"],"外会放一些项目配置":["44.63"],"依赖":["44.63"],"属性设置预处理器":["44.64"],"两者直接联系":["45.2"],"被观察这改变时直接向所有观察者发送消息":["45.2"],"而两个角色之间还有一个":["45.3"],"依赖收集和管理":["45.3"],"的角色":["45.3"],"提供一些观察者的操作方法":["45.3"],"sub":["45.4"],"只有此时的依赖目标":["45.4"],"实例":["45.4"],"存在时才收集依赖":["45.4"],"发送更新":["45.4"],"遍历依赖数组分别执行每个观察者定义好的":["45.4"],"对象主要功能是做依赖收集":["45.5"],"维护多个":["45.5"],"当更新时候循环调用每个":["45.5"],"notify":["45.8","45.15"],"这里第二次调用":["45.9"],"设置的新值也要被监听":["45.9"],"因为数据变化触发setter方法":["45.11"],"发布依赖":["45.11"],"通知watcher":["45.11"],"watcher收到后执行回调":["45.11"],"dep类收集的依赖是watcher":["45.12"],"watcher的依赖是data数据":["45.12"],"对存储的数据进行更新":["45.13"],"segments":["45.13"],"split":["45.13"],"foreach":["45.14","45.29"],"数据被改变了":["45.15"],"我要把新的值渲染到页面上去":["45.15"],"watcher设置在全局中读取数据":["45.15"],"因为读取了数据":["45.15"],"新增的一个构造函数":["45.16"],"用来创建一个":["45.16"],"目标对象的代理对象":["45.16"],"但是":["45.17","71.15"],"只有通过":["45.17"],"proxyobj":["45.17"],"进行操作的时候才能通过定义的操作拦截方法进行处理":["45.17"],"直接使用原对象则无法触发拦截器":["45.17"],"这也是":["45.17"],"vue":["45.17","55.1"],"中要求的":["45.17"],"reactive":["45.17"],"trigger":["45.18"],"进行依赖更新":["45.18"],"通过对象":["45.18"],"与属性":["45.18"],"reactiveeffect":["45.20","45.21"],"在派发更新时就能准确的找到这些被收集起来的副作用函数":["45.23"],"当数据发生更新时再次执行它":["45.23"],"与传统观察者模式不同":["45.24"],"当数据更新时触发":["45.24"],"等一系列":["45.24"],"接受一个对象":["45.25"],"不论是响应式还是普通的":["45.25"],"或是一个":["45.25"],"返回一个原值的只读代理":["45.25"],"deleteproperty":["45.26"],"操作会直接拦截报错":["45.26"],"提示禁止更新":["45.26"],"至于":["45.26"],"设值时自动通知更新":["45.32"],"所以实际是是设置receiver的key的值为value":["45.33"],"但这可不是直接":["45.33"],"proxy的set对应reflect":["45.34"],"还允许开发者自定义指令":["46.0"],"面试经常会问什么是自定义指令":["46.0"],"input":["46.2"],"click":["46.3"],"changecolor":["46.3"],"hello":["46.3"],"下":["46.4"],"mount":["46.6"],"复制成功":["47.0","63.0"],"removechild":["47.0","63.0"],"updated":["47.0","63.0"],"option":["50.2"],"用于":["50.3"],"获取当前已选中的行数据":["50.3"],"当前列表":["50.3"],"如果":["50.3"],"created":["50.4"],"以提供快速":["51.0"],"流畅的用户体验":["51.0"],"持续维护和更新":["51.0"],"持续集成和测试":["51.1"],"创建一个新的提交":["51.2"],"反做目标版本":["51.2"],"vue2中是通过object":["51.3"],"defineproperty对数据劫持实现的":["51.3"],"vue3中则是使用proxy对数据代理实现的":["51.3"],"生命周期区别":["51.3"],"利用了现代浏览器的缓存机制":["51.5"],"将构建的结果缓存到本地":["51.5"],"避免了重复构建相同的模块":["51.5"],"cancel":["51.6"],"方法来中止请求":["51.6"],"返回的新函数接收一个参数":["51.7"],"这个参数":["51.7"],"将会在组合后的函数链中依次传递给每个函数":["51.7"],"方法遍历":["51.7"],"数组中的每个函数":["51.7"],"从右到左依次执行每个函数":["51.7"],"并将结果传递给下一个函数":["51.7"],"reduceright":["51.7"],"addone":["51.7"],"beforedestroy":["52.0"],"onbeforeunmount":["52.0"],"而在mounted中html渲染出来了可以直接操作dom":["52.1"],"如果data是一个对象那么所有的组件都会共享这个data对象":["52.2"],"当需要对特定的请求进行拦截时":["52.3"],"可以通过":["52.3"],"creat":["52.3"],"mitt":["52.4"],"它包含了父组件在使用子组件时传递给子组件的所有非":["52.4"],"是一个用于修改状态的特殊方法":["52.6"],"它允许你以更简洁的方式更新状态":["52.6"],"而不需要显式地编写一个":["52.6"],"而无需编写计算逻辑":["52.7"],"堆中数据的存储位置并":["53.2"],"不是连续的":["53.2"],"而是分散的":["53.2"],"然后再继续执行下一个宏任务":["53.4"],"如此循环就是事件循环":["53.4"],"数据报":["53.5"],"不保证数据顺序和完整性":["53.5"],"是指拦截和记录通过网络传输的数据包的过程":["53.7"],"网络抓包工具可以截获在网络上发送和接收的数据":["53.7"],"dom型":["53.9"],"修改web页面的dom触发攻击":["53.9"],"写出man":["53.12"],"获取文档的根元素":["53.13"],"rootelement":["53.13"],"documentelement":["53.13"],"可以无损地缩放":["53.16"],"通过css和javascript进行样式和交互控制":["53.16"],"获取canvas内容的base64图片数据":["53.17"],"etag是服务器为资源生成的唯一标识符":["53.19"],"浏览器在后续请求中通过":["53.19"],"从而提高系统的整体性能和资源利用率":["53.20"],"只能存入字符串":["53.22"],"无法直接存对象":["53.22"],"从而提高了页面加载和响应速度":["53.23"],"提高稳定性":["53.23"],"一个标签页的崩溃不会影响到其他标签页":["53.23"],"那么就缩小当前定时器的间隔时间":["53.25"],"以该组件的key为键":["53.26"],"组件vnode为值":["53.26"],"将其存入this":["53.26"],"渲染页面":["53.34"],"none":["53.35"],"match将etag标识符发送给服务器":["53.35"],"如果没有变":["53.35"],"debugger":["53.37"],"cn":["55.0"],"language":["55.1"],"features":["55.1"],"watch用于监听数据的变化并执行操作":["56.2"],"适用于当需要在数据变化时执行异步或复杂的操作时":["56.2"],"computed用于根据依赖的数据动态计算属性值":["56.2"],"并缓存计算结果":["56.2"],"可以使用watch来监听路由的变化":["56.3"],"当路由发生变化时":["56.3"],"如更新页面内容":["56.3"],"请求新的数据":["56.3"],"记录路由历史等":["56.3"],"items":["56.6"],"定位":["56.10"],"滚动超过阈值后表现为":["56.10"],"对于":["56.10"],"减少数据的混乱和意外的副作用":["56.11"],"提高代码的可维护性和可预测性":["56.11"],"当用户点击按钮":["56.12"],"定时器触发或某个操作完成时":["56.12"],"可以使用异步操作来响应这些事件并执行相应的操作":["56.12"],"通过promise":["56.13"],"all方法":["56.13"],"可以等待多个promise同时完成":["56.13"],"事件循环":["56.14"],"负责协调同步任务和异步任务和任务队列之间的关系的机制":["56.14"],"不断地从任务队列中取出任务":["56.14"],"按照一定顺序执行":["56.14"],"以this作为fn函数执行时的上下文":["59.1"],"以args数组中的元素作为fn函数执行时的参数列表":["59.1"],"arguments":["59.2"],"alice":["59.4"],"coding":["59.4"],"字符串中的日期对象将被转换为字符串形式":["59.5"],"而不是原始的":["59.5"],"是指第一组":["59.6"],"并将其作为捕获组":["59.6"],"输入正确数字":["60.0"],"settimeout":["60.0"],"第一个拒绝的":["61.1"],"proxy":["62.0"],"initvalue":["62.0"],"john":["65.4"],"temp":["66.2"],"prev":["67.1"],"拼接在后":["67.2"],"正序":["67.2"],"add":["67.5","67.6"],"newsize":["69.2"],"prime":["69.4"],"getprime":["69.4"],"resize":["69.4"],"tuple":["69.7"],"empty":["70.0"],"左":["71.1"],"右子树本身也都是二叉搜索树":["71.1"],"这也是二叉搜索树中":["71.2"],"搜索的来源":["71.2"],"返回树中最大的值":["71.3"],"remove":["71.3"],"left":["71.4"],"向右查找":["71.5"],"right":["71.5","71.7","71.8","71.10"],"遍历过程为":["71.7","71.8","71.9"],"访问根结点":["71.7"],"中序遍历其左子树":["71.8"],"处理当前节点":["71.9"],"后序遍历其左子树":["71.9"],"必然需要将parent的left或者right指向它的某一个子节点":["71.12"],"所以需要保存起来current的parent":["71.12"],"树中的节点关系不能向上的":["71.12"],"和链表非常相似":["71.12"],"boolean类型":["71.12"],"它用户记录我们是在current是在父节点的左侧还是右侧":["71.12"],"以便到时候设置parent的left或者right":["71.12"],"然后开始查找对应的key":["71.12"],"还是之前的思路":["71.12"],"isleftchild":["71.13"],"parent":["71.13"],"将删除节点的左子树赋值给successor":["71.15","71.16"],"warning":["71.15"],"警告":["71.15"],"对于删除15我们还缺少什么呢":["71.15"],"已经完成":["71.15"],"11的left指向了18":["71.15"],"18的right指向了13":["71.15"],"没有完成":["71.15"],"19怎么办":["71.15"],"寻找后继":["71.16"],"delnode要删除的节点":["71.16"],"successor后继节点":["71.16"],"successorparent后继节点的父节点":["71.16"],"delnode":["71.16"],"successorparent":["71.16"],"while":["72.2"],"removedata2":["72.9","72.11","72.12"],"position":["72.9","85.2"],"indexof":["72.9","74.2"],"head":["72.10"],"isempty":["72.11","72.12"],"clear":["72.11","72.12"],"link":["72.11","72.12"],"普通js构造函数继承":["73.1"],"pq":["73.1","73.2"],"names":["74.2"],"result":["75.11","77.1"],"flat":["75.13"],"infinity":["75.13"],"o":["75.15"],"result30":["75.20"],"concat":["75.26"],"与3差值大小进行排序":["75.29"],"result35":["75.31"],"arr3":["76.7"],"只需要引用下面这行代码":["78.2","82.2"],"你就可以看到流光按钮啦":["78.2"],"flowing":["78.2"],"流光按钮":["78.3"],"midium":["79.1"],"small":["79.1"],"mini":["79.1"],"添加icon":["79.1"],"icon":["79.1"],"shuaxin":["79.1","82.1"],"l":["79.2"],"plain":["79.2"],"按钮":["79.3"],"info":["79.8"],"pinglun":["79.8"],"sousuo":["82.1"],"xiaoxi":["82.1"],"zhihui":["82.1"],"gengduo":["82.1"],"fanhui":["82.1"],"选择你想要的图标":["82.2"],"name":["82.2"],"你就可以看到图标啦":["82.2"],"badge":["82.4"],"说明":["82.5"],"部分图标不支持添加颜色":["82.5"],"给td设置vertical":["85.2"],"align":["85.2"],"middle":["85.2"],"td元素里面":["85.2"],"除float":["85.2"],"absolute":["85.2"],"所有的块级":["85.2"],"非块级元素都会相对于td垂直居中":["85.2"],"给td设置text":["85.2"],"undefined首字母大写":["85.3"],"而不是拒绝处理该请求":["85.6"],"其他的不会":["85.7"],"可以指定一些特定形状":["85.8"],"只会执行第一个catch":["85.9"],"对象的键名可以是字符串和symbol值":["85.10"],"所以当键名为除了字符串和symbol值以外的其他类型值时":["85.10"],"都是需要转换为字符串的":["85.10"],"所以和情况一一样重复赋值":["85.11"],"call":["85.12"],"解决设置max":["85.14"],"higeht":["85.14"],"挂载到对象自身里":["86.2"],"递归的时候没有return":["88.1"],"会一层一层的向外传递结果":["88.1"],"添加return要确保在递归调用":["88.1"],"庄子":["90.0"],"逍遥游":["90.0"],"错题集":["91.0"],"长点心":["91.0"]},{"0":["16.46","20.18","44.51","45.4","72.1","75.24"],"1":["20.13","42.3","45.8","69.3","69.7"],"2":["1.17","6.3","9.2","26.4","42.3","42.27","72.11"],"3":["16.47","19.11","20.22","24.2","42.3","45.9","72.11","72.12"],"4":["10.1","11.26","16.9","21.1","34.4","34.14","72.11","72.12","74.2"],"5":["0.6","2.7","10.1","16.27","23.2","35.2","35.4","44.41","72.11","72.12","75.6"],"6":["7.5","16.24","16.43","44.21","51.3"],"7":["2.10","3.15","5.8","7.5","9.25","10.2","16.35","20.31","26.1","60.0"],"8":["3.15","5.8","16.32","60.0"],"9":["3.15","19.76"],"10":["11.26","16.11","19.4","42.32","70.1","73.1","73.2","77.0"],"11":["75.7"],"12":["8.2"],"13":["8.2","24.3"],"16":["51.7","75.17"],"18":["42.1","75.17"],"20":["16.32","75.17"],"22":["11.23"],"25":["16.28","42.20"],"60":["73.1"],"70":["73.1","73.2"],"100":["42.19","60.0"],"123":["19.4","37.12","44.51"],"222":["72.11","72.12"],"502":["9.23"],"503":["9.23"],"504":["9.23"],"505":["9.23"],"2012":["14.12"],"9997":["16.23"],"9998":["16.23","16.25","16.30"],"9999":["16.23","16.25","16.30"],"10000":["16.30","16.33"],"authorization":["0.2"],"bearer":["0.2"],"token":["0.2"],"result":["0.2","16.46","62.0"],"而且上传数据都是重要数据":["0.4"],"所以不论在安全性还是数据量级":["0.4"],"post是最好的选择":["0.4"],"ip地址和网址不同":["0.5"],"基于消息":["0.6"],"通信是基于消息的":["0.6"],"而不是基于请求和响应的":["0.6"],"客户端和服务器之间可以发送和接收任意类型的消息":["0.6"],"如文本":["0.6"],"二进制数据等":["0.6"],"高效":["0.6"],"websocket协议使用":["0.6"],"单个tcp连接":["0.6"],"可以减少网络延迟和带宽占用":["0.6"],"从而提高通信的效率":["0.6"],"跨域支持":["0.6"],"与ajax请求不同":["0.6"],"websocket通信":["0.6"],"可以跨域":["0.6"],"进行":["0.6"],"不受同源策略的限制":["0.6"],"安全性":["0.6"],"websocket支持使用":["0.6"],"ssl":["0.6","9.16"],"tls加密":["0.6"],"连接":["0.6"],"从而保证通信的安全性":["0.6"],"重新发送原始请求":["0.8"],"catch":["0.8","61.0"],"处理刷新token失败的情况":["0.8"],"例如重定向到登录页":["0.8"],"console":["0.8","20.13","22.1","51.7","59.4","60.0","72.11","72.12","73.1","73.2","75.12","75.13","75.29"],"failed":["0.8"],"重定向到登录页或执行其他操作":["0.8"],"处理其他错误响应":["0.8"],"后端":["0.9"],"返回来的状态码判定执行不同业务":["0.9"],"transform":["1.1"],"translate":["1.1"],"flexbox":["1.2"],"flex":["1.2"],"auto":["1.3","2.10"],"scroll":["1.3"],"类似":["1.5"],"但实际浏览器只是跳过了内容的渲染":["1.5"],"还保留着内容的渲染状态":["1.5"],"性能上有优势":["1.5"],"不过元素实际不在视窗内所以无法交互":["1.6"],"此方法对行内元素无效":["1.6"],"也算是一种隐藏方式":["1.7"],"size按自身来计算":["1.8"],"的元素是相对于":["1.9"],"viewport":["1.9"],"可视窗口":["1.9"],"如果用户在移动设备上浏览网页":["1.10"],"浏览器会根据屏幕宽度自动调整基准字体大小":["1.10"],"使得网页元素的尺寸相对于屏幕宽度保持一定比例":["1.10"],"content属性定义了多根轴线的对齐方式":["1.11"],"如果项目只有一根轴线":["1.11"],"该属性不起作用":["1.11"],"指定了对应元素在主轴上的大小":["1.12"],"空间大小都一致":["1.13"],"才均分":["1.14"],"表现形式为最小内容宽度":["1.15"],"内容本身的宽度是多少就是多少":["1.16"],"50px":["1.17","1.25"],"nowrap":["1.18"],"重绘过程":["1.19"],"浏览器需要为整个层进行重绘并重新上传到":["1.19"],"造成了极大的性能开销":["1.19"],"元素固定的相对偏移是相对于离它最近的具有滚动框的祖先元素":["1.20"],"如果祖先元素都不可以滚动":["1.20"],"那么是相对于viewport来计算元素的偏移量":["1.20"],"evenly":["1.21"],"边缘空间和两个item之间的空间一样大":["1.21"],"或当动画有一个延迟未开始播放时":["1.22"],"要应用到元素的样式":["1.22"],"play":["1.22"],"state":["1.22"],"指定动画是否正在运行或已暂停":["1.22"],"inline":["1.24","56.10"],"indent":["1.25"],"首行缩进":["1.25"],"属性":["1.26","2.1","6.17","19.69","52.4"],"class":["1.30"],"选择url片段标识符":["1.30"],"url":["1.30","37.10","37.18"],"fragment":["1.30"],"identifier":["1.30"],"与元素的id匹配的元素":["1.30"],"选择元素的第一个字母":["1.31"],"visibility":["1.32"],"光标属性":["1.32"],"cursor":["1.32"],"箭头可以变成需要的形状":["1.32"],"然后根据新的条件重新应用相应的样式规则":["1.35"],"伪元素清浮动":["2.2"],"现在主流方法":["2.2"],"推荐使用":["2.2"],"的大小的总和":["2.3"],"默认使用标准盒模型":["2.3"],"或者滚动":["2.6"],"照片使用":["2.7"],"jpeg":["2.7"],"transition":["2.8"],"keyframes":["2.8"],"animation":["2.8"],"多列布局":["2.8"],"媒体查询":["2.8"],"改变背景颜色为红色":["2.9"],"网格布局":["2.10"],"grid":["2.10"],"利用grid布局的方式":["2.10"],"中间一栏设置为auto":["2.10"],"这种实现方式代码也非常简洁":["2.10"],"核心代码":["2.10"],"左右两栏固定宽度":["2.10"],"中间自适应宽度":["2.10"],"template":["2.10"],"columns":["2.10"],"var没有块级作用域":["3.6"],"let和const有块级作用域":["3.6"],"函数属于的是函数作用域而不是块级作用域":["3.7"],"对象的话":["3.7"],"又不能在里面let":["3.7"],"扩展运算符":["3.9"],"接受的时候只接一个":["3.12"],"函数可以被暂停和恢复":["3.14"],"因此可以用于实现复杂的状态机逻辑":["3.14"],"generator":["3.15"],"proxy":["3.15","45.32"],"模块化":["3.15"],"docorator修饰对象":["3.15"],"在不改变原有代码情况下":["3.15"],"对原来功能进行扩展":["3.15"],"只能对类进行装饰":["3.15"],"不能对函数进行装饰":["3.15"],"foo":["4.0"],"undefined":["4.0"],"它会将web页面和javascript脚本连接起来":["5.1"],"压入栈底":["5.2"],"然后经过分词器解析出来的第一个":["5.2"],"会被压入到栈中":["5.2"],"并创建一个":["5.2"],"添加到":["5.2"],"上":["5.2"],"解析到相关文件之后":["5.4"],"预解析线程会提前下载这些文件":["5.4"],"load":["5.7"],"绘制网页repaint":["5.8"],"重绘":["5.8"],"根据浏览器提供各层的信息合成图层":["5.8"],"显示到屏幕上":["5.8","6.9"],"节点就要从头到尾执行10遍":["5.12"],"再将最终的":["5.13"],"对象映射成真实的":["5.13"],"交由浏览器去绘制":["5.13"],"中":["5.16","20.14","34.4"],"请求对象":["5.17"],"用于发送异步":["5.17"],"http":["5.17","9.23"],"请求":["5.17","9.17"],"open":["5.18"],"打开一个新的空白文档":["5.18"],"close":["5.18","5.24"],"关闭当前文档":["5.18"],"parentelement":["5.21"],"获取元素的父元素":["5.21"],"children":["5.21"],"返回一个htmlcollection对象":["5.21"],"包含了元素的子元素":["5.21"],"previouselementsibling":["5.21"],"获取元素的前一个兄弟元素":["5.21"],"nextelementsibling":["5.21"],"获取元素的后一个兄弟元素":["5.21"],"removechild":["5.22"],"并加载指定的":["5.24"],"关闭当前窗口或标签页":["5.24"],"提供了对会话存储的访问":["5.25"],"可以在会话期间存储和读取数据":["5.25"],"指示事件的默认行为是否被取消的布尔值":["5.27"],"timestamp":["5.27"],"事件触发的时间戳":["5.27"],"冒泡和取消属性":["5.28"],"所以文档声明是必须的":["6.1"],"强调":["6.2"],"表示强调的文本":["6.2"],"可以通过display属性对行内元素和块级元素进行切换":["6.3"],"主要看第":["6.3"],"4三个值":["6.3"],"而下载的原理在于a标签所对应的资源浏览器无法解析":["6.5"],"于是浏览器会选择将其下载下来":["6.5"],"endif":["6.7"],"对可选用性产生负面影响的元素":["6.8"],"frame":["6.8"],"frameset":["6.8"],"noframes":["6.8"],"不会忽略":["6.10"],"开发尽量减少次数":["6.11"],"target":["6.13"],"如果不是合成层":["6.14"],"则其依然会触发":["6.14"],"隐式合成":["6.15"],"一个或多个非合成元素应出现在堆叠顺序上的合成元素之上":["6.15"],"会被提升为合成层":["6.15"],"元素的渲染等":["6.16"],"清晰地定义其内容":["6.18"],"移动设备等":["6.19"],"以有意义的方式来渲染网页":["6.19"],"iframe元素会加载嵌入的文档":["6.20"],"从而对网页的性能和加载速度产生一定的影响":["6.20"],"需要注意优化":["6.20"],"以最低的成本来提高你网站的排名":["7.1"],"查看是否有非法信息":["7.5"],"服务器速度":["7.5"],"推广":["7.5"],"图片添加有意义的alt属性":["8.2"],"在form表单中增加label":["8.2"],"以增加用户友好度":["8.2"],"代码维护简单":["8.3"],"便于改版":["8.3"],"通过session会话保存":["9.2"],"所以被称为tcp":["9.3"],"ip协议":["9.3"],"这可能导致关闭连接的操作阻塞":["9.4"],"比":["9.5"],"协议安全":["9.5"],"服务器和客户端都有了":["9.6"],"相同的对称密钥":["9.6"],"它们可以使用对称加密算法来进行通信":["9.6"],"保障数据在传输过程中的保密性和完整性":["9.6"],"push":["9.9","45.14"],"等功能":["9.9"],"以减少数据传输量和提高效率":["9.9"],"压缩后的头部信息会包含索引和增量更新动态表的信息":["9.11"],"以及实际的头部字段和值":["9.11"],"必须用代理的方式回源站取":["9.13","53.21"],"回源次数与所有访问次数之比":["9.13","53.21"],"可以分为一级缓存和二级缓存":["9.13","53.21"],"中预留给能够将连接改为通道方式的代理服务器":["9.16"],"通常用于":["9.16"],"加密服务器的链接":["9.16"],"经由非加密的":["9.16"],"代理服务器":["9.16"],"预检请求完成后":["9.17"],"浏览器才会发送实际的":["9.17"],"更稳定也更可靠":["9.18"],"since配合":["9.19"],"用于缓存控制":["9.19"],"cache":["9.19"],"control":["9.19"],"取值一般为no":["9.19"],"max":["9.19"],"age":["9.19"],"xx":["9.19"],"xx为整数":["9.19"],"表示资源缓存有效期":["9.19"],"秒":["9.19"],"属性记录的就是该请求体的长度":["9.20"],"服务器端错误":["9.22"],"服务器未能实现合法的请求":["9.22"],"服务器不具备完成请求的功能":["9.23"],"例如":["9.23","43.14","44.22"],"服务器无法识别请求方法时可能会返回此代码":["9.23"],"错误网关":["9.23"],"服务器作为网关或代理":["9.23"],"从上游服务器收到无效响应":["9.23"],"服务不可用":["9.23"],"服务器目前无法使用":["9.23"],"由于超载或停机维护":["9.23"],"这只是暂时状态":["9.23"],"网关超时":["9.23"],"但是没有及时从上游服务器收到请求":["9.23"],"版本不受支持":["9.23"],"服务器不支持请求中所用的":["9.23"],"协议版本":["9.23"],"渲染页面":["9.25"],"检查缓存":["9.26"],"缓存":["9.27"],"表示层":["9.28"],"presentation":["9.28"],"发送能力正常":["9.33"],"服务器自己的发送":["9.33"],"接收能力也正常":["9.33"],"报文之后":["9.34"],"就处于关闭连接了":["9.34"],"处于closed状态":["9.34"],"地址的网络部分和主机部分":["9.35"],"不可靠的数据传输":["9.36"],"数据传输速度快":["9.36"],"不保证数据的完整性和顺序性":["9.36"],"选择使用":["9.36"],"还是":["9.36","28.2"],"取决于具体的应用需求":["9.36"],"来维护状态":["9.37"],"实现方式包括":["9.38"],"json":["9.38"],"web":["9.38"],"jwt":["9.38"],"的优势在于它能够避免服务器上的session存储":["9.38"],"因为":["9.38","34.11","37.3"],"token本身就包含了认证信息":["9.38"],"无需服务器去维护状态":["9.38"],"httponly":["10.1","30.10"],"和":["10.1","41.0","44.22"],"secure":["10.1"],"标记":["10.1"],"防止":["10.1"],"cookie":["10.1","25.1"],"被窃取":["10.1"],"对于前端框架和第三方组件":["10.1"],"要及时更新到最新版本":["10.1"],"避免已知的安全漏洞":["10.1"],"社交工程和恶意行为":["10.2"],"web安全还需要考虑社交工程和恶意行为":["10.2"],"如钓鱼":["10.2"],"恶意软件等":["10.2"],"用户教育和意识提高可以帮助减少这些攻击的风险":["10.2"],"注入到网页中":["10.3"],"使其在用户浏览器中执行":["10.3"],"攻击成功":["10.4"],"目标网站在没有足够的验证措施的情况下":["10.4"],"执行了攻击者所发送的恶意请求":["10.4"],"可能导致不可预料的危害":["10.4"],"验证请求方法":["10.5"],"添加验证码":["10.5"],"不信任外部数据":["10.6"],"及时更新软件和框架等":["10.6"],"以减少潜在的安全漏洞":["10.6"],"java工具":["11.1"],"编译器":["11.1"],"调试器":["11.1"],"运行期间判断所引用对象的实际类型":["11.2"],"根据其实际类型调用相应的方法":["11.2"],"丰富了基本类型的操作":["11.5"],"false":["11.6","17.13","19.35","19.52","22.7","42.23","44.52"],"怎么解释呢":["11.7"],"其实不是的":["11.7"],"我们每次调用replace等方法":["11.7"],"其实会在堆内存中":["11.7"],"创建了一个新的对象":["11.7"],"然后其value数组引用指向不同的对象":["11.7"],"synchronized":["11.8"],"进行同步":["11.8"],"堆中创建一个字符串对象":["11.9"],"并返回其引用":["11.10"],"当比较对象的数量很大的时候能提升效率":["11.11"],"静态方法只能访问静态成员":["11.12"],"直接访问":["11.12"],"static不允许使用this":["11.12"],"父类中私有方法":["11.14"],"可以继承":["11.14"],"但不能被重写":["11.14"],"子类重写父类方法时":["11.14"],"权限一定要大于父类":["11.14"],"只能单继承不支持多继承":["11.14"],"支持多层继承":["11.14"],"被private修饰的方法子类不能重写":["11.17"],"被static修饰的方法可以用类名调用":["11.17"],"类名调用抽象方法没有意义":["11.17"],"final":["11.18"],"三个关键字":["11.18"],"接口的成员方法只能是抽象方法":["11.18"],"不写默认会加上":["11.18"],"system":["11.19","16.13"],"out":["11.19","16.13"],"println":["11.19","16.13"],"成员变量":["11.21"],"编译看左边":["11.21"],"父类":["11.21"],"运行看左边":["11.21"],"成员方法":["11.21"],"如果没有编译出错":["11.21"],"如果有继续运行":["11.21"],"但是运行看右边":["11.21"],"子类":["11.21"],"强转":["11.22"],"局部内部类":["11.24"],"放在方法代码块":["11.24"],"构造器等执行体中":["11.24"],"不重要":["11.24"],"匿名内部类":["11.24"],"定义在方法内部":["11.24"],"可以":["11.25"],"个数字":["11.26"],"表示匹配任何长度是":["11.26"],"的字符串":["11.26"],"y":["11.26"],"且":["11.26"],"表示匹配至少":["11.26"],"个最多":["11.26"],"之后的代码不再执行":["11.28"],"site":["12.1"],"delete":["13.3","14.4"],"deletebyids":["13.3"],"in":["13.3"],"foreach":["13.3","22.8","45.22"],"ids":["13.3"],"名字":["14.0"],"默认约束":["14.2"],"default":["14.2"],"外键约束":["14.2"],"foreign":["14.2"],"变长字符串":["14.3"],"删":["14.4"],"from":["14.4","56.0"],"分页参数":["14.5"],"having":["14.6"],"分组之后进行条件的过滤要写在having之后":["14.6"],"entrydate相同":["14.9"],"根据update":["14.9"],"time降序":["14.9"],"社会人":["14.10"],"end":["14.10","34.14"],"这样会自动关联":["14.11"],"01":["14.12"],"表子查询":["14.12"],"商务套餐a":["14.13"],"查询低于平均价格的菜品name":["14.13"],"avg":["14.13"],"持久性":["14.14"],"事务一旦提交或回滚":["14.14"],"它对数据库的数据改变就是永久的":["14.14"],"是jdk里的":["15.2"],"是spring框架的":["15.2"],"target通知所应用的对象":["15.3"],"方法发生异常后执行":["15.4"],"判断当前环境中是否有对应的bean":["15.7"],"conditionalonproperty":["15.7"],"判断配置文件中有对应属性和值":["15.7"],"long":["16.1"],"object":["16.1","19.75"],"一个完全运行完成的线程的状态":["16.1"],"也称之为终止状态":["16.1"],"结束状态":["16.1"],"各个状态的转换":["16.1"],"如下图所示":["16.1"],"1571652681276":["16.1"],"timed":["16.3"],"通过上面3个案例的代码演示":["16.5"],"我们可以证明开始章节说所述的线程状态以及线程状态转换都是正确的":["16.5"],"线程池":["16.5"],"线程并不会死亡":["16.6"],"而是再次返回到线程池中称为空闲状态":["16.6"],"等待下一次任务的执行":["16.6"],"而是循环使用这些已经存在的线程":["16.8"],"1571655104091":["16.8"],"通过这5个线程处理了10个任务":["16.9"],"executorsdemo06":["16.11"],"10s以后开始执行该任务":["16.11"],"执行了该任务":["16.11"],"测试类2":["16.11"],"演示周期性执行":["16.11"],"executorsdemo07":["16.11"],"10s以后开始第一次执行该任务":["16.11"],"然后每隔1秒执行一次":["16.11"],"以及默认的任务处理策略":["16.13"],"提交任务":["16.13"],"submit":["16.13"],"thread":["16.13"],"currentthread":["16.13","17.13"],"getname":["16.13","17.13"],"执行了任务":["16.13"],"关闭线程池":["16.13"],"shutdown":["16.13"],"可以看做成是核心线程池中的线程":["16.14"],"临时工就是非核心线程池中的线程":["16.14"],"当临时工处于空闲状态":["16.14"],"的时候":["16.14"],"那么如果空闲的时间超过keepalivetime所指定的时间":["16.14"],"那么就会被销毁":["16.14"],"1571735904991":["16.15"],"此时3个任务都以及提交完毕":["16.15"],"断点跳过":["16.15"],"经过20s以后":["16.15"],"再次查看该进程中的线程":["16.15"],"1571736824748":["16.15"],"我们发现非核心线程已经被线程池回收了":["16.15"],"通过控制台的输出":["16.16","16.23","16.28"],"我们可以看到次策略没有通过线程池中的线程执行任务":["16.16"],"而是直接调用任务的run":["16.16"],"volatile关键字":["16.16"],"线程休眠1s":["16.17"],"休眠一秒以后那么flag的值应该为":["16.17"],"此时我们在主线程中不停的获取flag的值":["16.17"],"发现前面释放false":["16.17"],"后面是true":["16.17"],"信息":["16.17"],"那么这是为什么呢":["16.17"],"要想知道原因":["16.17"],"那么我们就需要学习一下jmm":["16.17"],"不同线程之间也不能直接访问对方工作内存中的变量":["16.18"],"线程间变量的值的传递需要通过主":["16.18"],"内存完成":["16.18"],"1571743818653":["16.18"],"flag":["16.19"],"此时我们可以看到if语句已经执行了":["16.19"],"当然我们在真实开发中可能不能使用这种方式来处理这个问题":["16.19"],"那么这个问题应该怎么处理呢":["16.19"],"我们就需要学习下一小节的内容":["16.19"],"d":["16.21","74.2"],"执行代码":["16.21"],"e":["16.21","19.73","42.29"],"将修改后的副本的值刷新回主内存中":["16.21"],"f":["16.21","17.17","20.26","41.7"],"线程释放锁":["16.21"],"你喂你女朋友吃冰淇淋":["16.22"],"如果没有女朋友":["16.22"],"你就假想一下":["16.22"],"实在不行":["16.22"],"你就喂你旁边的哥们吃一口冰淇淋":["16.22"],"这就是一个不可分割的整体":["16.22"],"一个是你喂":["16.22"],"一个是她吃":["16.22"],"这就是一个整体":["16.22"],"如果没有她吃":["16.22"],"那么你喂就没有意义":["16.22"],"如果没有你喂":["16.22"],"她吃就没有意义":["16.22"],"比如":["16.22"],"从张三的账户给李四的账户转1000元":["16.22"],"这个动作将包含两个基本的操作":["16.22"],"从张三的账户扣除1000元":["16.22"],"给李四的账户增加1000元":["16.22"],"这两个操作必须符合原子性的要求":["16.22"],"要么都成功要么":["16.22"],"都失败":["16.22"],"我们可以看到最终count的结果可能并不是10000":["16.23"],"接下来我们就来分析一下问题产生的原因":["16.23"],"线程b将101写入到主内存":["16.24"],"线程a将101写入到主内存":["16.24"],"虽然计算了2次":["16.24"],"但是只对a进行了1次修改":["16.24"],"通过控制台结果的输出":["16.25"],"我们可以看到程序还是会出现问题":["16.25"],"因此也就证明volatile关键字是不保证原子性的":["16.25"],"timeunit":["16.27"],"seconds":["16.27"],"sleep":["16.27"],"观察控制台输出":["16.27"],"volatileusethread线程执行5秒以后程序结束":["16.27"],"start":["16.28","16.45","16.49","17.17"],"gatherthread":["16.28"],"setname":["16.28","17.17"],"温度采集线程":["16.28"],"控制台输出结果":["16.28","16.43"],"我们可以看到当温度采集线程刚采集到环境温度以后":["16.28"],"那么此时两个温度读取线程就可以立即感知到环境温度的变化":["16.28"],"通过控制台的执行结果":["16.33"],"我们可以看到最终得到的结果就是10000":["16.33"],"因此也就证明atomicinteger所提供的方法是原子性操作方法":["16.33"],"线程1进行swap":["16.35"],"把内存v的值替换为b":["16.35"],"也就是12":["16.35"],"1571818747880":["16.35"],"这好比春节的时候抢火车票":["16.35"],"下手快的会抢先买到票":["16.35"],"而下手慢的可以再次尝试":["16.35"],"直到买到票":["16.35"],"本地方法":["16.36"],"调用cpu指令实现cas":["16.36"],"native":["16.36"],"在jdk的并发包里提供了几个非常有用的并发容器和并发工具类":["16.37"],"供我们在多线程开发中进行使用":["16.37"],"concurrenthashmap中的键就是当前循环变量的x这个数据的字符串表现形式":["16.39"],"因此也就证明concurrenthashmap是线程安全的":["16.39"],"c":["16.41","16.42","17.17","73.1","74.2"],"如果超过阈值":["16.41"],"则进行rehash操作":["16.41"],"maximum":["16.41"],"capacity":["16.41"],"rehash":["16.41"],"setentryat":["16.41"],"finally":["16.41"],"unlock":["16.41"],"注":["16.41"],"源代码进行简单讲解即可":["16.41"],"核心":["16.41"],"进行了两次哈希定位以及加锁过程":["16.41"],"compareandswapobject":["16.42"],"简单总结":["16.42"],"如果当前需要put的key对应的链表在哈希表table中还不存在":["16.42"],"即还没添加过该key的hash值对应的链表":["16.42"],"则调用castabat方法":["16.42"],"基于cas机制来实现添加该链表头结点到哈希表":["16.42"],"table中":["16.42"],"避免该线程在添加该链表头结的时候":["16.42"],"其他线程也在添加的并发问题":["16.42"],"如果cas失败":["16.42"],"则进行自旋":["16.42"],"通过继续第2步的操作":["16.42"],"如果需要添加的链表已经存在哈希表table中":["16.42"],"则通过tabat方法":["16.42"],"基于volatile机制":["16.42"],"获取当前最新的链表头结点f":["16.42"],"由于f指向的是concurrenthashmap的哈希表table的某条":["16.42"],"链表的头结点":["16.42"],"故虽然f是临时变量":["16.42"],"由于是引用共享的该链表头结点":["16.42"],"所以可以使用synchronized关键字来同步多个线程对该链表的访问":["16.42"],"在synchronized":["16.42"],"同步块里面则是与":["16.42"],"hashmap一样遍历该链表":["16.42"],"如果该key对应的链表节点已经存在":["16.42"],"则更新":["16.42"],"否则在链表的末尾新增该key对应的链表节点":["16.42"],"程序结束的输出":["16.43"],"主线程执行了":["16.43"],"程序结束了":["16.43"],"countdownlatchthread02线程先执行完毕":["16.43"],"此时计数器":["16.43"],"countdownlatchthread01线程执行完毕":["16.43"],"当计数器的值为0的时候":["16.43"],"主线程阻塞状态接触":["16.43"],"主线程向下执行":["16.43"],"thread4":["16.45"],"thread5":["16.45"],"nextelement":["16.46"],"获取元素":["16.46"],"int":["16.46"],"输出":["16.46","41.10","51.7"],"测试类代码":["16.46"],"cyclicbarrierthreadusedemo01":["16.46"],"static":["16.46"],"main":["16.46"],"args":["16.46"],"创建任务类的对象":["16.46"],"调用count方法进行数据汇总":["16.46"],"通过控制台输出":["16.47"],"我们可以看到当某一个汽车":["16.47"],"驶出":["16.47"],"十字路口以后":["16.47"],"就会有一个汽车立马驶入":["16.47"],"new":["16.49","45.32"],"杨过":["16.49"],"小龙女":["16.49"],"启动线程":["16.49"],"死锁等问题":["17.9"],"尽量将共享资源设计为不可变":["17.10"],"immutable":["17.10"],"的":["17.10"],"这样就不需要考虑线程安全的问题":["17.10"],"这些方法在执行期间会保持原子性":["17.11"],"线程在执行原子操作时不会被中断":["17.11"],"从而确保了数据的一致性和线程安全性":["17.11"],"正在卖":["17.12","17.13"],"张票":["17.12","17.13"],"else":["17.12"],"break":["17.12"],"吃货":["17.17"],"厨师":["17.17"],"队伍满":["17.18"],"临时线程满时":["17.18"],"会触发任务拒绝策略":["17.18"],"gettotal":["18.4"],"getresult":["18.4"],"从而避免了多线程的安全问题":["19.1"],"array":["19.2","20.30","56.0"],"用于表示不是一个数字":["19.4"],"它不等于任何值":["19.4"],"包括它本身":["19.4"],"在":["19.4"],"之前":["19.4"],"windows":["19.4"],"对象提供了一个全局方法":["19.4"],"用于判断一个数字是不是":["19.4"],"对于字符串的检测结果也是":["19.4"],"但这其实并不严谨":["19.4"],"它对要判断的数据做了一个隐式类型转换":["19.4"],"先转为数字再进行判断":["19.4"],"而nan":["19.4"],"的检测应该仅限于数字类型":["19.4"],"所以":["19.4"],"提供了":["19.4"],"方法":["19.4","34.17","52.6","71.4"],"它能判断一个值是否严格等于nan":["19.4"],"然后再执行下一个宏任务":["19.11"],"而每一个宏任务都有一个自己的微任务队列":["19.12"],"每轮循环都是由一个宏任务":["19.12"],"多个微任务组成":["19.12"],"process":["19.13"],"nexttick等":["19.13"],"在下一轮事件循环中也能得到同步":["19.14"],"小于4ms执行setimmediate的回调":["19.15"],"就像地址一样的两个不同的个体":["19.21"],"异步回调":["19.22"],"保留回调函数中的变量状态等":["19.22"],"闭包里的变量会一直存在于内存中":["19.22"],"不会被回收":["19.22"],"当闭包函数被销毁时才会被回收":["19.22"],"注意内存泄漏":["19.22"],"才定义为内存泄漏":["19.25"],"泄露的本在在于程序是否能控制":["19.25"],"一直到全局作用域":["19.26"],"nan":["19.27"],"call":["19.30","20.30","36.17","53.1"],"arr":["19.30"],"用得到的基本类型值按照前面的规则进行比较":["19.39"],"不推荐":["19.43"],"load触发":["19.50"],"true":["19.51","19.66","19.67","20.12","42.16","69.5","72.4","72.7"],"quchong":["19.54"],"接收上一个return和数组的下一项":["19.58"],"flat":["19.58"],"数组扁平化":["19.58"],"slice":["19.58"],"截取数组":["19.58"],"返回被截取的区间":["19.58"],"取0":["19.59"],"num的随机数":["19.59"],"ss":["19.61"],"sssz":["19.61"],"origin":["19.63"],"获取当前域名":["19.63"],"获取当前浏览器信息":["19.63"],"对象":["19.64","59.5"],"浏览器提供出来给予访问的是bom对象":["19.64"],"从bom对象再访问到dom对象":["19.64"],"从而js可以操作浏览器以及浏览器读取到的文档":["19.64"],"i":["19.71","45.4"],"char":["19.73"],"h":["19.73"],"l":["19.73"],"o":["19.73","20.26"],"float64array":["19.74"],"等":["19.74"],"表示固定类型的数组":["19.74"],"nodelist":["19.74"],"dom":["19.74","34.13"],"操作返回的节点列表":["19.74"],"instanceof":["19.75"],"pagey":["19.76"],"鼠标指针相对于整个文档页面左上角的垂直坐标":["19.76"],"回收阶段":["19.77"],"然后将这个执行上下文压到执行栈中":["19.78"],"目标对象":["20.3"],"接收源对象属性的对象":["20.3"],"也是修改后的返回值":["20.3"],"sources":["20.3"],"源对象":["20.3"],"包含将被合并的属性":["20.3"],"expected":["20.6","20.12","20.31"],"output":["20.6","20.12","20.31"],"返回和传入的参数相同的对象":["20.9"],"clark":["20.13"],"kent":["20.13"],"log":["20.13","22.1","51.7","59.4","60.0","65.4","70.1","72.11","72.12","73.1","73.2","75.1","75.2","75.3","75.10","75.12","75.13","75.20","75.26","75.28","75.29","75.31","77.4"],"的原型链是针对":["20.14"],"进行检查的":["20.14"],"而不是针对":["20.14"],"本身":["20.14"],"undeclaredpropertyvalue":["20.19"],"都是同一个值":["20.21"],"非零且都不是":["20.21"],"argument":["20.26"],"will":["20.26"],"be":["20.26"],"coerced":["20.26"],"catche函数":["21.0"],"是用来处理异常":["21.1"],"reject后的东西":["21.1"],"一定会进入then中的第二个回调":["21.1"],"如果then中没有写第二个回调":["21.1"],"则进入catch":["21.1"],"网络异常":["21.1"],"比如断网":["21.1"],"会直接进入catch而不会进入then的第二个回调":["21.1"],"当我调用reject之后":["21.2"],"在调用resolve是无效的":["21.2"],"因为状态已经发生改变":["21.2"],"并且是不可逆的":["21.2"],"它的返回值是promise":["21.5"],"那它的状态如何决定":["21.5","21.6"],"返回一个普通值":["21.5"],"状态":["21.5"],"fulfilled":["21.5"],"明确返回一个promise":["21.5"],"返回一个thenable对象":["21.5"],"返回值是promise":["21.6"],"如果返回值明确一个promise或者thenable对象":["21.6"],"取决于你调用了resolve还是reject":["21.6"],"promise处理错误的方式有两种":["21.8"],"第一种在then中传递两个回调":["21.8"],"第二个回调是错误回调":["21.8"],"状态改变只有两种结果":["21.8"],"完成或者失败":["21.8"],"遍历字典的所有成员":["22.8"],"return":["22.9","22.10","37.16","38.8","42.30","53.30","59.10","66.5","69.1"],"会被垃圾回收":["22.11"],"不可迭代遍历":["22.11"],"不可获取大小":["22.11"],"对象的属性或方法":["23.1"],"所以可以通过访问":["23.1"],"对象来访问全局变量和全局函数":["23.1"],"它的值指向外层作用域中的":["23.2"],"这是因为箭头函数没有自己的执行上下文":["23.2"],"它的上下文由外层作用域提供":["23.2"],"立即执行函数的this指向全局作用域":["23.2"],"bind":["23.3"],"则是立即执行":["23.4"],"number2":["24.2"],"条件运算符":["24.3"],"赋值运算符":["24.3"],"验证token":["25.1"],"其他域不断重复":["25.1"],"生成token":["25.1"],"写session":["25.1"],"登录":["25.1"],"其他":["26.1"],"entries":["26.1"],"返回一个新的数组迭代器对象类似generator":["26.1"],"reduce":["26.1"],"累加器返回一个新数组":["26.1"],"reduceright":["26.1"],"累加器从右往左返回一个新数组":["26.1"],"reverse":["26.1"],"颠倒数组":["26.1"],"ab":["27.0"],"表示匹配一个或多个ab连续出现的字符串":["27.0"],"这些只是正则表达式的基础":["27.0"],"实际上它们还可以实现更复杂的匹配逻辑":["27.0"],"在编写正则表达式时":["27.0"],"您还可以使用一些特殊字符和标志":["27.0"],"这些字符和标志有特定的含义和用法":["27.0"],"可以帮助您更精确地控制匹配过程":["27.0"],"boxsizing":["28.2"],"是":["28.2"],"borderbox":["28.2"],"contentbox":["28.2"],"如果是borderbox":["28.2"],"高度要加上":["28.2"],"上下boreder的高度":["28.2"],"如果是":["28.2"],"高度要减去":["28.2"],"上下padding的高度":["28.2"],"然后清空虚拟文本域计算单行行高":["28.2"],"设置最小行数的高度和最大行数的高度":["28.2"],"最后把虚拟文本域移除":["28.2"],"提供更丰富":["28.9"],"动态和响应式的用户界面":["28.9"],"这可以改善用户体验并提高用户满意度":["28.9"],"3旨在进一步提升性能":["28.10"],"降低延迟":["28.10"],"并解决某些网络环境下tcp存在的一些问题":["28.10"],"如丢包恢复速度慢":["28.10"],"拥塞控制等":["28.10"],"以破坏通信的安全性":["28.11"],"gmt表示资源文件将在指定日期之后过期":["28.12"],"推荐的做法是结合使用cache":["28.12"],"control和expires字段":["28.12"],"以提供更好的缓存控制和兼容性":["28.12"],"避免动态内容":["28.13"],"尽量避免在页面加载后动态插入或移除内容":["28.13"],"或者在动态内容加载前预留足够的空间":["28.13"],"lighthouse等来分析和监测应用的性能指标":["28.14"],"发现潜在的性能瓶颈并进行优化":["28.14"],"定期优化和更新":["28.14"],"持续监测应用的性能":["28.14"],"定期进行优化和更新":["28.14"],"以适应不断变化的平台和设备环境":["28.14"],"可靠性":["28.16"],"workspaces":["28.17"],"cjs":["29.1"],"这两种模块不兼容":["29.1"],"最底层的模块第一个执行":["29.2"],"json文件中":["29.3"],"指定type字段为module":["29.3"],"模块内部可以使用顶层await命令":["29.4"],"导致无法被同步加载":["29.4"],"js文件的加载取决于package":["29.5"],"json里面type字段的设置":["29.5"],"就向客户端返回请求的数据":["30.8"],"服务端验证token":["30.8"],"表示该cookie只能通过https连接传输":["30.10"],"httponly标志":["30.10"],"表示该cookie只能通过http协议访问":["30.10"],"无法通过javascript脚本访问":["30.10"],"dirname":["32.4"],"dist":["32.4"],"所期望的":["32.5"],"loader要放在style":["32.5"],"loader后面":["32.5"],"browserslist":["32.6"],"defaults":["32.6"],"index":["32.7"],"html":["32.7","43.5"],"双方可以通信":["32.8"],"而不是压缩后的代码":["32.9"],"js变量提升":["33.0"],"this指向":["33.0"],"html语义化":["33.0"],"callapplybind":["33.0"],"箭头函数":["33.0"],"数组去重":["33.0"],"constructor中":["34.2"],"bind事件与定义阶段使用箭头函数绑定这两种形式只会生成一个方法实例":["34.2"],"lazy":["34.2"],"服务端渲染":["34.2"],"来处理组件的副作用操作":["34.4"],"性能":["34.4"],"由于":["34.4","38.7"],"函数组件没有实例化的过程":["34.4"],"相比类组件来说":["34.4"],"函数组件的创建和渲染效率更高":["34.4"],"版本引入的":["34.4"],"memo":["34.4"],"和其他优化方法来提升性能":["34.4"],"组件更新前调用的钩子":["34.5"],"组件更新完成后调用的钩子":["34.5"],"卸载阶段唯一的生命周期钩子":["34.5"],"通常在这里处理一些善后工作":["34.5"],"例如关闭定时器":["34.5"],"取消监听等等":["34.5"],"卸载阶段":["34.6"],"unmounting":["34.6"],"componentwillunmount":["34.6","34.26"],"在组件卸载前调用":["34.6"],"可以进行清理工作":["34.6"],"如取消订阅":["34.6"],"清除计时器等":["34.6"],"的一个时机":["34.7"],"无状态组件主要用于表示简单的":["34.9"],"ui":["34.9"],"展示组件":["34.9"],"通常仅负责展示传入的数据":["34.9"],"所有的子组件得跟着一起渲染":["34.10","40.1"],"它不能像vue一样":["34.10","40.1"],"精确到当前组件的粒度":["34.10","40.1"],"每个节点都保持着对其父节点的索引":["34.11"],"树和fiber虽然看起来很像":["34.11"],"但本质上来说":["34.11"],"一个是树":["34.11"],"一个是链表":["34.11"],"树的根":["34.13"],"容器中":["34.13"],"处理合成事件内的回调事件":["34.14"],"事件触发完成":["34.14"],"就从这个数组中弹出":["34.15"],"避免频繁地去创建和销毁":["34.15"],"垃圾回收":["34.15"],"方便事件统一管理和事务机制":["34.15"],"这个对象就是上面注册的所有插件列表":["34.16"],"persist":["34.17"],"上挂载的事件":["34.19"],"取消事件池复用":["34.20"],"通过使用":["34.21"],"我们可以在不修改mycomponent的情况下":["34.21"],"为它添加额外的功能":["34.21"],"比如日志记录":["34.21"],"这样":["34.21"],"我们可以在多个组件中重复使用这个增项逻辑强":["34.21"],"提高代码的可复用性和可维护性":["34.21"],"mixins":["34.22"],"的属性":["34.22"],"并将可供混合的类的集合以数组的形式赋给":["34.22"],"因为他们没有实例":["34.24"],"的重要性":["34.25"],"compose":["34.27"],"组合高阶组件":["34.27"],"这个组件会被自动添加上一个不重复的class":["34.28"],"给样式组件传值可以修改样式":["34.28"],"然后再做动画":["34.29"],"删除的节点":["34.29"],"先做动画":["34.29"],"然后再删除dom":["34.29"],"componentdidcatch":["34.31"],"移动这个节点":["35.1"],"所以只会往右移不会往左移":["35.1"],"如果在一长串集合中":["35.1"],"如果最后一个元素移动到第一个":["35.1"],"前面的所有元素都会移动":["35.1"],"性能不佳要尽量避免":["35.1"],"应该用元素的唯一标识id作为key值":["35.1"],"以便更精确地定位和复用已有的dom节点":["35.2"],"完成diff过程":["35.2"],"当所有子节点都比较完成后":["35.2"],"diff算法就完成了":["35.2"],"如果找不到":["35.3"],"则新增到头部":["35.3"],"表示只有旧的一组的子节点还有未处理的节点":["35.4"],"中的节点进行删除":["35.4"],"新老两组的子节点都有剩余":["35.4"],"然后从后遍历新的一组节点":["35.5"],"节点的索引与升序列表对比":["35.5"],"如果对比上了说明不需要移动":["35.5"],"否则需要移动":["35.5"],"最终转换为真实dom":["35.6"],"虽然箭头函数能够避免一部分工作":["36.1"],"目标是让函数组件在功能上能够与类组件类似":["36.2"],"以便更好地复用和组合逻辑":["36.2"],"这个回调函数会确保上一次的setstate":["36.3"],"调用完成后才被调用":["36.3"],"同时会使用最新的state值作为回调函数的第一个参数":["36.3"],"不会同步更新":["36.5","38.2"],"而是异步的":["36.5","38.2"],"apis情况下":["36.6","38.3"],"setstate是同步更新state的":["36.6","38.3"],"对应类组件中的componentwillunmount":["36.7"],"deps依赖列表":["36.7"],"当数组为空":["36.7"],"表示不会因为页面的状态改变而执行回调方法":["36.7"],"即":["36.7"],"仅在初始化时执行":["36.7"],"当这个参数不传递":["36.7"],"表示页面的任何状态一旦变更都会执行回调方法":["36.7"],"当数组非空":["36.7"],"数组里的值一旦有变化":["36.7"],"就会执行回调方法":["36.7"],"callback":["36.8"],"中代码执行会阻塞浏览器绘制":["36.8"],"button":["36.10","36.17"],"onclick":["36.10","36.17"],"increment":["36.10","36.16"],"date":["36.12","59.5"],"这可以通过将函数定义移到父组件外部":["36.14"],"或者使用":["36.14"],"usecallback":["36.14"],"钩子来确保每次渲染时都返回相同的函数引用":["36.14"],"需要配合":["36.15"],"一起使用":["36.15"],"这样当父组件重新渲染时":["36.15"],"缓存的函数的地址不会发生改变":["36.15"],"浅比较会认为":["36.15"],"没有改变":["36.15"],"因此子组件不会重新渲染":["36.15"],"count":["36.16"],"method":["36.17"],"不需要特殊的服务器配置":["37.3"],"哈希路由不会被发送到服务器":["37.3"],"适用于静态网站或无法修改服务器配置的环境":["37.3"],"可以在老旧浏览器中提供更好的兼容性":["37.3"],"因为哈希路由是较早的实现方式":["37.3"],"当children接收到的是一个回调函数时":["37.4"],"即使路径没有匹配组件也会被挂载到页面中":["37.4"],"没有使用switch标签的情况下":["37.4"],"这一特性可以在一些特殊应用场景下发挥作用":["37.4"],"如果不希望出现路径不匹配时组件被挂载的情况":["37.4"],"最好选择使用render来代替":["37.4"],"location":["37.4"],"sensitive":["37.4"],"to":["37.8"],"home":["37.8"],"component":["37.9"],"contact":["37.9"],"apikey":["37.12"],"react":["37.12"],"router":["37.12"],"版本6":["37.12"],"学生列表":["37.15"],"outlet":["37.15"],"about":["37.16"],"div":["37.16"],"但是多了一点":["37.17"],"就算不匹配路由":["37.17"],"函数也会触发":["37.17"],"所以很适合侧边栏或面包屑组件的样式等":["37.17"],"修改了应用的":["37.18"],"活跃时添加的class":["37.19"],"如果你现在在这里读取":["38.0"],"它还是会为":["38.0"],"它会变为":["38.0"],"再统一地进行更新":["38.4"],"这种机制可以在大型应用中得到很好的性能提升":["38.4"],"是多变的":["38.5"],"可以修改":["38.5"],"事件处理函数内部setstate都异步更新":["38.5"],"定义接口来校验":["38.6"],"可以根据需要在回调函数中执行任何操作":["38.7"],"比如更新组件的状态":["38.7"],"触发网络请求等":["38.7"],"也会在":["38.7"],"组件首次渲染时运行一次":["38.7"],"你可能还需要添加一些条件语句来判断是否是首次渲染":["38.7"],"以便执行不同的操作":["38.7"],"依赖数组为空":["38.8"],"组件的":["38.8"],"并且可以嵌套子模块":["41.1","52.5"],"preloadedstate就是state的初始值":["41.3"],"可以在这里指定也可以在reducer中指定":["41.3"],"enhancer增强函数用来对state的功能进行扩展":["41.3"],"你可以在":["41.4"],"redux":["41.4"],"中监听状态的变化":["41.4"],"并在状态发生变化时执行相应的操作":["41.4"],"改学校name":["41.5"],"高老庄中心大街15号":["41.5"],"改学校address":["41.5"],"root":["41.5"],"createroot":["41.5"],"document":["41.5"],"getelementbyid":["41.5"],"render":["41.5"],"会先经过第一个中间件":["41.6"],"然后依次执行下一个中间件":["41.6"],"再最后到达":["41.6"],"这样dispatch作为参数会经过所有中间件":["41.6"],"返回增强后的dispatch":["41.6"],"g":["41.7"],"x":["41.7"],"createstore":["41.9"],"rootreducer":["41.9"],"派发一个":["41.9"],"dispatch":["41.9"],"type":["41.9"],"some":["41.9"],"ljt":["42.1"],"tostring":["42.4","74.1"],"typescript":["42.7"],"在这里是":["42.8"],"除了never本身没有人可以给他赋值":["42.8"],"const":["42.8","72.11","72.12"],"check":["42.8"],"类型断言":["42.10"],"as":["42.10"],"除外":["42.11"],"和非原始类型":["42.11"],"而小":["42.11"],"则表示非原始类型":["42.11"],"编译器就会知道该属性会被明确地赋值":["42.15"],"boolean":["42.17"],"进行描述":["42.18"],"然后将这个myobj再赋值给labeledobj":["42.21"],"此时根据类型的兼容性":["42.21"],"两种类型对象":["42.21"],"参照鸭式辨型法":["42.21"],"因为都具有label属性":["42.21"],"所以被认定为两个相同":["42.21"],"故而可以用此法来绕开多余的类型检查":["42.21"],"ok":["42.23"],"给基本类型起别名通常没什么用":["42.24"],"尽管可以做为文档的一种形式使用":["42.24"],"b":["42.26","73.1","73.2","74.2"],"typeof":["42.26"],"element":["42.29"],"表示元素类型":["42.29"],"ts泛型":["42.29"],"从某个类型中挑出一些属性出来":["42.32"],"record":["42.32"],"的作用是将":["42.32"],"中所有的属性的值转化为":["42.32"],"类型":["42.32"],"告诉nginx如果按顺序检查文件是否存在":["43.2"],"若不存在则重定向到index":["43.2"],"html文件":["43.2"],"事件":["43.4"],"相同的页面":["43.5"],"漂亮依旧":["43.5"],"在路由配置中使用":["43.6"],"this":["43.7","44.26","50.1"],"所以它不会在组件的初始加载时被触发":["43.7"],"beforerouteleave":["43.7"],"在离开当前组件时调用":["43.7"],"与":["43.7"],"一样":["43.7"],"它可以访问组件实例":["43.7"],"导航确认":["43.8"],"dom更新":["43.8"],"users":["43.11"],"id":["43.11"],"在数据获取成功后执行导航":["43.13"],"的参数在路径中可见":["43.15"],"对于敏感信息或较长的参数可能不太适合":["43.15"],"而":["43.15"],"的参数不会在路径中显示":["43.15"],"vue支持在组件间添加过渡效果和动画":["44.1"],"vue3也兼容vue2的选项式api":["44.3"],"vue3使用选项式api生命周期和vue2一样":["44.3"],"vue3的组合式api生命周期有所变化":["44.3"],"methods":["44.5"],"指令之类的都在正常运行":["44.5"],"destroyed":["44.5"],"onunmounted":["44.5","52.0"],"组件销毁完毕":["44.5"],"父destroyed":["44.6"],"销毁":["44.6"],"if会先执行此时还没有拿到这个数组":["44.9"],"所以vue3中依然不建议这样使用":["44.9"],"watch默认只监听一层数据":["44.10"],"不监听多层数据里属性的变化":["44.10"],"需要设置deep":["44.10"],"true才会进行深度监听":["44.10"],"watch没有返回值":["44.13"],"其他情况能用计算属性就首选计算属性":["44.14"],"computed属性函数执行并返回新执行结果":["44.17"],"下一次变更执行重新计算是在":["44.18"],"在响应数据初始化时就会立即执行回调函数":["44.20"],"内置组件":["44.21","51.3"],"vue3新增了传送组件teleport和异步依赖处理组件suspense":["44.21","51.3"],"beforecreate":["44.22"],"created":["44.22"],"beforemount":["44.22"],"mounted":["44.22"],"这些钩子函数允许开发者在不同的生命周期阶段执行一些逻辑":["44.22"],"注册全局和局部组件":["44.22"],"可以注册全局组件或在需要时在特定的组件内注册局部组件":["44.22"],"这样它们就可以在模板中使用了":["44.22"],"当属性发生变化时":["44.23"],"观察者对象会接收到通知":["44.23"],"并触发相应的更新操作":["44.23"],"unshift":["44.24","59.7"],"splice等方法的返回类型和参数类型都得到了改进":["44.24"],"am":["44.26"],"years":["44.26"],"old":["44.26"],"year":["44.26"],"mitt":["44.27"],"除了上面的传参方式你也可以回答vuex和pinia":["44.27"],"前提你了解这两个状态管理器":["44.27"],"因为你说了大概率下个问题就会问你vuex和pinia":["44.27"],"child":["44.29"],"value":["44.31","56.0"],"我们可以在actions中进行数据请求":["44.33"],"拿到结果通过它的dispatch方法调用mutations中修改state的函数":["44.33"],"从而将结果赋值给了state":["44.33"],"patchmethod":["44.34"],"或者在actions中修改":["44.35"],"或者使用它的":["44.35"],"patch方法进行修改":["44.35"],"pinia中没有了modules":["44.35"],"如果想使用多个store":["44.35"],"直接使用definestore定义多个store传入不同的id即可":["44.35"],"更好的ts支持":["44.35"],"不需要创建自定义的复杂包装器来支持ts":["44.35"],"此时组件被激活":["44.37"],"deactivated钩子则是在组件从dom上移除或者组件卸载时调用":["44.37"],"此时组件被缓存":["44.37"],"beforeupdate":["44.38"],"不好追溯源":["44.40"],"后期排查不方便":["44.40"],"proxy不兼容ie11及以下":["44.41"],"video将会被传送到id为popup的元素下":["44.43"],"即异步组件":["44.44"],"这时候便需要调用nexttick函数在它的回调函数中获取到变化后的dom":["44.46"],"利用了异步任务在同步任务之后执行的原理":["44.46"],"算法最重要的就是找到可复用的节点":["44.49"],"然后移动到正确的位置":["44.49"],"只不过不同的算法查找顺序不一样":["44.49"],"移动":["44.50"],"替换等":["44.50"],"js会将这些dom操作打包成批量更新操作":["44.50"],"通过一次性地应用到真实dom上":["44.50"],"以减少dom操作的次数":["44.50"],"用于在下次":["44.53"],"更新循环结束后执行回调函数":["44.53"],"传入nexttick的回调函数会在dom更新完成后被调用":["44.53"],"就可以拿到最新的dom元素了":["44.53"],"on":["44.59"],"input的语法糖":["44.59"],"双向数据流也可以有双向绑定":["44.60"],"两者不应该混为一谈":["44.60"],"使用ssr":["44.62"],"环境等文件":["44.63"],"内联样式风格的方式来根据最新状态设置和改变css":["44.64"],"调用观察者的更新方法":["45.2"],"hr":["45.3","45.15"],"br":["45.3","45.15"],"vue2":["45.3"],"表达式解析":["45.4"],"function":["45.4"],"path":["45.4"],"segments":["45.4"],"split":["45.4"],"for":["45.4","45.13"],"let":["45.4","45.13"],"length":["45.4","72.2"],"执行更新":["45.5"],"watcher主要是用于更新":["45.5"],"而且是收集的重点对象":["45.5"],"obj":["45.8"],"a":["45.8","73.1","73.2","75.15","79.1","82.1"],"observe将一个正常的object转换为每个层级的属性都是响应式的":["45.9"],"observer中通过definereactive方法进行响应式的绑定":["45.9"],"在数据被读的时候":["45.9"],"触发getter方法":["45.9"],"执行dep来收集依赖":["45.9"],"也就是收集watcher":["45.9"],"在数据被改的时候":["45.9"],"触发setter方法":["45.9"],"触发依赖":["45.9"],"通过对应的所有依赖":["45.9"],"watcher":["45.9","45.24"],"去执行更新":["45.9"],"比如watch和computed就执行开发者自定义的回调方法":["45.9"],"通知组件":["45.11"],"通过虚拟dom和diff算法进行页面更新":["45.11"],"key":["45.13"],"of":["45.13"],"if":["45.13"],"update":["45.14"],"sub":["45.14"],"所以触发getter方法":["45.15"],"在getter中就能得到当前正在读取数据的watcher":["45.15"],"并把这个watcher收到dep中":["45.15"],"vue3":["45.15"],"拦截对原对象的所有操作":["45.16"],"用户可以通过注册相应的拦截方法来实现对象操作时的自定义行为":["45.16"],"声明的对象修改原对象无法触发视图更新的原因":["45.17"],"并且":["45.17"],"也只针对":["45.17"],"引用类型数据":["45.17"],"才能进行代理":["45.17"],"所以这也是":["45.17"],"的基础数据都需要通过":["45.17"],"ref":["45.17"],"进行声明的原因":["45.17"],"内部会建立一个新对象保存原有的基础数据值":["45.17"],"coutner":["45.18"],"找到对应的":["45.18"],"副作用函数":["45.18","45.21"],"然后重新执行":["45.18"],"trigger":["45.19"],"依赖更新":["45.19"],"注意":["45.21"],"当我们调用":["45.21"],"时":["45.21"],"会将当前的副作用函数赋值给全局的":["45.21"],"所以此时我们可以正确的关联其依赖":["45.21"],"effect":["45.22","45.29"],"函数的执行来实现视图更新的":["45.24"],"deepreadonly":["45.25"],"操作的拦截两者的大体思路差不多":["45.26"],"不过":["45.26"],"因为只读的原因":["45.26"],"数据不会发生改变":["45.26"],"所以不会进行依赖收集操作":["45.26"],"如果有深层数据则会继续向内部进行同样的处理操作":["45.26"],"null":["45.27"],"add":["45.28"],"set":["45.34"],"你用自定义指令做过哪些功能":["46.0"],"不使用":["46.2"],"backgroundcolor":["46.3"],"bordercolor":["46.3"],"handleclick":["46.3"],"点击":["46.3"],"引入完成之后就可以在组件中使用v":["46.6"],"debounce":["46.6"],"unmounted":["47.0","63.0"],"placeholder":["50.1"],"请输入阈值":["50.1"],"required":["50.1"],"isrowselected":["50.1"],"label":["50.2"],"isfull":["50.3"],"则获取全表已选中的数据":["50.3"],"selectarr":["50.3"],"modal组件v":["50.4"],"model双向绑定createmodal":["50.4"],"在created里设置":["50.4"],"良好的":["51.0"],"文档":["51.0"],"和示例":["51.0"],"根节点":["51.3"],"vue3组件允许多个根节点":["51.3"],"而vue2只允许一个":["51.3"],"但在生产环境下webpack打包的代码更小":["51.5"],"效率更高":["51.5"],"double":["51.7"],"double2":["51.7"],"addoneanddouble":["51.7"],"reduceright从右到左依次执行":["51.7"],"组件销毁完成调用":["52.0"],"创建一个axios实例":["52.3"],"用这个实例对特定请求进行拦截":["52.3"],"子组件通过expose把需要暴露出来的属性暴露出来":["52.4"],"父组件通过inject接收":["52.4"],"mutations":["52.6"],"指针或引用":["53.2"],"来找到对象的实际位置":["53.2"],"构造函数":["53.12"],"从根元素开始遍历dom树":["53.13"],"match头将该标识符发送给服务器":["53.19"],"如果资源的etag没有变化":["53.19"],"则服务器返回304状态码":["53.19"],"资源隔离":["53.23"],"避免了不同网页之间的资源争夺和冲突":["53.23"],"并且把key存入this":["53.26"],"keys中":["53.26"],"则返回304不返回内容":["53.35"],"volar":["55.1"],"uniquearr":["56.0"],"values":["56.0"],"适用于根据已有数据派生出新的数据":["56.2"],"以及在模板中使用计算结果":["56.2"],"通过使用watch":["56.3"],"可以监视数据的变化":["56.3"],"并在数据变化时执行相应的操作":["56.3"],"从而实现对数据的动态响应和处理":["56.3"],"属性为":["56.10"],"的元素":["56.10"],"设置":["56.10"],"position":["56.10","79.1"],"会被忽略":["56.10"],"这种机制允许程序与外部环境进行交互":["56.12"],"并根据需要作出反应":["56.12"],"race方法":["56.13"],"可以等待多个promise中的任何一个完成":["56.13"],"一定事件循环周期内":["56.14"],"先处理微任务队列中的任务在处理宏任务":["56.14"],"执行fn函数":["59.1"],"这样就可以保证函数在正确的上下文中执行":["59.1"],"并且能够正确地处理参数":["59.1"],"san":["59.4"],"francisco":["59.4"],"原始对象不受影响":["59.4"],"拷贝对象被修改":["59.4"],"方法并传入正则表达式和替换字符串":["59.6"],"将会将整个字符串替换为捕获组中的内容":["59.6"],"返回数组":["59.7"],"concat":["59.8","66.5"],"res":["60.0"],"err":["60.0","61.0"],"computed":["62.0"],"拼接在前":["67.2"],"逆序":["67.2"],"prime":["69.2"],"getprime":["69.2"],"resize":["69.2"],"put":["69.7"],"二叉树":["71.1"],"从树中移除某个键":["71.3"],"right":["71.4","79.1"],"先序遍历其左子树":["71.7"],"先序遍历其右子树":["71.7"],"递归图解":["71.7","71.8","71.9"],"先序遍历递归图解":["71.7"],"访问根结点":["71.8","71.9"],"中序遍历其右子树":["71.8"],"中序遍历递归图解":["71.8"],"后序遍历其右子树":["71.9"],"后序遍历递归图解":["71.9"],"依次向下找到节点":["71.12"],"同时记录current":["71.12"],"isleftchild这些变量":["71.12"],"如果遍历到current":["71.12"],"那么说明在二叉搜索树中没有该key":["71.12"],"直接返回false即可":["71.12"],"如果找到":["71.12"],"后面就需要我们进一步考虑更加复杂的情况了":["71.12"],"20这个左子树怎么办":["71.15"],"很明显":["71.15"],"19应该放在20的左边":["71.15"],"20应该放在18的右边":["71.15"],"19放在20的左边代码":["71.15"],"20放在18的右边代码":["71.15"],"图解删除":["71.15"],"data":["72.5","72.8"],"next":["72.6"],"remove":["72.9"],"links":["72.11","72.12"],"links2":["72.11","72.12"],"linkget":["72.11","72.12"],"infinity":["75.11","76.6","76.7"],"r":["75.15"],"arr3":["76.5","76.6"],"流光按钮":["78.2"],"刷新":["79.1"],"dianhua":["79.1"],"电话":["79.1"],"pinglun":["79.1"],"评论":["79.1","79.8"],"licon":["79.1","82.2"],"name":["79.1"],"xiala2":["79.1","82.1"],"jinru":["79.1","82.1","82.2","82.3"],"按钮":["79.2"],"guanbi":["82.1"],"fenxiang2":["82.1"],"center":["85.2"],"td元素里面所有非block元素":["85.2"],"都会相对于td水平居中":["85.2"],"虽然block元素不居中":["85.2"],"但其中的文字或inline元素会水平居中":["85.2"],"undefinded":["85.4"],"第二个catch无结果":["85.9"],"以":["85.10"],"这种形式调用对象的键名时":["85.10"],"里面的键b一定要有引号":["85.10"],"必须为字符串或者是symbol":["85.10"],"如果不是字符串则转为字符串":["85.10"],"后":["88.1"],"将其返回值返回给最外层的函数调用":["88.1"]}]'},e={"0.0":{t:"# ajax\r",p:"\r",l:"audition/ajax/ajax.html",a:"ajax"},"0.1":{t:"什么是ajax？ajax作用是什么？\r",p:`
a 异步的
j javascript a and
x xml
ajax用来与后台交互

`,l:"audition/ajax/ajax.html#什么是ajax-ajax作用是什么",a:"什么是ajax-ajax作用是什么"},"0.2":{t:"ajax 常见的方法\r",p:`
XHR

const xhr = new XMLHttpRequest();
xhr.open('GET', &quot;http://localhost:3000/goods&quot;)
xhr ...`,l:"audition/ajax/ajax.html#ajax-常见的方法",a:"ajax-常见的方法"},"0.3":{t:"json字符串转换集json对象、json对象转换json字符串\r",p:`//字符串转对象
JSON.parse(json)
eval('(' + jsonstr + ')')   
// 对象转字符串
JSON.stringify(json)


`,l:"audition/ajax/ajax.html#json字符串转换集json对象、json对象转换json字符串",a:"json字符串转换集json对象、json对象转换json字符串"},"0.4":{t:"ajax几种请求方式？他们的优缺点？\r",p:`常用的post,get,delete。不常用copy、head、link等等。

get
post

区别

post比get安全(因为post参数在请求体中。get参数在url上面)
get传输速度 ...`,l:"audition/ajax/ajax.html#ajax几种请求方式-他们的优缺点",a:"ajax几种请求方式-他们的优缺点"},"0.5":{t:"什么情况造成跨域？\r",p:`同源策略限制 不同源会造成跨域。




原因




http://
协议不同，http和https


www
子域名不同


baidu.com
主域名不同


8080
端口号不同


www ...`,l:"audition/ajax/ajax.html#什么情况造成跨域",a:"什么情况造成跨域"},"0.6":{t:"跨域解决方案有哪些？\r",p:`
jsonp 只能解决get跨域(问的最多)
原理：动态创建一个script标签。利用script标签的src属性不受同源策略限制。因为所有的src属性和href属性都不受同源策略限制。可以请求第三方 ...`,l:"audition/ajax/ajax.html#跨域解决方案有哪些",a:"跨域解决方案有哪些"},"0.7":{t:"使用axios怎么中止请求\r",p:`axios.CancelToken.source();
`,l:"audition/ajax/ajax.html#使用axios怎么中止请求",a:"使用axios怎么中止请求"},"0.8":{t:"axios的请求响应拦截\r",p:`
响应拦截

全局错误处理：你可以在响应拦截器中检查响应的状态码，并根据不同的状态码执行相应的操作。例如，如果响应状态码是401（未授权），你可以执行相应的操作，例如重新登录或跳转到登录页面。
统一的 ...`,l:"audition/ajax/ajax.html#axios的请求响应拦截",a:"axios的请求响应拦截"},"0.9":{t:"axios封装\r",p:`
设置接口请求前缀：根据开发、测试、生产环境的不同，前缀需要加以区分
请求头 : 来实现一些具体的业务，必须携带一些参数才可以请求(例如：会员业务)
状态码: 根据接口返回的不同status ， 来执 ...`,l:"audition/ajax/ajax.html#axios封装",a:"axios封装"},"0.10":{t:"axios取消请求\r",p:`CancelToken.source()在get方法中，调用source.cancel('主动取消请求')，主动取消请求
// 方式一
const CancelToken = axios.Cancel ...`,l:"audition/ajax/ajax.html#axios取消请求",a:"axios取消请求"},"1.0":{t:"# CSS\r",p:"\r",l:"audition/css/css上篇.html",a:"css"},"1.1":{t:"1. 常见的水平垂直居中实现方案\r",p:`
最简单的方案当然是flex布局

.father {
    display: flex;
    justify-content: center;
    align-items: center; ...`,l:"audition/css/css上篇.html#_1-常见的水平垂直居中实现方案",a:"_1-常见的水平垂直居中实现方案"},"1.2":{t:"清除浮动\r",p:`清除浮动是为了解决浮动元素导致的父元素高度塌陷问题。
使用额外的空元素清除浮动：
&lt;div style=&quot;clear: both;&quot;&gt;&lt;/div&gt;

使用伪 ...`,l:"audition/css/css上篇.html#清除浮动",a:"清除浮动"},"1.3":{t:"2. BFC问题，触发BFC的元素\r",p:`BFC：块级格式化上下文,属于普通流，是一块独立的渲染区域，内部元素不会影响外部的元素。
如何触发？

根元素
float属性不是none position为absolute或者fixed
displ ...`,l:"audition/css/css上篇.html#_2-bfc问题-触发bfc的元素",a:"_2-bfc问题-触发bfc的元素"},"1.4":{t:"4. 隐藏元素的属性有哪些\r",p:"",l:"audition/css/css上篇.html#_4-隐藏元素的属性有哪些",a:"_4-隐藏元素的属性有哪些"},"1.5":{t:"1. 常规方法\r",p:`
display: none;（结构消失；会触发回流重绘性能消耗较大；非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示）
visibility: hidden;（结构保留 ...`,l:"audition/css/css上篇.html#_1-常规方法",a:"_1-常规方法"},"1.6":{t:"2. 逃逸视窗\r",p:`
position + left/top（利用绝对定位 position 设置 absolute 或 fixed，同时 left 或 top 设置 -9999px；
超大负边距会将元素抛出视图，因为定 ...`,l:"audition/css/css上篇.html#_2-逃逸视窗",a:"_2-逃逸视窗"},"1.7":{t:"3. 移行变换\r",p:`
scale(0) / skew(90deg)（通过2D变换来达到隐藏，占据空间，不可交互。注意：此方法对行内元素无效！）
circle(0px)（利用裁剪创建元素的可显示区域，区域外会隐藏，占据空间 ...`,l:"audition/css/css上篇.html#_3-移行变换",a:"_3-移行变换"},"1.8":{t:"5. px 和 em 的区别\r",p:`
px全称pixel像素，是相对于屏幕分辨率而言的，它是一个绝对单位
em是一个相对长度单位，具体的大小需要相对于父元素计算，比如父元素的字体大小为80px，那么子元素1em就表示大小和父元素一样为8 ...`,l:"audition/css/css上篇.html#_5-px-和-em-的区别",a:"_5-px-和-em-的区别"},"1.9":{t:"6. vw、vh 是什么？\r",p:`vw 和 vh 是 CSS3 新单位，即 view width 可视窗口宽度 和 view height 可视窗口高度。1vw 就等于可视窗口宽度的百分之一，1vh 就等于可视窗口高度的百分之一。

 ...`,l:"audition/css/css上篇.html#_6-vw、vh-是什么",a:"_6-vw、vh-是什么"},"1.10":{t:"自适应布局rem\r",p:`自适应布局使用rem作为单位，其原理是基于浏览器默认字体大小的相对值来计算元素的尺寸，实现不同屏幕尺寸下的自适应布局。
在HTML的&lt;head&gt;标签中设置基准字体大小，一般为16px。然后 ...`,l:"audition/css/css上篇.html#自适应布局rem",a:"自适应布局rem"},"1.11":{t:"7. flex 布局如何使用\r",p:`flex 是 Flexible Box 的缩写，意为&quot;弹性布局&quot;。指定容器display: flex即可。
容器有以下属性：flex-direction，flex-wrap，fle ...`,l:"audition/css/css上篇.html#_7-flex-布局如何使用",a:"_7-flex-布局如何使用"},"1.12":{t:"3. felx是哪些属性的缩写，对应的属性代表什么含义\r",p:`flex在浏览器中查看分别是

flex-grow（设置了对应元素的增长系数）
flex-shrink(指定了对应元素的收缩规则，只有在所有元素的默认宽度之和大于容器宽度时才会触发)
flex-bas ...`,l:"audition/css/css上篇.html#_3-felx是哪些属性的缩写-对应的属性代表什么含义",a:"_3-felx是哪些属性的缩写-对应的属性代表什么含义"},"1.13":{t:"flex:1\r",p:`
flex: 1, 对应的是1 1 0%, 相当于可扩大，可缩小，flex-basis为0%
不管内容多少，一般都是平分空间，空间大小都一致

`,l:"audition/css/css上篇.html#flex-1",a:"flex-1"},"1.14":{t:"flex:auto\r",p:`
flex: auto, 对应的是1 1 auto, 相当于可扩大，可缩小，flex-basis为auto
flex: auto是根据内容的大小来分，不是均分的（除非内容都是一样，才均分）

`,l:"audition/css/css上篇.html#flex-auto",a:"flex-auto"},"1.15":{t:"flex: 0\r",p:`
flex: 0, 对应的是0 1 0%, 相当于不可扩大，可缩小，flex-basis为0%
不可扩大，可缩小,表现形式为最小内容宽度

`,l:"audition/css/css上篇.html#flex-0",a:"flex-0"},"1.16":{t:"flex: none\r",p:`
flex: none, 对应的是0 0 auto, 相当于不可扩大，不可缩小，flex-basis为auto
不可扩大，不可缩小，内容本身的宽度是多少就是多少

`,l:"audition/css/css上篇.html#flex-none",a:"flex-none"},"1.17":{t:"8. grid布局\r",p:"那就是 flex 布局是一维布局，Grid 布局是二维布局。flex 布局一次只能处理一个维度上的元素布局，一行或者一列。Grid 布局是将容器划分成了“行”和“列”，产生了一个个的网格，我们可以将网 ...",l:"audition/css/css上篇.html#_8-grid布局",a:"_8-grid布局"},"1.18":{t:"8. 如何用 css 或 js 实现多行文本溢出省略效果，考虑兼容性\r",p:`overflow: hidden;
text-overflow:ellipsis;
white-space: nowrap;

`,l:"audition/css/css上篇.html#_8-如何用-css-或-js-实现多行文本溢出省略效果-考虑兼容性",a:"_8-如何用-css-或-js-实现多行文本溢出省略效果-考虑兼容性"},"1.19":{t:"9. 居中为什么要使用 transform（为什么不使用 marginLeft/Top）\r",p:`
transform 属于合成属性（composite property），对合成属性进行 transition/animation 动画将会创建一个合成层（composite layer），这使得被 ...`,l:"audition/css/css上篇.html#_9-居中为什么要使用-transform-为什么不使用-marginleft-top",a:"_9-居中为什么要使用-transform-为什么不使用-marginleft-top"},"1.20":{t:"10. 介绍下粘性布局(sticky)\r",p:"position 中的 sticky 值是 CSS3 新增的，设置了 sticky 值后，在屏幕范围（viewport）时该元素的位置并不受到定位影响（设置是top、left等属性无效），当该元素的位 ...",l:"audition/css/css上篇.html#_10-介绍下粘性布局-sticky",a:"_10-介绍下粘性布局-sticky"},"1.21":{t:"11. 说出 space-between 和 space-around 的区别\r",p:`这个是 flex 布局的内容，其实就是一个边距的区别，按水平布局来说：

space-between是两端对齐，在左右两侧没有边距，
而space-around是每个子项目左右方向的 margin 相 ...`,l:"audition/css/css上篇.html#_11-说出-space-between-和-space-around-的区别",a:"_11-说出-space-between-和-space-around-的区别"},"1.22":{t:"12. CSS3 中 transition 和 animation 的属性分别有哪些\r",p:`transition 过渡动画：

transition-property：指定过渡的 CSS 属性
transition-duration：指定过渡所需的完成时间
transition-timing ...`,l:"audition/css/css上篇.html#_12-css3-中-transition-和-animation-的属性分别有哪些",a:"_12-css3-中-transition-和-animation-的属性分别有哪些"},"1.23":{t:"clip-path\r",p:`clip-path 属性使用裁剪方式创建元素的可显示区域。区域内的部分显示，区域外的隐藏。可以指定一些特定形状。
裁剪一张图像，以圆形的方式显示 50%：
img {
  clip-path: cir ...`,l:"audition/css/css上篇.html#clip-path",a:"clip-path"},"1.24":{t:"行内元素和块元素\r",p:`
块级元素以块状形式显示，并占据一行或多行的空间，其宽度默认为父元素的100%。块级元素可以设置宽度、高度、外边距和内边距等盒模型属性。可以容纳其他块级元素或行内元素。
行内元素则不会产生换行，宽度由 ...`,l:"audition/css/css上篇.html#行内元素和块元素",a:"行内元素和块元素"},"1.25":{t:"text\r",p:`/text-aline/
h1 {text-align:center;}  //居中
p.date {text-align:right;}  
p.main {text-align:justify;} ...`,l:"audition/css/css上篇.html#text",a:"text"},"1.26":{t:"对齐\r",p:`{
  vertical-align 属性设置一个元素的垂直对齐方式。
  align-content:center; space-between  space-around 对齐弹性盒的 &lt;d ...`,l:"audition/css/css上篇.html#对齐",a:"对齐"},"1.27":{t:"动画\r",p:`animation: name duration timing-function delay iteration-count direction fill-mode play-state;
`,l:"audition/css/css上篇.html#动画",a:"动画"},"1.28":{t:"响应式布局rem和em\r",p:`rem相对于根元素（即HTML元素）
em相对于父元素
`,l:"audition/css/css上篇.html#响应式布局rem和em",a:"响应式布局rem和em"},"1.29":{t:"css选择器排序\r",p:`
内联样式的权重为1000。
ID选择器的权重为100。
类选择器、属性选择器和伪类选择器的权重为10。
元素选择器和伪元素选择器的权重为1。

`,l:"audition/css/css上篇.html#css选择器排序",a:"css选择器排序"},"1.30":{t:"属性选择器和伪类选择器\r",p:`

属性选择器使用方括号（[]）来指定属性和属性值。


伪类选择器选择处于特定状态或特定位置的元素。它们通过在选择器后面使用冒号（:）和关键词来指定。


/* 选择已选中的复选框 不用js*/
i ...`,l:"audition/css/css上篇.html#属性选择器和伪类选择器",a:"属性选择器和伪类选择器"},"1.31":{t:"伪元素选择器\r",p:`伪元素选择器允许在元素的特定位置插入额外的内容，而无需修改HTML结构。这些内容可以用于添加装饰、修饰文本或创建特殊效果。

::before：在元素内容之前插入生成的内容。
::after：在元素内 ...`,l:"audition/css/css上篇.html#伪元素选择器",a:"伪元素选择器"},"1.32":{t:"继承属性\r",p:`字体系列属性：font
font:组合字体
font-family:规定元素的字体系列
font-weight:设置字体的粗细
font-size:设置字体的尺寸
font-style:定义字体的风格 ...`,l:"audition/css/css上篇.html#继承属性",a:"继承属性"},"1.33":{t:"响应式布局\r",p:`
媒体查询
百分比
vw/vh rem

`,l:"audition/css/css上篇.html#响应式布局",a:"响应式布局"},"1.34":{t:"如果要做优化，CSS提高性能的方法有哪些？\r",p:`
内联首屏关键CSS，内联css使浏览器在下载完html后就能立刻渲染，而如果外部引用css代码，在解析html结构过程中遇到外部css文件，才会开始下载css代码，再渲染
异步加载CSS，
资源压缩 ...`,l:"audition/css/css上篇.html#如果要做优化-css提高性能的方法有哪些",a:"如果要做优化-css提高性能的方法有哪些"},"1.35":{t:"媒体查询工作原理\r",p:`
当浏览器加载页面时，解析 CSS 文件中的媒体查询。
根据设备的属性和特征，判断是否满足媒体查询的条件。如果满足，则将媒体查询内的样式规则应用到对应的元素或组件上。
如果设备的属性或特征发生改变（如 ...`,l:"audition/css/css上篇.html#媒体查询工作原理",a:"媒体查询工作原理"},"2.0":{t:"13. 如何用 CSS 实现一个三角形\r",p:`利用盒模型的 border 属性上下左右边框交界处会呈现出平滑的斜线这个特点，通过设置不同的上下左右边框宽度或者颜色即可得到三角形或者梯形。
`,l:"audition/css/css下篇.html",a:"_13-如何用-css-实现一个三角形"},"2.1":{t:"14. 如何实现一个自适应的正方形\r",p:`
利用 CSS3 的 vw 单位，vw 会把视口的宽度平均分为 100 份
利用 margin 或者 padding 的百分比计算是参照父元素的 width 属性

`,l:"audition/css/css下篇.html#_14-如何实现一个自适应的正方形",a:"_14-如何实现一个自适应的正方形"},"2.2":{t:"15. 清除浮动的方法\r",p:`
clear 清除浮动（添加空div法）在浮动元素下方添加空div，并给该元素写css样式： {clear:both;height:0;overflow:hidden;}
给浮动元素父级设置高度
父级 ...`,l:"audition/css/css下篇.html#_15-清除浮动的方法",a:"_15-清除浮动的方法"},"2.3":{t:"盒模型\r",p:"CSS盒模型是指在HTML中，每个元素都被视为一个矩形的盒子，其包括四个部分：内容(content)、填充(padding)、边框(border)、外边距(margin)。CSS盒模型中，元素的大小由 ...",l:"audition/css/css下篇.html#盒模型",a:"盒模型"},"2.4":{t:"16. 两种盒模型以及区别\r",p:`
W3C盒模型（标准盒模型）和IE盒模型，主要区别是二者的盒子宽高是否包括元素的边框和内边距。IE盒模型中内容的宽或高将会包含内边距、外边距和边框，而W3C盒模型把内边距边框放到外面相加。
W3C盒模 ...`,l:"audition/css/css下篇.html#_16-两种盒模型以及区别",a:"_16-两种盒模型以及区别"},"2.5":{t:"指定盒模型的类型\r",p:"可以使用box-sizing属性来指定盒模型的类型，其取值为content-box和border-box。默认值为content-box，表示使用标准盒模型；而border-box表示使用IE盒模型。 ...",l:"audition/css/css下篇.html#指定盒模型的类型",a:"指定盒模型的类型"},"2.6":{t:"17. 如何触发重排和重绘，重绘)？\r",p:`
添加、删除、更新DOM节点
通过display: none隐藏一个DOM节点-触发重排和重绘
通过visibility: hidden隐藏一个DOM节点-只触发重绘，因为没有几何变化
移动或者给页面 ...`,l:"audition/css/css下篇.html#_17-如何触发重排和重绘-重绘",a:"_17-如何触发重排和重绘-重绘"},"2.7":{t:"18. 如何优化图片\r",p:`
对于很多装饰类图片，尽量不用图片，因为这类修饰图片完全可以用 CSS 去代替。
将多个图标文件整合到一张图片中（雪碧图）
WebP 格式的浏览器尽量使用 WebP 格式，因为 WebP 格式具有更好 ...`,l:"audition/css/css下篇.html#_18-如何优化图片",a:"_18-如何优化图片"},"2.8":{t:"19. CSS3 新增了那些东西？\r",p:`
选择器nth-child、last-child
盒子模型属性：border-radius、box-shadow、border-image
背景：background-size、background- ...`,l:"audition/css/css下篇.html#_19-css3-新增了那些东西",a:"_19-css3-新增了那些东西"},"2.9":{t:"媒体查询\r",p:"媒体查询是CSS3中新增的一种功能，它允许开发者根据设备屏幕尺寸、分辨率、方向等条件来为不同的设备或浏览器设置不同的CSS样式。通过媒体查询，我们可以根据屏幕宽度、高度等条件来动态地调整网页的布局和样 ...",l:"audition/css/css下篇.html#媒体查询",a:"媒体查询"},"2.10":{t:"20. 实现三栏布局的7种方法\r",p:`
浮动float + calc()

div {
    height: 100px;
}
.left {
    float: left;
    width: 200px;
    backgro ...`,l:"audition/css/css下篇.html#_20-实现三栏布局的7种方法",a:"_20-实现三栏布局的7种方法"},"3.0":{t:"# ES6\r",p:"\r",l:"audition/es6/ES6.html",a:"es6"},"3.1":{t:"1. 什么是ES6模块化？\r",p:`ES6 模块化规范是浏览器端与服务器端通用的模块化开发规范。
`,l:"audition/es6/ES6.html#_1-什么是es6模块化",a:"_1-什么是es6模块化"},"3.2":{t:"定义：\r",p:`
每个 js 文件都是一个独立的模块
导入其它模块成员使用 import关键字
向外共享模块成员使用 export关键字

`,l:"audition/es6/ES6.html#定义",a:"定义"},"3.3":{t:"用法：\r",p:`
默认导出与默认导入
按需导出与按需导入
直接导入并执行模块中的代码

`,l:"audition/es6/ES6.html#用法",a:"用法"},"3.4":{t:"默认导出与默认导入注意点：\r",p:`
每个模块中，只允许使用唯一的一次export default，否则会报错
默认导入时的接收名称可以任意名称，只要是合法的成员名称即可

`,l:"audition/es6/ES6.html#默认导出与默认导入注意点",a:"默认导出与默认导入注意点"},"3.5":{t:"按需导入与按需导出注意点：\r",p:`
每个模块中可以使用多次按需导出
按需导入的成员名称必须和按需导出的名称保持一致
按需导入时，可以使用 as 关键字进行重命名
按需导入可以和默认导入一起使用

ES6新增
`,l:"audition/es6/ES6.html#按需导入与按需导出注意点",a:"按需导入与按需导出注意点"},"3.6":{t:"2. 新增了let const关键字\r",p:`
var允许重复声明，let、const不允许
var会提升变量的声明到作用域的顶部，但let和const不会
只要作用域内存在let、const，它们所声明的变量或常量就会自动“绑定”这个区域，不再 ...`,l:"audition/es6/ES6.html#_2-新增了let-const关键字",a:"_2-新增了let-const关键字"},"3.7":{t:"3. 作用域\r",p:`常见的作用域主要分为几个类型：全局作用域、函数作用域、块状作用域、动态作用域



对象
类型




global/window
全局作用域


function
函数作用域（局部作用域）


{} ...`,l:"audition/es6/ES6.html#_3-作用域",a:"_3-作用域"},"3.8":{t:"4. 新增的解构赋值\r",p:`解构赋值针对数组或者对象进行模式匹配，然后对其中的变量进行赋值。
let [a,b] = [1,2]
let {user} = obj

`,l:"audition/es6/ES6.html#_4-新增的解构赋值",a:"_4-新增的解构赋值"},"3.9":{t:"5. 新增了箭头函数\r",p:`箭头函数和普通函数的区别

普通函数存在着变量的提升，箭头函数没有
普通函数的this指向，谁调用指向谁，箭头函数是在哪定义就指向谁
普通函数可以当成构造函数，而箭头函数是不可以的
箭头函数没有arg ...`,l:"audition/es6/ES6.html#_5-新增了箭头函数",a:"_5-新增了箭头函数"},"3.10":{t:"6. js新增简单数据类型Symbol\r",p:`symbol
`,l:"audition/es6/ES6.html#_6-js新增简单数据类型symbol",a:"_6-js新增简单数据类型symbol"},"3.11":{t:"7. 新增了class关键字\r",p:`class关键字是es5构造函数+原型模式创建对象的语法糖。创建类的方式 class 类名{构造函数和方法} 通过extends关键字实现继承。
`,l:"audition/es6/ES6.html#_7-新增了class关键字",a:"_7-新增了class关键字"},"3.12":{t:"8. es6新增了模块化\r",p:`与node.js的commonjs不同,es6新增esmoudule
根据功能封装模块 通过import导入 然后通过export导出，也可以使用export default导出

export 可以 ...`,l:"audition/es6/ES6.html#_8-es6新增了模块化",a:"_8-es6新增了模块化"},"3.13":{t:"9. 新增promise\r",p:`promise
`,l:"audition/es6/ES6.html#_9-新增promise",a:"_9-新增promise"},"3.14":{t:"Generator（生成器）\r",p:`Generator（生成器）是 ES6 中引入的一种特殊函数，它可以被暂停和恢复
场景：
惰性计算（Lazy Evaluation）：Generator 函数可以实现惰性计算，只有当需要获取值时
异步 ...`,l:"audition/es6/ES6.html#generator-生成器",a:"generator-生成器"},"3.15":{t:"ES6新增\r",p:`
数组：

扩展运算符
构造函数新增方法，Array.from、Array.of
数组新增方法，find,findindex,includes,fill,keys,values,entires，cop ...`,l:"audition/es6/ES6.html#es6新增",a:"es6新增"},"4.0":{t:"js新增简单数据类型Symbol\r",p:`新增简单数据类型Symbol，用于表示一个独一无二的值。
const a = Symbol(); //Symbol创建实例不需要new
console.log(a);  //Symbol()

不能在 ...`,l:"audition/es6/symbol.html",a:"js新增简单数据类型symbol"},"5.0":{t:"# DOM\r",p:"\r",l:"audition/html/DOM.html",a:"dom"},"5.1":{t:"什么是DOM，文档对象模型\r",p:`从网络传给渲染引擎的 HTML 文件字节流是无法直接被渲染引擎理解的，所以要将其转化 为渲染引擎能够理解的内部结构，这个结构就是 DOM。DOM 提供了对 HTML 文档结构 化的表述。
!dom树
 ...`,l:"audition/html/DOM.html#什么是dom-文档对象模型",a:"什么是dom-文档对象模型"},"5.2":{t:"DOM 树如何生成\r",p:"渲染引擎内部，有一个叫HTML 解析器（HTMLParser）的模块，它的职责就是负责将HTML 字节流转换为 DOM 结构。HTML 解析器并不是等整个文档加载完成之后再解析的，而是网络进程加载了多 ...",l:"audition/html/DOM.html#dom-树如何生成",a:"dom-树如何生成"},"5.3":{t:"JavaScript和css会不会影响DOM树构建和渲染\r",p:`
CSS不会阻塞DOM树的解析，但是会阻塞DOM树的渲染，阻塞后面js语句的执行
JavaScript 会阻止DOM树的解析
最终CSS（CSSOM）会影响DOM树的渲染，也可以说最终会影响渲染树的生 ...`,l:"audition/html/DOM.html#javascript和css会不会影响dom树构建和渲染",a:"javascript和css会不会影响dom树构建和渲染"},"5.4":{t:"JavaScript对DOM树构建和渲染的影响\r",p:`
执行到 JavaScript 标签时，暂停整个 DOM 的解析，执行 JavaScript 代码，如果要下载JavaScript代码，下载过程会阻塞DOM 解析
Chrome 浏览器预解析操作，当渲 ...`,l:"audition/html/DOM.html#javascript对dom树构建和渲染的影响",a:"javascript对dom树构建和渲染的影响"},"5.5":{t:"规避JavaScript线程阻塞DOM现象\r",p:`JavaScript 脚本设置为异步加载，通过 async 或 defer 来标记代码
`,l:"audition/html/DOM.html#规避javascript线程阻塞dom现象",a:"规避javascript线程阻塞dom现象"},"5.6":{t:"DOMContentLoaded\r",p:`
文档解析完毕DOM树构建完成，触发 DOMContentLoaded 事件。
html所有资源都加载完毕之后，load 事件触发。

`,l:"audition/html/DOM.html#domcontentloaded",a:"domcontentloaded"},"5.7":{t:"DOM文档加载的步骤为：\r",p:`
解析HTML结构。
加载外部脚本和样式表文件。
解析并执行脚本代码。
DOM树构建完成。//DOMContentLoaded
加载图片等外部文件。
页面加载完毕。//load

`,l:"audition/html/DOM.html#dom文档加载的步骤为",a:"dom文档加载的步骤为"},"5.8":{t:" 网页的渲染\r",p:`DOM文档的加载顺序是由上而下的顺序加载：

下载html，内联css使浏览器在下载完html后就能立刻渲染
在解析html到link标签（css）外部 CSS 文件的下载是异步的，即浏览器会继续加载 ...`,l:"audition/html/DOM.html#网页的渲染",a:"网页的渲染"},"5.9":{t:"DOM树的构建是文档加载完成开始的？ \r",p:`构建 DOM 树是一个渐进过程，为达到更好的用户体验，渲染引擎会尽快将内容显示在屏幕上，它不必等到整个 HTML 文档解析完成之后才开始构建 render 树和布局。
`,l:"audition/html/DOM.html#dom树的构建是文档加载完成开始的",a:"dom树的构建是文档加载完成开始的"},"5.10":{t:"Render 树是 DOM 树和 CSS 样式表构建完毕后才开始构建的？ \r",p:`这三个过程在实际进行的时候并不是完全独立的，而是会有交叉，会一边加载，一边解析，以及一边渲染。
`,l:"audition/html/DOM.html#render-树是-dom-树和-css-样式表构建完毕后才开始构建的",a:"render-树是-dom-树和-css-样式表构建完毕后才开始构建的"},"5.11":{t:"CSS 的解析注意点？ \r",p:`CSS 的解析是从右往左逆向解析的，嵌套标签越多，解析越慢。
`,l:"audition/html/DOM.html#css-的解析注意点",a:"css-的解析注意点"},"5.12":{t:"JS 操作真实 DOM 的代价？\r",p:`原生 JS 或 JQ 操作 DOM 时，浏览器会从构建 DOM 树开始从头到尾执行一遍流程，需要更新 10 个 DOM 节点就要从头到尾执行10遍
`,l:"audition/html/DOM.html#js-操作真实-dom-的代价",a:"js-操作真实-dom-的代价"},"5.13":{t:"Virtual-DOM 就是一个JS对象模拟的DOM树\r",p:`参考这篇
虚拟 DOM 就是为了解决浏览器性能问题而被设计出来的。如前，若一次操作中有 10 次更新 DOM 的动作，虚拟 DOM 不会立即操作 DOM，而是将这 10 次更新的 diff 内容保存到 ...`,l:"audition/html/DOM.html#virtual-dom-就是一个js对象模拟的dom树",a:"virtual-dom-就是一个js对象模拟的dom树"},"5.14":{t:"Virtual-DOM的实现\r",p:`
用 JS 对象模拟 DOM 树
diff算法比较两棵虚拟 DOM 树的差异
将两个虚拟 DOM 对象的差异应用到真正的 DOM 树

`,l:"audition/html/DOM.html#virtual-dom的实现",a:"virtual-dom的实现"},"5.15":{t:"vue的Virtual-DOM\r",p:"",l:"audition/html/DOM.html#vue的virtual-dom",a:"vue的virtual-dom"},"5.16":{t:"VNode 模拟 DOM 树\r",p:`利用 _createElement 方法创建 VNode，它定义在 src/core/vdom/create-elemenet.js 中
`,l:"audition/html/DOM.html#vnode-模拟-dom-树",a:"vnode-模拟-dom-树"},"5.17":{t:"DOM常用接口\r",p:`
Document: 表示整个文档，提供了操作和访问文档的方法和属性。
Element: 表示一个元素节点，提供了操作和访问元素的方法和属性。
Node: 表示文档中的一个节点，可以是元素节点、文本节 ...`,l:"audition/html/DOM.html#dom常用接口",a:"dom常用接口"},"5.18":{t:"Document\r",p:`
getElementById(id): 根据元素的 id 属性获取对应的元素节点。
querySelector(selector): 根据 CSS 选择器选择匹配的第一个元素节点。
querySel ...`,l:"audition/html/DOM.html#document",a:"document"},"5.19":{t:"常用属性：\r",p:`
documentElement: 返回文档的根元素节点（通常是 &lt;html&gt;）。
head: 返回文档的头部元素节点（通常是 &lt;head&gt;）。
body: 返回文档的主体元素 ...`,l:"audition/html/DOM.html#常用属性",a:"常用属性"},"5.20":{t:"Element getAttribute(name): 获取指定属性名对应的属性值。\r",p:`
setAttribute(name, value): 设置指定属性名的属性值。
hasAttribute(name): 检查是否存在指定属性名的属性。
removeAttribute(name):  ...`,l:"audition/html/DOM.html#element-getattribute-name-获取指定属性名对应的属性值。",a:"element-getattribute-name-获取指定属性名对应的属性值。"},"5.21":{t:"DOM元素对象属性\r",p:`DOM元素对象（Element）具有许多属性，用于访问和操作元素的不同方面。下面列举一些常见的属性：

classList：返回一个DOMTokenList对象，包含了元素的类名（class）列表，可 ...`,l:"audition/html/DOM.html#dom元素对象属性",a:"dom元素对象属性"},"5.22":{t:"DOM常见的操作有哪些\r",p:`
createElement，创建新元素
createTextNode，创建一个文本节点
createAttribute，创建属性节点，可以是自定义属性，setAttribute querySelec ...`,l:"audition/html/DOM.html#dom常见的操作有哪些",a:"dom常见的操作有哪些"},"5.23":{t:"window\r",p:`Window 对象是浏览器中的顶级对象，提供了许多常用的方法和属性。以下是一些常见的 Window 方法和属性：
`,l:"audition/html/DOM.html#window",a:"window"},"5.24":{t:"常用方法：\r",p:`
alert(message): 显示一个带有消息和确定按钮的对话框。
confirm(message): 显示一个带有消息、确定和取消按钮的对话框，并返回用户的选择结果。
prompt(messag ...`,l:"audition/html/DOM.html#常用方法",a:"常用方法"},"5.25":{t:"常用属性：\r",p:`
document: 获取当前窗口的 Document 对象，用于访问和操作文档的内容。
location: 获取或设置当前窗口的 URL 地址信息。
navigator: 获取关于浏览器的信息，如浏 ...`,l:"audition/html/DOM.html#常用属性",a:"常用属性"},"5.26":{t:"Event\r",p:"Event 是 JavaScript 中处理事件的基本对象。它代表了在 DOM 中发生的特定事件，可以包含有关事件的信息和方法。Event 对象的属性和方法可以用于事件处理、事件传播和事件信息的获取。 ...",l:"audition/html/DOM.html#event",a:"event"},"5.27":{t:"常用属性：\r",p:`
type：事件的类型，如 &quot;click&quot;、&quot;keydown&quot; 等。
target：触发事件的元素。
currentTarget：当前正在处理事件的元素。
ev ...`,l:"audition/html/DOM.html#常用属性",a:"常用属性"},"5.28":{t:"常用方法：\r",p:`
preventDefault()：取消事件的默认行为。
stopPropagation()：停止事件的传播，阻止事件进一步冒泡或捕获。
stopImmediatePropagation()：立即停止 ...`,l:"audition/html/DOM.html#常用方法",a:"常用方法"},"6.0":{t:"# html八股文\r",p:"\r",l:"audition/html/html.html",a:"html八股文"},"6.1":{t:"1. 什么是 DOCTYPE， 有何作用？\r",p:"Doctype是HTML5的文档声明，通过它可以告诉浏览器，使用哪一个HTML版本标准解析文档。在浏览器发展的过程中，HTML出现过很多版本，不同的版本之间格式书写上略有差异。如果没有事先告诉浏览器， ...",l:"audition/html/html.html#_1-什么是-doctype-有何作用",a:"_1-什么是-doctype-有何作用"},"6.2":{t:"2. title 与 h1 的区别、b 与 strong 的区别、i 与 em 的区别？\r",p:`
title 属性表示网页的标题，h1 元素则表示层次明确的页面内容标题，对页面信息的抓取也有很大的影响
strong 是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时：strong会重读，而 ...`,l:"audition/html/html.html#_2-title-与-h1-的区别、b-与-strong-的区别、i-与-em-的区别",a:"_2-title-与-h1-的区别、b-与-strong-的区别、i-与-em-的区别"},"6.3":{t:"3. 行内元素和块级元素分别有哪些？有何区别？怎样转换？\r",p:`常见的块级元素：p、div、form、ul、li、ol、table、h1、h2、h3、h4、h5、h6、dl、dt、dd
常见的行级元素：span、a、img、button、input、select
 ...`,l:"audition/html/html.html#_3-行内元素和块级元素分别有哪些-有何区别-怎样转换",a:"_3-行内元素和块级元素分别有哪些-有何区别-怎样转换"},"6.4":{t:"4. label的作用是什么？是怎么用的？\r",p:"label元素不会向用户呈现任何特殊效果，但是，它为鼠标用户改进了可用性，当我们在label元素内点击文本时就会触发此控件。也就是说，当用户选择该标签时，浏览器就会自动将焦点转到和标签相关的表单控件上 ...",l:"audition/html/html.html#_4-label的作用是什么-是怎么用的",a:"_4-label的作用是什么-是怎么用的"},"6.5":{t:"5. a元素除了用于导航外，还有什么作用？\r",p:"href属性中的url可以是浏览器支持的任何协议，所以a标签可以用来手机拨号&lt;a href=&quot;tel:110&quot;&gt;110&lt;/a&gt;，也可以用来发送短信&lt;a ...",l:"audition/html/html.html#_5-a元素除了用于导航外-还有什么作用",a:"_5-a元素除了用于导航外-还有什么作用"},"6.6":{t:"6. 你知道SEO中的TDK吗？\r",p:`在SEO中，TDK其实就是title、description、keywords这三个标签，title表示标题标签，description是描述标签，keywords是关键词标签
`,l:"audition/html/html.html#_6-你知道seo中的tdk吗",a:"_6-你知道seo中的tdk吗"},"6.7":{t:"7. 怎么处理HTML5新标签兼容问题？\r",p:`主要有两种方式：

实现标签被识别：通过document.createElement(tagName)方法可以让浏览器识别新的标签，浏览器支持新标签后。还可以为新标签添加CSS样式
用JavaScri ...`,l:"audition/html/html.html#_7-怎么处理html5新标签兼容问题",a:"_7-怎么处理html5新标签兼容问题"},"6.8":{t:"8. HTML5新增了哪些新特性？移除了哪些元素？\r",p:`HTML5主要是关于图像、位置、存储、多任务等功能的增加：

语义化标签，如：article、footer、header、nav等
视频video、音频audio
画布canvas
表单控件，cale ...`,l:"audition/html/html.html#_8-html5新增了哪些新特性-移除了哪些元素",a:"_8-html5新增了哪些新特性-移除了哪些元素"},"6.9":{t:"9. 网页的渲染\r",p:`
加载js然后html和css，设置defer和acync时js和html异步加载
html转换为dom，css转换为cssom
将DOM和CSSOM合并成一棵渲染render树
对渲染树进行refl ...`,l:"audition/html/html.html#_9-网页的渲染",a:"_9-网页的渲染"},"6.10":{t:"10. 渲染树\r",p:`
从根元素开始检查哪些元素可见，以及样式
忽略不可见的元素

display:none不占位置会忽略
visiabllity:hidden,position定位,obsity:0这三个占位置，不会忽略 ...`,l:"audition/html/html.html#_10-渲染树",a:"_10-渲染树"},"6.11":{t:"11. 重排(回流)，重绘\r",p:`
计算渲染树中的元素大小和位置
当页面中的元素的大小或位置发生变化，便会触发重排，
每次修改样式都会触发重排，重排非常耗费资源，开发尽量减少次数

`,l:"audition/html/html.html#_11-重排-回流-重绘",a:"_11-重排-回流-重绘"},"6.12":{t:"重绘\r",p:`当页面发生变化时浏览器会对页面重新绘制，不可避免
重排一定重绘，重绘不一定重排
`,l:"audition/html/html.html#重绘",a:"重绘"},"6.13":{t:"避免重排重绘\r",p:`
避免频繁使用 style，而是采用修改class的方式。
使⽤DocumentFragment
提升为合成层

合成层的位图，会交由 GPU 合成，⽐ CPU 处理要快
当需要 repaint 时， ...`,l:"audition/html/html.html#避免重排重绘",a:"避免重排重绘"},"6.14":{t:"12. 合成层\r",p:`
合成就是将页面的各个部分分成多个层，最后把它们合成为一个页面的技术
合成层拥有单独的图层，不影响其他图层，而其他不是合成层的渲染层，则和其第一个拥有图层(GraphicsLayer)的父层共用一个。 ...`,l:"audition/html/html.html#_12-合成层",a:"_12-合成层"},"6.15":{t:"触发合成层\r",p:`
使用CSS3硬件加速：将元素的属性设置为transform、opacity、filter、will-change等，浏览器会自动将这些元素创建为单独的合成层；设置 transform: transl ...`,l:"audition/html/html.html#触发合成层",a:"触发合成层"},"6.16":{t:"层压缩\r",p:`
层隐式合成的例子，可能简单的重叠就会产生大量的合成层，这样会占用很多无辜的 CPU 和 内存资源，严重影响了页面的性能。这一点浏览器也考虑到了，因此就有了层压缩（Layer Squashing）的处 ...`,l:"audition/html/html.html#层压缩",a:"层压缩"},"6.17":{t:"层爆炸\r",p:`
同合成层重叠也会使元素提升为合成层，虽然有浏览器的层压缩机制，但是也有很多无法进行压缩的情况。也就是说除了我们显式的声明的合成层，还可能由于重叠原因不经意间产生一些不在预期的合成层，极端一点可能会产 ...`,l:"audition/html/html.html#层爆炸",a:"层爆炸"},"6.18":{t:"13. 谈谈html语义化\r",p:`语义元素可以清楚地向浏览器和开发者描述其意义。即元素本身传达了关于标签所包含内容类型的一些信息。例如，当浏览器解析到标签时，它将该标签解释为包含这一块内容的最重要的标题。

非语义元素：&lt;div ...`,l:"audition/html/html.html#_13-谈谈html语义化",a:"_13-谈谈html语义化"},"6.19":{t:"为什么要语义化？\r",p:`
页面结构: 使页面没有css的情况下，也能够呈现出很好的内容结构
有利于SEO: 爬虫依赖标签来确定关键字的权重，因此可以帮助爬虫抓取更多的有效信息
提升用户体验： 例如title、alt可以用于解 ...`,l:"audition/html/html.html#为什么要语义化",a:"为什么要语义化"},"6.20":{t:"IFrame\r",p:"IFrame（Inline Frame）是HTML中的一个元素，可以在页面中嵌入另一个HTML文档或者网页。IFrame元素可以用来在当前页面中显示来自其他网站或者服务器的内容，也可以用来实现一些特殊 ...",l:"audition/html/html.html#iframe",a:"iframe"},"7.0":{t:"# SEO\r",p:"\r",l:"audition/html/SEO.html",a:"seo"},"7.1":{t:"什么是SEO\r",p:"SEO（Search Engine Optimization）:汉译为搜索引擎优化。搜索引擎优化是一种利用搜索引擎的搜索规则来提高目前网站在有关搜索引擎内的自然排名的方式。SEO是指为了从搜索引擎中获 ...",l:"audition/html/SEO.html#什么是seo",a:"什么是seo"},"7.2":{t:"优化的三要素\r",p:`
标题，言简意赅的体现出页面的主要内容
关键词，提升页面关键词密度
描述，用自然语言描述页面的主要内容

`,l:"audition/html/SEO.html#优化的三要素",a:"优化的三要素"},"7.3":{t:"TDK是搜索引擎判断页面主题内容的关键\r",p:`所以要在title里面言简意赅的体现出页面的主要内容，如果主体比较多，可以用一些符号把不同的主题词隔开，但是关键词不要太多，最多不要超过五个。
keywords里面把每个关键词用英文逗号隔开，三到五个 ...`,l:"audition/html/SEO.html#tdk是搜索引擎判断页面主题内容的关键",a:"tdk是搜索引擎判断页面主题内容的关键"},"7.4":{t:"提升页面关键词密度\r",p:"关键词密度。简单理解就是关键词在所有文字内容中出现的比例。提升关键词的密度，有利于提升搜索引擎针对对应关键词的搜索排名。通过站内的关键词链接指向网站内部的链接，通过这样的方式，还可以在不同的页面之间相 ...",l:"audition/html/SEO.html#提升页面关键词密度",a:"提升页面关键词密度"},"7.5":{t:"细枝末节但不可忽视的优化\r",p:`
页面上经常会有各种图片，对于搜索引擎来说，它是不识别图片上的内容的。你可能知道代码中img标签的alt属性是为了图片加载失败的时候，给用户看的。这个属性表明了这张图的内容。其实搜索引擎在分析页面的时 ...`,l:"audition/html/SEO.html#细枝末节但不可忽视的优化",a:"细枝末节但不可忽视的优化"},"8.0":{t:"# W3C标准\r",p:"\r",l:"audition/html/w3c.html",a:"w3c标准"},"8.1":{t:"概念\r",p:`web标准简单来说可以分为结构、表现和行为

结构，主要是有HTML标签组成
表现，即指css样式表
行为，主要是有js、dom组成

`,l:"audition/html/w3c.html#概念",a:"概念"},"8.2":{t:"体现\r",p:`
需要声明（DOCTYPE）
需要定义语言编码
JavaScript定义&lt;script&gt;
CSS定义&lt;style type=“text/css”&gt;和数量单位
不要在注释内容中使 ...`,l:"audition/html/w3c.html#体现",a:"体现"},"8.3":{t:"意义\r",p:`
标签规范可以提高搜索引擎对页面的抓取效率，对SEO（搜索引擎优化）很有帮助
尽量使用外链css样式表和js脚本：
结构、表现和行为分为三块，符合规范，同时提高页面渲染速度，提高用户的体验
样式尽量少 ...`,l:"audition/html/w3c.html#意义",a:"意义"},"9.0":{t:"# http\r",p:"\r",l:"audition/http/http协议.html",a:"http"},"9.1":{t:"HTTP概述\r",p:"HTTP ( HyperText Transfer Protocal)，全称为超文本传输协议。HTTP是一个客户端终端（用户）和服务器端（网站）请求和应答的标准。通常，由HTTP客户端发起一个请求，创 ...",l:"audition/http/http协议.html#http概述",a:"http概述"},"9.2":{t:"HTTP特点：\r",p:`
支持客户端、服务端模式
简单快速：客户向服务器请求服务时，只需要传送请求方法和路径。由于HTTP协议简单，使得通信速度比较快
灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content ...`,l:"audition/http/http协议.html#http特点",a:"http特点"},"9.3":{t:"TCP/IP\r",p:"TCP/IP（Transmission Control Protocol/Internet Protocol，传输控制协议/网际协议）是指能够在多个不同网络间实现信息传输的协议簇。TCP/IP协议不仅 ...",l:"audition/http/http协议.html#tcp-ip",a:"tcp-ip"},"9.4":{t:"tcp阻塞\r",p:`可能会发生阻塞的情况：

建立连接阻塞：在客户端请求建立连接时，如果服务器没有及时响应，客户端的连接请求可能会一直等待，导致阻塞。设置超时等待时间
数据传输阻塞：在数据传输过程中，如果网络拥塞或数据包 ...`,l:"audition/http/http协议.html#tcp阻塞",a:"tcp阻塞"},"9.5":{t:"HTTP与HTTPS的区别\r",p:"HTTP协议传输的数据都是未加密的，也就是明文的，可以用抓包工具直接抓下来并且可见，而HTTPS则是利用了网景公司设计的SSL（Secure Sockets Layer）协议对HTTP协议传输的数据进 ...",l:"audition/http/http协议.html#http与https的区别",a:"http与https的区别"},"9.6":{t:"ssl\r",p:`SSL（Secure Sockets Layer）是一种加密协议，用于在计算机网络上保证通信安全。它通过使用对称加密和非对称加密的组合来实现数据的机密性、完整性和身份验证。
SSL的工作原理：

客户 ...`,l:"audition/http/http协议.html#ssl",a:"ssl"},"9.7":{t:"对称加密\r",p:`对称加密是一种加密方式，使用相同的密钥对数据进行加密和解密。
`,l:"audition/http/http协议.html#对称加密",a:"对称加密"},"9.8":{t:"非对称加密\r",p:`非对称加密使用一对密钥：公钥和私钥。公钥用于加密数据，而私钥用于解密数据。
`,l:"audition/http/http协议.html#非对称加密",a:"非对称加密"},"9.9":{t:"HTTP1.0与HTTP2.0的区别\r",p:`HTTP 2.0 的出现，相比于 HTTP 1.x ，大幅度的提升了 web 性能

HTTP/2是HTTP/1.1的升级版本，于2015年发布。它引入了一些重要的改进，其中最显著的是多路复用（mul ...`,l:"audition/http/http协议.html#http1-0与http2-0的区别",a:"http1-0与http2-0的区别"},"9.10":{t:"多路复用\r",p:"多路复用允许在单个TCP连接上同时发送多个请求和响应`，从而提高性能并减少延迟。这对于加载复杂网页或处理大量资源请求时特别有用。\n",l:"audition/http/http协议.html#多路复用",a:"多路复用"},"9.11":{t:" 头部压缩：\r",p:`使用了HPACK压缩算法，它采用了动态表和静态表的方式来减少头部信息的大小

动态表和静态表：在客户端和服务器之间维护了一个动态表和一个静态表，这些表中包含了一些常用的头部字段和值。静态表是在协议中预 ...`,l:"audition/http/http协议.html#头部压缩",a:"头部压缩"},"9.12":{t:"服务器推送\r",p:`服务器可以根据当前请求和之前的请求历史预测客户端可能需要的资源，并在客户端请求这些资源之前将它们推送给客户端,客户端可以拒绝接收推送的资源，或者已经缓存了相同资源的情况下，可以忽略服务器推送。
`,l:"audition/http/http协议.html#服务器推送",a:"服务器推送"},"9.13":{t:"CDN\r",p:`CDN就是根据用户位置分配最近的资源,用户在上网的时候不用直接访问源站，访问离他“最近的”一个 CDN 节点，术语叫边缘节点，其实就是缓存了源站内容的代理服务器
应用CDN后，DNS 返回的不再是 I ...`,l:"audition/http/http协议.html#cdn",a:"cdn"},"9.14":{t:"URL的组成\r",p:`协议+主机名+路径+参数
`,l:"audition/http/http协议.html#url的组成",a:"url的组成"},"9.15":{t:"HTTP请求\r",p:"",l:"audition/http/http协议.html#http请求",a:"http请求"},"9.16":{t:"请求行\r",p:`请求行包括三个方面：请求方法、请求地址、协议版本



方法名
功能




GET
向指定的资源发出“显示”请求，使用 GET 方法应该只用在读取数据上，而不应该用于产生“副作用”的操作中


PO ...`,l:"audition/http/http协议.html#请求行",a:"请求行"},"9.17":{t:"GET与POST的区别：\r",p:`
GET：一般用于信息获取，使用URL传递参数并且可见，传递参数数量有限
POST：一般用于提交数据，参数不可见，传递参数数量无限制

注意：
安全性讲，get和post都一样，没啥所谓的哪个更安全, ...`,l:"audition/http/http协议.html#get与post的区别",a:"get与post的区别"},"9.18":{t:"什么情况下使用POST请求：\r",p:`
无法使用缓存文件（更新服务器上的文件或数据库），GET能请求缓存，POST不能
向服务器发送大量数据（POST 没有数据量限制）
发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
 ...`,l:"audition/http/http协议.html#什么情况下使用post请求",a:"什么情况下使用post请求"},"9.19":{t:"请求头\r",p:`请求头可用于传递一些附加信息，格式为：键: 值，注意，冒号后面有一个空格：

常见的请求 Header：




名称
作用




Authorization
用于设置身份认证信息


User-A ...`,l:"audition/http/http协议.html#请求头",a:"请求头"},"9.20":{t:"请求体\r",p:"请求体（又叫请求正文）是 post 请求方式中的请求参数，以 key = value 形式进行存储，多个请求参数之间用&amp;连接，如果请求当中请求体，那么在请求头当中的 Content-Lengt ...",l:"audition/http/http协议.html#请求体",a:"请求体"},"9.21":{t:"HTTP响应\r",p:`HTTP响应报文分为三个部分：响应状态行，响应头，响应体
`,l:"audition/http/http协议.html#http响应",a:"http响应"},"9.22":{t:"响应状态行\r",p:`


状态码
对应的信息




1XX
提示信息—表示请求已接收，继续处理


2XX
用于表示请求已被成功接收、理解、接收


3XX
用于表示资源（网页等）被永久转移到其它 URL，也就是所谓的 ...`,l:"audition/http/http协议.html#响应状态行",a:"响应状态行"},"9.23":{t:"常见状态码\r",p:`
2XX 成功

200   （成功）  服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。
201   （已创建）  请求成功并且服务器创建了新的资源。
202   （已接受）  服务器 ...`,l:"audition/http/http协议.html#常见状态码",a:"常见状态码"},"9.24":{t:"响应头 响应体\r",p:"\r",l:"audition/http/http协议.html#响应头-响应体",a:"响应头-响应体"},"9.25":{t:"浏览器输入url按回车背后经历了哪些\r",p:`参考这篇博文

URL 解析
DNS 查询(获取网站的ip地址，向 DNS 服务器发送查询请求，通过网址获取ip地址)
TCP 连接
客户端向服务器发请求(http协议)
服务器处理请求，返回响应(h ...`,l:"audition/http/http协议.html#浏览器输入url按回车背后经历了哪些",a:"浏览器输入url按回车背后经历了哪些"},"9.26":{t:"URL 解析\r",p:`
地址解析,首先判断你输入的是一个合法的 URL 还是一个待搜索的关键词，并且根据你输入的内容进行自动完成、字符编码等操作。
会使用 HSTS 强制客户端使用 HTTPS 访问页面
浏览器还会进行一些 ...`,l:"audition/http/http协议.html#url-解析",a:"url-解析"},"9.27":{t:"DNS 查询\r",p:`
浏览器缓存,浏览器会先检查是否在缓存中，没有则调用系统库函数进行查询。
操作系统缓存,操作系统也有自己的 DNS缓存，但在这之前，会向检查域名是否存在本地的 Hosts 文件里，没有则向 DNS 服 ...`,l:"audition/http/http协议.html#dns-查询",a:"dns-查询"},"9.28":{t:"计算机网络五层七层协议\r",p:`五层协议模型（TCP/IP协议模型）：

物理层（Physical Layer）：负责传输数据的物理媒介，如电缆、光纤等。
数据链路层（Data Link Layer）：在直接连接的节点之间传输数据， ...`,l:"audition/http/http协议.html#计算机网络五层七层协议",a:"计算机网络五层七层协议"},"9.29":{t:"处理请求\r",p:`服务器处理收到的请求，将数据返回至浏览器
`,l:"audition/http/http协议.html#处理请求",a:"处理请求"},"9.30":{t:"浏览器收到HTTP响应\r",p:`浏览器解码响应，如果响应可以缓存，则存入缓存。
`,l:"audition/http/http协议.html#浏览器收到http响应",a:"浏览器收到http响应"},"9.31":{t:"渲染页面\r",p:"\r",l:"audition/http/http协议.html#渲染页面",a:"渲染页面"},"9.32":{t:"TCP 建立连接是三次握手，而断开连接是四次挥手。\r",p:"",l:"audition/http/http协议.html#tcp-建立连接是三次握手-而断开连接是四次挥手。",a:"tcp-建立连接是三次握手-而断开连接是四次挥手。"},"9.33":{t:"三次握手\r",p:"三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化 ...",l:"audition/http/http协议.html#三次握手",a:"三次握手"},"9.34":{t:"四次挥手\r",p:`TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，客户端或服务器均可主动发起挥手动作。

第一次挥手：客户端发送一个 FIN 报文，等待服务端的确认。此时客 ...`,l:"audition/http/http协议.html#四次挥手",a:"四次挥手"},"9.35":{t:"ip\r",p:`IP（Internet Protocol）是用于在网络中标识和定位设备的地址。在 IP 地址中，有内网 IP 和公网 IP，同时还有子网掩码用于定义 IP 地址的网络部分和主机部分。
`,l:"audition/http/http协议.html#ip",a:"ip"},"9.36":{t:"tcp和udp\r",p:"TCP（Transmission Control Protocol）和 UDP（User Datagram Protocol）是两种在计算机网络中常用的传输层协议，它们在数据传输方式、可靠性、连接性等 ...",l:"audition/http/http协议.html#tcp和udp",a:"tcp和udp"},"9.37":{t:"HTTP无状态的协议\r",p:`HTTP（Hypertext Transfer Protocol）是一种无状态的协议。
无状态指的是在每个独立的 HTTP 请求之间，服务器不会保留任何关于客户端的状态信息。每个请求都是独立的，服务器 ...`,l:"audition/http/http协议.html#http无状态的协议",a:"http无状态的协议"},"9.38":{t:"cookie、session、token\r",p:`Web应用程序中管理用户认证和授权的机制
Cookie：Cookie 是一种存储在客户端（通常是浏览器）的小型文本文件，由服务器通过 HTTP 响应头设置并发送给客户端。浏览器会在后续的请求中将 Co ...`,l:"audition/http/http协议.html#cookie、session、token",a:"cookie、session、token"},"9.39":{t:"进程和线程\r",p:`进程和线程是操作系统中用于执行任务的两个基本概念。
进程（Process）是指正在执行的程序的实例。
线程（Thread）是进程中的执行单元。一个进程可以拥有多个线程，
`,l:"audition/http/http协议.html#进程和线程",a:"进程和线程"},"10.0":{t:"# 安全\r",p:"",l:"audition/http/web安全.html",a:"安全"},"10.1":{t:"xss\r",p:`XSS（Cross-Site Scripting）在受害者的浏览器中注入恶意脚本，盗取存储在客户端的cookie或者其他网站用于识别客户端身份的敏感信息。
XSS 攻击通常可以分为三种类型：

反射型 ...`,l:"audition/http/web安全.html#xss",a:"xss"},"10.2":{t:"web安全有哪些方面\r",p:`Web安全是指保护Web应用程序和Web服务器免受各种安全威胁的一系列措施。Web安全覆盖了很多方面，包括但不限于以下几个方面：

身份认证和授权：身份认证是验证用户身份的过程，而授权是确定用户是否有 ...`,l:"audition/http/web安全.html#web安全有哪些方面",a:"web安全有哪些方面"},"10.3":{t:"CSRF和XSS\r",p:`CSRF（Cross-Site Request Forgery）和XSS（Cross-Site Scripting）都是常见的安全漏洞，存在于 Web 应用程序中。
CSRF 是一种攻击方式，攻击者通 ...`,l:"audition/http/web安全.html#csrf和xss",a:"csrf和xss"},"10.4":{t:"CSRF（Cross-Site Request Forgery）跨站请求伪造\r",p:`CSRF（Cross-Site Request Forgery）攻击通常通过以下步骤实施：

攻击者创建恶意网页：攻击者创建一个包含恶意代码的网页，其中包含对目标网站的请求。
用户访问恶意网页：攻击者 ...`,l:"audition/http/web安全.html#csrf-cross-site-request-forgery-跨站请求伪造",a:"csrf-cross-site-request-forgery-跨站请求伪造"},"10.5":{t:"防范 CSRF 攻击的措施：\r",p:`
验证来源，CSRF令牌：在每个用户请求中包含一个随机生成的CSRF令牌，并在服务器端进行验证。只有在令牌验证通过的情况下，才执行请求。
启用 SameSite 属性：设置 Cookie 的 Same ...`,l:"audition/http/web安全.html#防范-csrf-攻击的措施",a:"防范-csrf-攻击的措施"},"10.6":{t:"防范 XSS 攻击的措施：\r",p:`
输入验证和过滤：对于用户输入的数据，进行输入验证和过滤，确保只接受符合预期格式的数据
输出转义：在将用户输入的数据输出到网页时，进行合适的转义，将特殊字符转换为其对应的 HTML 实体，避免被解释为 ...`,l:"audition/http/web安全.html#防范-xss-攻击的措施",a:"防范-xss-攻击的措施"},"10.7":{t:"SQL注入\r",p:`Sql 注入攻击，是通过将恶意的 Sql查询或添加语句插入到应用的输入参数中，再在后台 Sql服务器上解析执行进行的攻击
`,l:"audition/http/web安全.html#sql注入",a:"sql注入"},"11.0":{t:"# javaSE\r",p:"\r",l:"audition/java/javaSE.html",a:"javase"},"11.1":{t:"JDK/JRE/JVM三者的关系\r",p:`
JVM,英文名称（Java Virtual Machine），就是我们耳熟能详的 Java 虚拟机。
JRE,英文名称（Java Runtime Environment），就是Java 运行时环境。 ...`,l:"audition/java/javaSE.html#jdk-jre-jvm三者的关系",a:"jdk-jre-jvm三者的关系"},"11.2":{t:"面向对象的特性\r",p:`
封装就是将类的信息隐藏在类内部，不允许外部程序直接访问，而是通过该类的方法实现对隐藏信息的操作和访问。 减少耦合。
继承是从已有的类中派生出新的类，新的类继承父类的属性和行为，并能扩展新的能力，大大 ...`,l:"audition/java/javaSE.html#面向对象的特性",a:"面向对象的特性"},"11.3":{t:"基本数据类型\r",p:`


简单类型
boolean
byte
char
short
Int
long
float
double




二进制位数
1
8
16
16
32
64
32
64


包装类
Boolean
 ...`,l:"audition/java/javaSE.html#基本数据类型",a:"基本数据类型"},"11.4":{t:"为什么不能用浮点型表示金额？\r",p:`由于计算机中保存的小数其实是十进制的小数的近似值，并不是准确值，所以，千万不要在代码中使用浮点数来表示金额等重要的指标。
建议使用BigDecimal或者Long来表示金额。
`,l:"audition/java/javaSE.html#为什么不能用浮点型表示金额",a:"为什么不能用浮点型表示金额"},"11.5":{t:"了解Java的包装类型吗？为什么需要包装类？\r",p:`

Java 是一种面向对象语言，很多地方都需要使用对象而不是基本数据类型。比如，在集合类中，我们是无法将 int 、double 等类型放进去的。因为集合的容器要求元素是 Object 类型。


 ...`,l:"audition/java/javaSE.html#了解java的包装类型吗-为什么需要包装类",a:"了解java的包装类型吗-为什么需要包装类"},"11.6":{t:"自动装箱和拆箱\r",p:`
装箱：将基础类型转化为包装类型。
拆箱：将包装类型转化为基础类型。

当基础类型与它们的包装类有如下几种情况时，编译器会自动帮我们进行装箱或拆箱：

赋值操作（装箱或拆箱）
进行加减乘除混合运算 （ ...`,l:"audition/java/javaSE.html#自动装箱和拆箱",a:"自动装箱和拆箱"},"11.7":{t:"String 为什么不可变？\r",p:`
String对象其实在内部就是一个个字符，存储在这个value数组里面的。value数组用final修饰，final 修饰的变量，值不能被修改。因此value不可以指向其他对象。
String类内部 ...`,l:"audition/java/javaSE.html#string-为什么不可变",a:"string-为什么不可变"},"11.8":{t:"String, StringBuffer 和 StringBuilder区别\r",p:`
可变性

String 不可变
StringBuffer 和 StringBuilder 可变


线程安全

String 不可变，因此是线程安全的
StringBuilder 不是线程安全的
S ...`,l:"audition/java/javaSE.html#string-stringbuffer-和-stringbuilder区别",a:"string-stringbuffer-和-stringbuilder区别"},"11.9":{t:'new String("dabin")会创建几个对象？\r',p:`
使用这种方式会创建两个字符串对象（前提是字符串常量池中没有 &quot;dabin&quot; 这个字符串对象）。&quot;dabin&quot; 属于字符串字面量，因此编译时期会在字符串常量池中 ...`,l:"audition/java/javaSE.html#new-string-dabin-会创建几个对象",a:"new-string-dabin-会创建几个对象"},"11.10":{t:"什么是字符串常量池？字符串常量池（String Pool）\r",p:"保存着所有字符串字面量，这些字面量在编译时期就确定。字符串常量池位于堆内存中，专门用来存储字符串常量。在创建字符串时，JVM首先会检查字符串常量池，如果该字符串已经存在池中，则返回其引用，如果不存在， ...",l:"audition/java/javaSE.html#什么是字符串常量池-字符串常量池-string-pool",a:"什么是字符串常量池-字符串常量池-string-pool"},"11.11":{t:"两个对象的hashCode()相同，则 equals()是否也一定为 true？\r",p:`
equals与hashcode的关系：如果两个对象调用equals比较返回true，那么它们的hashCode值一定要相同；
如果两个对象的hashCode相同，它们并不一定相同。
hashcode ...`,l:"audition/java/javaSE.html#两个对象的hashcode-相同-则-equals-是否也一定为-true",a:"两个对象的hashcode-相同-则-equals-是否也一定为-true"},"11.12":{t:"static\r",p:`可以修饰成员变量，也可以修饰成员方法。
特点：

被类的所有对象共享
可以通过类名调用
随着类的加载而加载，优先于对象存在,用类名调用时不需要先创建类

public class Student {
 ...`,l:"audition/java/javaSE.html#static",a:"static"},"11.13":{t:"main\r",p:`public  被jvm调用
`,l:"audition/java/javaSE.html#main",a:"main"},"11.14":{t:"继承extends 子和父变量重名时，要用`super.变量`调用父的变量\r",p:`public class father extends person {
    int age = 20;
    double salary;
    public void methods(){ ...`,l:"audition/java/javaSE.html#继承extends-子和父变量重名时-要用-super-变量-调用父的变量",a:"继承extends-子和父变量重名时-要用-super-变量-调用父的变量"},"11.15":{t:"权限修饰符\r",p:`
从小到大
private -&gt; (default) -&gt; protected -&gt; public




权限修饰符
同一个类
同一个包
不同包的子类
不同包的无关类




pr ...`,l:"audition/java/javaSE.html#权限修饰符",a:"权限修饰符"},"11.16":{t:"final\r",p:`
父类重要的方法final修饰，不能被子类继承
最终方法，最终类
基本数据类型变量不能被改变，引用数据类型地址不能改变内容可以改变
final修饰成员变量时，不允许修饰默认值

`,l:"audition/java/javaSE.html#final",a:"final"},"11.17":{t:"抽象类\r",p:`
特殊的父类
内部允许编写抽象方法
将共性的方法，抽取到父类之后，发现这个方法在父类中无法给出具体明确，而且这个方法还是子类必须要有的方法，就可以设计为抽象方法
抽象类的子类要强制重写父类的抽象方法， ...`,l:"audition/java/javaSE.html#抽象类",a:"抽象类"},"11.18":{t:"接口\r",p:`
接口体现的思想就是声明规则
一个类的所有组成都是抽象方法，这种类会设计成接口，这个类存在的唯一价值就只是声明规则
不允许实例化，找类来实现接口

public class interfaceTest ...`,l:"audition/java/javaSE.html#接口",a:"接口"},"11.19":{t:"接口和类的关系\r",p:`
类和类之间：继承关系，单继承，多层继承，不可多继承
类和接口之间：单实现，多实现，可以在继承的同时实现多个接口
接口和接口之间：可以单继承，多继承

public class interfaceTe ...`,l:"audition/java/javaSE.html#接口和类的关系",a:"接口和类的关系"},"11.20":{t:"抽象类和接口的对比\r",p:`



成员变量
成员方法
构造方法




抽象类
可以定义变量也可以定义常量
可以定义具体方法也可以定义抽象方法
有


接口
只能定义常量
只能定义抽象方法
没有



抽象类是对事物进行描述， ...`,l:"audition/java/javaSE.html#抽象类和接口的对比",a:"抽象类和接口的对比"},"11.21":{t:"多态\r",p:`同一个行为具有多个表现形式或形态的能力

对象多态，方法的形参定义为父类型，这个方法就可以接受到该父类的任意子类对象
行为多态，同一个方法有多中的表现形式，或形态的能力

package com.hi ...`,l:"audition/java/javaSE.html#多态",a:"多态"},"11.22":{t:"多态的转型\r",p:`
向上转型

Fu f = new Zi();


向下转型

Zi z = (Zi)f;  //强转  

`,l:"audition/java/javaSE.html#多态的转型",a:"多态的转型"},"11.23":{t:"代码块\r",p:`
局部代码块，可以限定变量的生命周期，提早释放内存
构造代码块，在创建方法执行构造方法的时候，会执行构造代码块,比类的方法优先制性
静态代码块，在构造代码块前加static，类只加载一次，在最开始执行 ...`,l:"audition/java/javaSE.html#代码块",a:"代码块"},"11.24":{t:"内部类\r",p:`class Outer {
    int num = 40;
    public void method(){
        System.out.println(&quot;33&quot;) ...`,l:"audition/java/javaSE.html#内部类",a:"内部类"},"11.25":{t:"BigDecimal\r",p:`
用于解决小数运算中，出现的不精确的问题

public BigDecimal(double value)   //无法保证小数的精度
public BigDecimal(String value)  ...`,l:"audition/java/javaSE.html#bigdecimal",a:"bigdecimal"},"11.26":{t:"正则匹配\r",p:`

[]:       匹配单个字符


[a,b,c]   只能是a、b、c


[^abc]    除了abc外的


.	       匹配所有单个字符，除了换行符（Linux 中换行是 \\n， ...`,l:"audition/java/javaSE.html#正则匹配",a:"正则匹配"},"11.27":{t:" ",p:"",l:"audition/java/javaSE.html#",a:""},"11.28":{t:"throws && throw\r",p:`throws，写在方法调用处，表示声明一个异常
throw，写在方法内，结束方法，手动抛出异常，之后的代码不再执行
`,l:"audition/java/javaSE.html#throws-throw",a:"throws-throw"},"12.0":{t:"# Maven\r",p:"\r",l:"audition/java/Maven.html",a:"maven"},"12.1":{t:"生命周期\r",p:`clean:一出上一次构建生成的文件
default：
compile：编译项目源代码
test：使用合适的单元测试框架运行测试
package：将编译后的文件打包
install：安装项目到本地仓库 ...`,l:"audition/java/Maven.html#生命周期",a:"生命周期"},"13.0":{t:"# mybatis\r",p:"\r",l:"audition/java/mybatis.html",a:"mybatis"},"13.1":{t:"数据库连接池\r",p:`
是个容器，负责管理分配数据库连接
允许重复使用一个现有的数据库连接，而不是在建立一个
释放空闲时间超过最大空闲时间的连接

标准接口 DateSource
`,l:"audition/java/mybatis.html#数据库连接池",a:"数据库连接池"},"13.2":{t:"XML命名规范\r",p:`
id要与接口中的方法名一致
XML文件的名称与接口名称一致，放在同包同名下
namespace属性与接口名一致

`,l:"audition/java/mybatis.html#xml命名规范",a:"xml命名规范"},"13.3":{t:"动态SQL\r",p:`公共配置部分
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        ...`,l:"audition/java/mybatis.html#动态sql",a:"动态sql"},"14.0":{t:"# mysql\r",p:`关系型数据库，建立在关系模型基础上，由多张相互连接的二维表组成的数据库

创建
create database mydatebase
删除
drop database mydatebase
查询

s ...`,l:"audition/java/mysql.html",a:"mysql"},"14.1":{t:"SQL语句被分为四大类\r",p:`
DDL 数据定义语言
DML 数据操作语言
DQL 数据查询语言
DCL 数据控制语言

`,l:"audition/java/mysql.html#sql语句被分为四大类",a:"sql语句被分为四大类"},"14.2":{t:"DDL\r",p:`创建
create table tb_user(
    id int comment 'ID, 唯一表示',
    username varchar(20) comment '用户名',
     ...`,l:"audition/java/mysql.html#ddl",a:"ddl"},"14.3":{t:"常见数据类型\r",p:`tinyint   1
smallint    2
mediumint   3
int 4
bigint  8
float   4
double  8
decimal
char  定长字符串
varc ...`,l:"audition/java/mysql.html#常见数据类型",a:"常见数据类型"},"14.4":{t:"DML语法\r",p:`
增

# 插入字段
insert into tb_emp(username,name,gender,create_time,update_time) values ('sst','吕江涛',1,no ...`,l:"audition/java/mysql.html#dml语法",a:"dml语法"},"14.5":{t:"DQL\r",p:`
select  字段列表
from 表名列表
where 条件列表
group by    分组字段列表
having 分组后条件列表
order by 排序字段列表
limit 分页参数

`,l:"audition/java/mysql.html#dql",a:"dql"},"14.6":{t:"DQL基本查询\r",p:`select、from
select name,entrydate from tb_emp;

select id, username, password, name, gender, image,  ...`,l:"audition/java/mysql.html#dql基本查询",a:"dql基本查询"},"14.7":{t:"where和having的区别\r",p:`
执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组之后对结果进行过滤
判断条件不同：where不能对聚合函数进行判断，而having可以

`,l:"audition/java/mysql.html#where和having的区别",a:"where和having的区别"},"14.8":{t:"执行顺序\r",p:`where &gt; 聚合函数 &gt; having
`,l:"audition/java/mysql.html#执行顺序",a:"执行顺序"},"14.9":{t:"排序查询\r",p:`select from tb_emp order by entrydate asc ; -- 升序默认

select from tb_emp order by entrydate desc;

se ...`,l:"audition/java/mysql.html#排序查询",a:"排序查询"},"14.10":{t:"分页查询\r",p:`select from tb_emp limit 0,2;

select * from tb_emp limit 2,1;


起始索引从0开始 起始索引 = （查询页码-1）*每页显示记录数
my ...`,l:"audition/java/mysql.html#分页查询",a:"分页查询"},"14.11":{t:"多表\r",p:`
外键关联一对一，基本都用逻辑外连接

constraint fk_user_id foreign key (user_id) references tb_user(id);


逻辑外连接
字段名写 ...`,l:"audition/java/mysql.html#多表",a:"多表"},"14.12":{t:"多表查询\r",p:`
内连接

select tb_dept.name,tb_emp.name from tb_dept,tb_emp where tb_dept.id = tb_emp.id;

select * fr ...`,l:"audition/java/mysql.html#多表查询",a:"多表查询"},"14.13":{t:"多表查询案例\r",p:`-- 多表查询
-- 查询价格低于10元的菜品name，price，和对应的菜品分类名称
select d.name,d.price,(select name from category where  ...`,l:"audition/java/mysql.html#多表查询案例",a:"多表查询案例"},"14.14":{t:"事务\r",p:`-- 开启事务
start transaction  -- begin

-- 执行删除操作
delete from tb_dept where id = 1;

-- 提交事务
commit;

- ...`,l:"audition/java/mysql.html#事务",a:"事务"},"14.15":{t:"索引\r",p:`结构：
默认B+Tree（多路平衡搜索树）结构组织索引
为什么不用二叉树或者红黑树：大数据量情况下，层级深，检索速度越慢
-- 创建
create index idx_emp_name on tb_e ...`,l:"audition/java/mysql.html#索引",a:"索引"},"15.0":{t:"# sringBoot\r",p:`\r
\r`,l:"audition/java/springBoot.html",a:"sringboot"},"15.1":{t:"http\r",p:` \r
\r
\r`,l:"audition/java/springBoot.html#http",a:"http"},"15.2":{t:"解耦\r",p:`server层及Dao层的实现类交给IOC容器管理，添加注解@component
为Controller及Service主图运行时依赖的对象,添加注解@Autowired
Bean的声明，要把某个对象 ...`,l:"audition/java/springBoot.html#解耦",a:"解耦"},"15.3":{t:"AOP\r",p:`面向切面编程，面向方面编程，面向特定方法编程
连接点：JoinPoint，可以被AOP控制的方法
通知：Advice，那些重复的逻辑，也就是共性功能
切入点：PointCut，匹配连接点的条件，通知仅 ...`,l:"audition/java/springBoot.html#aop",a:"aop"},"15.4":{t:"AOP通知的类型\r",p:`
@Around：环绕通知，在目标方法前后执行
@Before：前置通知，在目标方法前执行
@After：后置通知，在目标方法后执行，无论是否有异常都会执行
@AfterReturning：返回后通知 ...`,l:"audition/java/springBoot.html#aop通知的类型",a:"aop通知的类型"},"15.5":{t:"AOP通知的顺序，多个切面类的执行顺序\r",p:`
和类名自动排序有关
运行前类名越靠前AOP越先执行，运行后类名越靠后AOP越先执行
可用@Order(num)控制执行顺序

`,l:"audition/java/springBoot.html#aop通知的顺序-多个切面类的执行顺序",a:"aop通知的顺序-多个切面类的执行顺序"},"15.6":{t:"spring获取Bean对象\r",p:`
默认情况下，项目启动时，会把bean都创建好放在ioc容器中

`,l:"audition/java/springBoot.html#spring获取bean对象",a:"spring获取bean对象"},"15.7":{t:"springboot原理\r",p:`

起步依赖，maven的依赖传递


自动配置：原理

@SpringBootApplication，工程引导类，三部分组成

@SpringBootConfiguration，与@Configur ...`,l:"audition/java/springBoot.html#springboot原理",a:"springboot原理"},"16.0":{t:"# 1 线程状态\r",p:"\r",l:"audition/java/多线程.html",a:"_1-线程状态"},"16.1":{t:"1.1 状态介绍\r",p:`当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。线程对象在不同的时期有不同的状态。那么Java中的线程存在哪几种状态呢？Java中的线程
状态被定义在了java.lan ...`,l:"audition/java/多线程.html#_1-1-状态介绍",a:"_1-1-状态介绍"},"16.2":{t:"1.2 案例演示\r",p:`为了验证上面论述的状态即状态转换的正确性，也为了加深对线程状态转换的理解，下面通过三个案例演示线程间中的状态转换。
`,l:"audition/java/多线程.html#_1-2-案例演示",a:"_1-2-案例演示"},"16.3":{t:"1.2.1 案例一\r",p:`本案例主要演示TIME_WAITING的状态转换。
需求：编写一段代码，依次显示一个线程的这些状态：NEW -&gt; RUNNABLE -&gt; TIME_WAITING -&gt; RUNNAB ...`,l:"audition/java/多线程.html#_1-2-1-案例一",a:"_1-2-1-案例一"},"16.4":{t:"1.2.2 案例二\r",p:`本案例主要演示WAITING的状态转换。
需求：编写一段代码，依次显示一个线程的这些状态：NEW -&gt; RUNNABLE -&gt; WAITING -&gt; RUNNABLE -&gt; T ...`,l:"audition/java/多线程.html#_1-2-2-案例二",a:"_1-2-2-案例二"},"16.5":{t:"1.2.3 案例三\r",p:`本案例主要演示BLOCKED的状态转换。
需求：编写一段代码，依次显示一个线程的这些状态：NEW -&gt; RUNNABLE -&gt; BLOCKED -&gt; RUNNABLE -&gt; T ...`,l:"audition/java/多线程.html#_1-2-3-案例三",a:"_1-2-3-案例三"},"16.6":{t:"2.1 概述\r",p:`提到池，大家应该能想到的就是水池。水池就是一个容器，在该容器中存储了很多的水。那么什么是线程池呢？线程池也是可以看做成一个池子，在该池子中存储很多个线程。
线程池存在的意义：
系统创建一个线程的成本是 ...`,l:"audition/java/多线程.html#_2-1-概述",a:"_2-1-概述"},"16.7":{t:"2.2 自定义线程池\r",p:"\r",l:"audition/java/多线程.html#_2-2-自定义线程池",a:"_2-2-自定义线程池"},"16.8":{t:"2.2.1 线程池的设计思路\r",p:`线程池的思路和生产者消费者模型是很接近的

准备一个任务容器
一次性启动多个(2个)消费者线程
刚开始任务容器是空的，所以线程都在wait
直到一个外部线程向这个任务容器中扔了一个&quot;任务&q ...`,l:"audition/java/多线程.html#_2-2-1-线程池的设计思路",a:"_2-2-1-线程池的设计思路"},"16.9":{t:"2.2.2 代码实现\r",p:`实现思路：

创建一个线程池类(ThreadPool)
在该类中定义两个成员变量poolSize(线程池初始化线程的个数) , BlockingQueue&lt;Runnable&gt;(任务容器)
 ...`,l:"audition/java/多线程.html#_2-2-2-代码实现",a:"_2-2-2-代码实现"},"16.10":{t:"2.3 JDK中线程池\r",p:"\r",l:"audition/java/多线程.html#_2-3-jdk中线程池",a:"_2-3-jdk中线程池"},"16.11":{t:"2.3.1 Executors\r",p:`JDK对线程池也进行了相关的实现，在真实企业开发中我们也很少去自定义线程池，而是使用JDK中自带的线程池。
我们可以使用Executors中所提供的静态方法来创建线程池。
&lt;font color ...`,l:"audition/java/多线程.html#_2-3-1-executors",a:"_2-3-1-executors"},"16.12":{t:"2.3.2 ThreadPoolExecutor\r",p:"\r",l:"audition/java/多线程.html#_2-3-2-threadpoolexecutor",a:"_2-3-2-threadpoolexecutor"},"16.13":{t:"1) 基本使用\r",p:`刚才我们是通过Executors中的静态方法去创建线程池的，通过查看源代码我们发现，其底层都是通过ThreadPoolExecutor构建的。比如：newFixedThreadPool方法的源码
pu ...`,l:"audition/java/多线程.html#_1-基本使用",a:"_1-基本使用"},"16.14":{t:"2) 工作原理\r",p:`接下来我们就来研究一下线程池的工作原理，如下图所示
!1571732060388
当我们通过submit方法向线程池中提交任务的时候，具体的工作流程如下：

客户端每次提交一个任务，线程池就会在核心线 ...`,l:"audition/java/多线程.html#_2-工作原理",a:"_2-工作原理"},"16.15":{t:"3) 案例演示\r",p:`接下来我们就通过一段代码的断点测试，来演示一下线程池的工作原理。
案例代码
public class ThreadPoolExecutorDemo01 {

    public static voi ...`,l:"audition/java/多线程.html#_3-案例演示",a:"_3-案例演示"},"16.16":{t:"4) 任务拒绝策略\r",p:`RejectedExecutionHandler是jdk提供的一个任务拒绝策略接口，它下面存在4个子类。
ThreadPoolExecutor.AbortPolicy: 		    丢弃任务并抛出Re ...`,l:"audition/java/多线程.html#_4-任务拒绝策略",a:"_4-任务拒绝策略"},"16.17":{t:"3.1 看程序说结果\r",p:`分析如下程序，说出在控制台的输出结果。
Thread的子类
public class VolatileThread extends Thread {

    // 定义成员变量
    privat ...`,l:"audition/java/多线程.html#_3-1-看程序说结果",a:"_3-1-看程序说结果"},"16.18":{t:"3.2 JMM\r",p:`概述：JMM(Java Memory Model)Java内存模型,是java虚拟机规范中所定义的一种内存模型。
Java内存模型(Java Memory Model)描述了Java程序中各种变量(线 ...`,l:"audition/java/多线程.html#_3-2-jmm",a:"_3-2-jmm"},"16.19":{t:"3.3 问题分析\r",p:`了解了一下JMM,那么接下来我们就来分析一下上述程序产生问题的原因。
!1571744627663
产生问题的流程分析：


VolatileThread线程从主内存读取到数据放入其对应的工作内存

 ...`,l:"audition/java/多线程.html#_3-3-问题分析",a:"_3-3-问题分析"},"16.20":{t:"3.4 问题处理\r",p:"\r",l:"audition/java/多线程.html#_3-4-问题处理",a:"_3-4-问题处理"},"16.21":{t:"3.4.1 加锁\r",p:`第一种处理方案，我们可以通过加锁的方式进行处理。
测试类
public class VolatileThreadDemo03 {

    public static void main(String ...`,l:"audition/java/多线程.html#_3-4-1-加锁",a:"_3-4-1-加锁"},"16.22":{t:"3.4.2 volatile关键字\r",p:`第二种处理方案，我们可以通过volatile关键字来修饰flag变量。
线程类
public class VolatileThread extends Thread {

    // 定义成员变量
 ...`,l:"audition/java/多线程.html#_3-4-2-volatile关键字",a:"_3-4-2-volatile关键字"},"16.23":{t:"4.1 看程序说结果\r",p:`分析如下程序的执行结果
线程类
public class VolatileAtomicThread implements Runnable {

    // 定义一个int类型的变量
    pri ...`,l:"audition/java/多线程.html#_4-1-看程序说结果",a:"_4-1-看程序说结果"},"16.24":{t:"4.2 问题分析说明\r",p:`以上问题主要是发生在count++操作上：
count++操作包含3个步骤：

从主内存中读取数据到工作内存
对工作内存中的数据进行++操作
将工作内存中的数据写回到主内存

count++操作不是一 ...`,l:"audition/java/多线程.html#_4-2-问题分析说明",a:"_4-2-问题分析说明"},"16.25":{t:"4.3 volatile原子性测试\r",p:`我们刚才说到了volatile在多线程环境下只保证了共享变量在多个线程间的可见性，但是不保证原子性。那么接下来我们就来做一个测试。测试的思想，就是使用volatile修饰count。
线程类
publ ...`,l:"audition/java/多线程.html#_4-3-volatile原子性测试",a:"_4-3-volatile原子性测试"},"16.26":{t:"4.4 volatile使用场景\r",p:`volatile关键字不保证原子性操作，那么同学们可能会存在一些疑问，volatile关键字在什么情况下进行使用呢？这里我们举两个基本的使用场景。
`,l:"audition/java/多线程.html#_4-4-volatile使用场景",a:"_4-4-volatile使用场景"},"16.27":{t:"4.4.1 状态标志\r",p:`比如现在存在一个线程不断向控制台输出一段话&quot;传智播客中国IT教育的标杆....&quot;,当这个线程执行5秒以后，将该线程结束。
实现思路：定义一个boolean类型的变量，这个变量就相当 ...`,l:"audition/java/多线程.html#_4-4-1-状态标志",a:"_4-4-1-状态标志"},"16.28":{t:"4.4.2 独立观察\r",p:`//AI养猪。。。。
//设备区测量温度
//当温度高了。。。需要给猪开空调。。。加冰棍。。。加喝的水。。。
volatile的另一种简单使用场景是：定期&quot;发布&quot;观察结果供程序内部 ...`,l:"audition/java/多线程.html#_4-4-2-独立观察",a:"_4-4-2-独立观察"},"16.29":{t:"4.5 问题处理\r",p:`接下来我们就来讲解一下我们上述案例(引入原子性问题的案例)的解决方案。
`,l:"audition/java/多线程.html#_4-5-问题处理",a:"_4-5-问题处理"},"16.30":{t:"4.5.1 锁机制\r",p:`我们可以给count++操作添加锁，那么count++操作就是临界区中的代码，临界区中的代码一次只能被一个线程去执行，所以count++就变成了原子操作。
线程任务类
public class Vol ...`,l:"audition/java/多线程.html#_4-5-1-锁机制",a:"_4-5-1-锁机制"},"16.31":{t:"4.5.2 原子类\r",p:"\r",l:"audition/java/多线程.html#_4-5-2-原子类",a:"_4-5-2-原子类"},"16.32":{t:"1) AtomicInteger\r",p:"概述：java从JDK1.5开始提供了java.util.concurrent.atomic包(简称Atomic包)，这个包中的原子操作类提供了一种用法简单，性能高效，线程安全地更新一个变量的方式。因 ...",l:"audition/java/多线程.html#_1-atomicinteger",a:"_1-atomicinteger"},"16.33":{t:"2) 案例改造\r",p:`使用AtomicInteger对案例进行改造。
public class VolatileAtomicThread implements Runnable {

    // 定义一个int类型的变量 ...`,l:"audition/java/多线程.html#_2-案例改造",a:"_2-案例改造"},"16.34":{t:"4.6 AtomicInteger原理\r",p:"\r",l:"audition/java/多线程.html#_4-6-atomicinteger原理",a:"_4-6-atomicinteger原理"},"16.35":{t:"4.6.1 原理介绍\r",p:`AtomicInteger的本质：自旋锁 + CAS算法
CAS的全成是： Compare And Swap(比较再交换); 是现代CPU广泛支持的一种对内存中的共享数据进行操作的一种特殊指令。CAS ...`,l:"audition/java/多线程.html#_4-6-1-原理介绍",a:"_4-6-1-原理介绍"},"16.36":{t:"4.6.2 源码分析\r",p:`那么接下来我们就来查看一下AtomicInteger类中incrementAndGet方法的源码。
public class AtomicInteger extends Number implemen ...`,l:"audition/java/多线程.html#_4-6-2-源码分析",a:"_4-6-2-源码分析"},"16.37":{t:"4.7 CAS与Synchronized\r",p:`CAS和Synchronized都可以保证多线程环境下共享数据的安全性。那么他们两者有什么区别？
Synchronized是从悲观的角度出发：
总是假设最坏的情况，每次去拿数据的时候都认为别人会修改， ...`,l:"audition/java/多线程.html#_4-7-cas与synchronized",a:"_4-7-cas与synchronized"},"16.38":{t:"5.1 ConcurrentHashMap\r",p:"\r",l:"audition/java/多线程.html#_5-1-concurrenthashmap",a:"_5-1-concurrenthashmap"},"16.39":{t:"5.1.1 概述以及基本使用\r",p:`在集合类中HashMap是比较常用的集合对象，但是HashMap是线程不安全的(多线程环境下可能会存在问题)。为了保证数据的安全性我们可以使用Hashtable，但是Hashtable的效率低下。
基 ...`,l:"audition/java/多线程.html#_5-1-1-概述以及基本使用",a:"_5-1-1-概述以及基本使用"},"16.40":{t:"5.1.2 源码分析\r",p:`由于ConcurrentHashMap在jdk1.7和jdk1.8的时候实现原理不太相同，因此需要分别来讲解一下两个不同版本的实现原理。
`,l:"audition/java/多线程.html#_5-1-2-源码分析",a:"_5-1-2-源码分析"},"16.41":{t:"1) jdk1.7版本\r",p:`&lt;font color=&quot;blue&quot; size=&quot;3&quot;&gt;ConcurrentHashMap中的重要成员变量&lt;/font&gt;
public  ...`,l:"audition/java/多线程.html#_1-jdk1-7版本",a:"_1-jdk1-7版本"},"16.42":{t:"2) jdk1.8版本\r",p:"在JDK1.8中为了进一步优化ConcurrentHashMap的性能，去掉了Segment分段锁的设计。在数据结构方面，则是跟HashMap一样，使用一个哈希表table数组。(数组 + 链表 +  ...",l:"audition/java/多线程.html#_2-jdk1-8版本",a:"_2-jdk1-8版本"},"16.43":{t:"5.2 CountDownLatch\r",p:`CountDownLatch允许一个或多个线程等待其他线程完成操作以后，再执行当前线程；比如我们在主线程需要开启2个其他线程，当其他的线程执行完毕以后我们再去执行主线程，针对这
个需求我们就可以使用C ...`,l:"audition/java/多线程.html#_5-2-countdownlatch",a:"_5-2-countdownlatch"},"16.44":{t:"5.3 CyclicBarrier\r",p:"\r",l:"audition/java/多线程.html#_5-3-cyclicbarrier",a:"_5-3-cyclicbarrier"},"16.45":{t:"5.3.1 概述以及基本使用\r",p:`CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障
才会开门， ...`,l:"audition/java/多线程.html#_5-3-1-概述以及基本使用",a:"_5-3-1-概述以及基本使用"},"16.46":{t:"5.3.2 使用场景\r",p:`使用场景：CyclicBarrier可以用于多线程计算数据，最后合并计算结果的场景。
比如：现在存在两个文件，这个两个文件中存储的是某一个员工两年的工资信息(一年一个文件)，现需要对这两个文件中的数据 ...`,l:"audition/java/多线程.html#_5-3-2-使用场景",a:"_5-3-2-使用场景"},"16.47":{t:"5.4 Semaphore\r",p:`Semaphore字面意思是信号量的意思，它的作用是控制访问特定资源的线程数目。
举例：现在有一个十字路口，有多辆汽车需要进经过这个十字路口，但是我们规定同时只能有两辆汽车经过。其他汽车处于等待状态， ...`,l:"audition/java/多线程.html#_5-4-semaphore",a:"_5-4-semaphore"},"16.48":{t:"5.5 Exchanger\r",p:"\r",l:"audition/java/多线程.html#_5-5-exchanger",a:"_5-5-exchanger"},"16.49":{t:"5.5.1 概述以及基本使用\r",p:`Exchanger（交换者）是一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交换。
举例：比如男女双方结婚的时候，需要进行交换结婚戒指。
Exchanger常用方法
public  ...`,l:"audition/java/多线程.html#_5-5-1-概述以及基本使用",a:"_5-5-1-概述以及基本使用"},"16.50":{t:"5.5.2 使用场景\r",p:`使用场景：可以做数据校对工作
比如: 现在存在一个文件，该文件中存储的是某一个员工一年的工资信息，现需要将这个员工的工资信息录入到系统中，采用AB岗两人进行录入，录入到两个文件中，系统需要加载这两
个 ...`,l:"audition/java/多线程.html#_5-5-2-使用场景",a:"_5-5-2-使用场景"},"17.0":{t:"# 线程\r",p:"\r",l:"audition/java/线程.html",a:"线程"},"17.1":{t:"什么是线程\r",p:`线程是操作系统呢能够进行运算调度的最小单位，被包含在进程之中，是进程的实际运作单位。
`,l:"audition/java/线程.html#什么是线程",a:"什么是线程"},"17.2":{t:"什么是进程\r",p:`程序的基本执行实体
`,l:"audition/java/线程.html#什么是进程",a:"什么是进程"},"17.3":{t:"并发\r",p:`同一时刻有多个指令在单个cpu上交替执行
`,l:"audition/java/线程.html#并发",a:"并发"},"17.4":{t:"并行\r",p:`同一时刻有多个指令在多个cpu上同时执行
`,l:"audition/java/线程.html#并行",a:"并行"},"17.5":{t:"线程的优先级\r",p:`java采用抢占式调度，优先级也不是绝对的，是概率问题
`,l:"audition/java/线程.html#线程的优先级",a:"线程的优先级"},"17.6":{t:"守护线程setDeamon\r",p:`当其他非守护线程执行完毕之后，守护线程也会陆续结束，不会全部执行完
`,l:"audition/java/线程.html#守护线程setdeamon",a:"守护线程setdeamon"},"17.7":{t:" ",p:"",l:"audition/java/线程.html#",a:""},"17.8":{t:"线程的生命周期\r",p:`
创建线程对象start()  新建
有执行资格，没有执行权，不停地抢cpu（就绪）
有执行资格和执行权，运行代码 运行,虚拟机没有这个状态，交给操作系统了，java就不管了

如果线程遇到阻塞方法（ ...`,l:"audition/java/线程.html#线程的生命周期",a:"线程的生命周期"},"17.9":{t:"java线程安全是什么\r",p:`在Java中，线程安全（Thread Safety）是指在多线程环境下，对共享资源（如变量、对象、数据结构等）的访问和操作能够正确地进行，而不会出现意外的结果或导致程序的异常行为。
可能导致数据损坏、 ...`,l:"audition/java/线程.html#java线程安全是什么",a:"java线程安全是什么"},"17.10":{t:"确保线程安全常见的方式\r",p:`为了确保线程安全，可以采取多种方式，其中常见的方式包括：

使用互斥锁（Mutex）或同步机制来保护共享资源，确保同一时间只有一个线程可以访问该资源。例如，可以使用synchronized关键字或Lo ...`,l:"audition/java/线程.html#确保线程安全常见的方式",a:"确保线程安全常见的方式"},"17.11":{t:"原子操作\r",p:`原子操作（Atomic Operations）是指在并发编程中不可分割的、不可中断的单个操作。原子操作要么完全执行，要么不执行，不存在执行过程中被其他线程干扰的情况。
原子操作可以用来解决确保线程安全 ...`,l:"audition/java/线程.html#原子操作",a:"原子操作"},"17.12":{t:"同步代码块\r",p:`
synchronized线程锁，synchronized的锁对象一定是唯一的，可以写当前类名的字节码文件


public class synchronizedDemo extends Thread ...`,l:"audition/java/线程.html#同步代码块",a:"同步代码块"},"17.13":{t:"同步方法\r",p:`
synchronized直接写在方法上
同步方法是锁住方法里的所有代码
锁对象不能自己指定，非静态：this，静态：当前类名的字节码文件

public class RunnableDemo imp ...`,l:"audition/java/线程.html#同步方法",a:"同步方法"},"17.14":{t:"StringBuilder和StringBuffer\r",p:`StringBuilder用于单线程，多线程不安全
StringBuffer用于多线程，线程安全，加了synchronized关键字
`,l:"audition/java/线程.html#stringbuilder和stringbuffer",a:"stringbuilder和stringbuffer"},"17.15":{t:"Lock锁\r",p:`Lock实现提供比使用synchronized方法和语句可以获得更广泛的锁定操作，
Lock提供了获得锁和释放锁的方法
void lock(),获得锁
void unlock()，释放锁
Lock是一 ...`,l:"audition/java/线程.html#lock锁",a:"lock锁"},"17.16":{t:"死锁\r",p:`嵌套锁
`,l:"audition/java/线程.html#死锁",a:"死锁"},"17.17":{t:"生产者消费者（等待唤醒机制）\r",p:`wait和notifyAll实现
public class Foodie extends Thread {

    @Override
    public  void run(){

       ...`,l:"audition/java/线程.html#生产者消费者-等待唤醒机制",a:"生产者消费者-等待唤醒机制"},"17.18":{t:"线程池\r",p:`    ThreadPoolExecutor pool = new ThreadPoolExecutor(
            3,          //核心线程数量
            6 ...`,l:"audition/java/线程.html#线程池",a:"线程池"},"17.19":{t:"线程池多大合适\r",p:`CPU密集型运算，最大并行数+1 I/O密集型运算

最大并行数 * 期望CPU利用率 *（总时间（cpu计算时间+等待时间）/ CPU计算时间）

`,l:"audition/java/线程.html#线程池多大合适",a:"线程池多大合适"},"18.0":{t:"# 总结\r",p:"\r",l:"audition/java/综合案例总结.html",a:"总结"},"18.1":{t:"@Slf4j\r",p:`输出日志
@Slf4j //注解 private static Logger log = LoggerFactory.getLogger(DeptController.class);


`,l:"audition/java/综合案例总结.html#slf4j",a:"slf4j"},"18.2":{t:"请求方式\r",p:" @GetMapping(&quot;/depts&quot;)   //衍生注解 相当于@RequestMapping(value = &quot;/depts&quot;,method = Req ...",l:"audition/java/综合案例总结.html#请求方式",a:"请求方式"},"18.3":{t:"操作\r",p:`
前端发请求会请求到@RestController这个方法，
这个方法中首先会通过@Autowired注入service接口，
service接口需要一个实现类来获取数据，在这个实现类中通过@Auto ...`,l:"audition/java/综合案例总结.html#操作",a:"操作"},"18.4":{t:"分页查询\r",p:`通过一个外部类PageBean收集总条数和pagesize
Controller编写接口
    @GetMapping(&quot;/emps&quot;)
    public Result pa ...`,l:"audition/java/综合案例总结.html#分页查询",a:"分页查询"},"19.0":{t:"# javascript八股文\r",p:"\r",l:"audition/js/javascript.html",a:"javascript八股文"},"19.1":{t:"js为什么是单线程的\r",p:`
简单：多线程编程涉及到线程间的同步和竞争条件处理，避免复杂的并发问题
安全：由于JavaScript通常运行在浏览器环境中，它可能与用户的敏感数据进行交互。如果允许JavaScript多线程访问用户 ...`,l:"audition/js/javascript.html#js为什么是单线程的",a:"js为什么是单线程的"},"19.2":{t:"1. Js的基础类型\r",p:`
基础类型有：boolean、string、number、undefined、symbol、null、  bigint。
引用数据类型：Object、function、Array

`,l:"audition/js/javascript.html#_1-js的基础类型",a:"_1-js的基础类型"},"19.3":{t:"2. typeof和instanceof的区别\r",p:`
typeof能识别所有的基本类型值类型，识别函数，对于其他引用类型统一返回object。
instanceof用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上，可以准确地 ...`,l:"audition/js/javascript.html#_2-typeof和instanceof的区别",a:"_2-typeof和instanceof的区别"},"19.4":{t:"3. JS数据类型判断\r",p:`
typeof：检测基础数据类型和函数很好用

它能准确判断出的数据类型有：Number，String，Boolean，Undefined，Symbol，BigInt，Function。
它的缺点就是 ...`,l:"audition/js/javascript.html#_3-js数据类型判断",a:"_3-js数据类型判断"},"19.5":{t:"4. ``没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。先执行下载js脚本然后执行然后再解析HTML。\r",p:"",l:"audition/js/javascript.html#_4-没有-defer-或-async-浏览器会立即加载并执行指定的脚本-立即-指的是在渲染该-script-标签之下的文档元素之前-也就是说不等待后续载入的文档元素-读到就加载并执行。先执行下载js脚本然后执行然后再解析html。",a:"_4-没有-defer-或-async-浏览器会立即加载并执行指定的脚本-立即-指的是在渲染该-script-标签之下的文档元素之前-也就是说不等待后续载入的文档元素-读到就加载并执行。先执行下载js脚本然后执行然后再解析html。"},"19.6":{t:"async \r",p:"``有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。解析HTML和下载async脚本同时进行，async脚本下载完成后立即执行，然后开始解析剩下的H ...",l:"audition/js/javascript.html#async",a:"async"},"19.7":{t:"defer\r",p:"``如果一个script加了defer属性，即使放在head里面，它也会在html页面解析完毕之后再去执行，也就是类似于把这个script放在了页面底部。下载时，解析HTML和下载defer脚本同时进 ...",l:"audition/js/javascript.html#defer",a:"defer"},"19.8":{t:"不同\r",p:`
defer是html4的async是html5新增的
执行时间不同，async是下载完后立即执行，defer是在html解析完后再执行,在DOM树构建完成，DOMContentLoaded之前执行
 ...`,l:"audition/js/javascript.html#不同",a:"不同"},"19.9":{t:"立即执行函数是闭包\r",p:`立即执行函数是闭包，因为立即执行，所以定义在return上，所以是闭包，var声明变量时在闭包里不会提升，私有属性
`,l:"audition/js/javascript.html#立即执行函数是闭包",a:"立即执行函数是闭包"},"19.10":{t:"class类的函数默认是严格模式\r",p:`class类里的函数默认是严格模式，类中的方法的this不是固定的，以方法形式调用this是当前实例，以普通函数形式调时严格模式下this指向undefined，以箭头函数调用时this指向当前实例
`,l:"audition/js/javascript.html#class类的函数默认是严格模式",a:"class类的函数默认是严格模式"},"19.11":{t:"JS 执行机制\r",p:"js是单线程的，为了解决耗时任务阻塞页面渲染，实现单线程非阻塞方法就是事件循环，分为同步任务和异步任务，同步任务进入主线程，即主执行栈，异步任务进入任务队列，主线程内的任务执行完毕为空，会去任务队列读 ...",l:"audition/js/javascript.html#js-执行机制",a:"js-执行机制"},"19.12":{t:"eventloop事件循环\r",p:"同步任务执行完，就会去任务队列中拿一个宏任务放到执行栈中执行，执行完该宏任务中的所有微任务，再到任务队列中拿宏任务，即一个宏任务、所有微任务、渲染、一个宏任务、所有微任务、渲染...(不是所有微任务之 ...",l:"audition/js/javascript.html#eventloop事件循环",a:"eventloop事件循环"},"19.13":{t:"同步异步\r",p:`
同步任务：指排队在主线程上依次执行的任务
异步任务：不进入主线程，而进入任务队列的任务，又分为宏任务和微任务

宏任务： 渲染事件、请求、script、setTimeout、setInterval、 ...`,l:"audition/js/javascript.html#同步异步",a:"同步异步"},"19.14":{t:"宏任务和微任务\r",p:`
事件循环由宏任务和在执行宏任务期间产生的所有微任务组成。完成当下的宏任务后，会立刻执行所有在此期间入队的微任务。
这种设计是为了给高优先级任务一个插队的机会，微任务比宏任务有更高优先级。否则新入队的 ...`,l:"audition/js/javascript.html#宏任务和微任务",a:"宏任务和微任务"},"19.15":{t:"setTimeout的误区\r",p:`
setTimeout的回调不一定在指定时间后能执行。而是在指定时间后，将回调函数放入事件循环的队列中。
如果时间到了，JS引擎还在执行同步任务，这个回调函数需要等待；如果当前事件循环的队列里还有其他 ...`,l:"audition/js/javascript.html#settimeout的误区",a:"settimeout的误区"},"19.16":{t:"nextTick 永远大于 promise.then \r",p:`process.nextTick()将函数插入到tick队列，promise.then 将函数插入到微任务队列，tick队列比微任务队列先执行
`,l:"audition/js/javascript.html#nexttick-永远大于-promise-then",a:"nexttick-永远大于-promise-then"},"19.17":{t:"队列执行顺序\r",p:`调用栈 --&gt; tick队列 --&gt; 微任务队列 --&gt; 宏任务队列
`,l:"audition/js/javascript.html#队列执行顺序",a:"队列执行顺序"},"19.18":{t:"深拷贝浅拷贝\r",p:`拷贝，新旧对象不共享同一地址
`,l:"audition/js/javascript.html#深拷贝浅拷贝",a:"深拷贝浅拷贝"},"19.19":{t:"深拷贝\r",p:`深拷贝是将一个对象从内存中完整的拷贝一份出来
`,l:"audition/js/javascript.html#深拷贝",a:"深拷贝"},"19.20":{t:"浅拷贝\r",p:`浅拷贝是将一个对象的第一层从内存中拷贝一份出来，如果属性值是对象或数组，则对应属性的地址还是原对象的地址
`,l:"audition/js/javascript.html#浅拷贝",a:"浅拷贝"},"19.21":{t:"赋值和浅拷贝的区别\r",p:`
赋值：新对象改变会影响原对象，赋值后原对象改变也会影响新对象，就像是一个整体
浅拷贝：新对象改变不会影响原对象，拷贝后原对象改变也不会影响新对象，就像地址一样的两个不同的个体

`,l:"audition/js/javascript.html#赋值和浅拷贝的区别",a:"赋值和浅拷贝的区别"},"19.22":{t:"闭包\r",p:"在JavaScript中，闭包（Closure）是指能够访问外部函数作用域中变量的函数。当一个内部函数引用了其外部函数的变量时，就形成了一个闭包。闭包使得函数可以保留对其定义时作用域内的变量和参数的引 ...",l:"audition/js/javascript.html#闭包",a:"闭包"},"19.23":{t:"内存泄漏\r",p:`比如：意外的全局变量，给全局变量赋值，闭包，对dom元素的引用
`,l:"audition/js/javascript.html#内存泄漏",a:"内存泄漏"},"19.24":{t:"内存的生命周期\r",p:`
分配内存，
在内存中进行操作
垃圾清除，释放内存

`,l:"audition/js/javascript.html#内存的生命周期",a:"内存的生命周期"},"19.25":{t:"垃圾回收机制\r",p:`

标记清除，标记为离开环境，等待垃圾回收


引用计数，如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放


从全局对象 window 开始，顺着引用表能找到的都不是内存垃圾 ...`,l:"audition/js/javascript.html#垃圾回收机制",a:"垃圾回收机制"},"19.26":{t:"执行上下文\r",p:"函数在执行时，JS 引擎会创建执行上下文，该执行上下文会包含函数的作用域链，其次包含函数内部定义的变量、参数等。在执行时，会首先查找当前作用域下的变量，如果找不到，就会沿着作用域链中查找，一直到全局作 ...",l:"audition/js/javascript.html#执行上下文",a:"执行上下文"},"19.27":{t:"isNaN 与 Number.isNaN的区别？\r",p:`
isNaN：除了判断NaN为true，还会把不能转成数字的判断为true，例如字符串'xxx'
Number.isNaN：只有判断NaN时为true，其余情况都为false

console.log ...`,l:"audition/js/javascript.html#isnan-与-number-isnan的区别",a:"isnan-与-number-isnan的区别"},"19.28":{t:"hasOwnProperty\r",p:`找到静态方法定义在实例对象上的属性，找不到实例方法定义在原型对象上的属性
function Person(name) {
  this.name = name
}
Person.prototype.a ...`,l:"audition/js/javascript.html#hasownproperty",a:"hasownproperty"},"19.29":{t:"&& ||\r",p:`a &amp;&amp; b :a为真时执行b，a为假时执行a
a || b :a为假时执行b，a为真时执行a
`,l:"audition/js/javascript.html#",a:""},"19.30":{t:"valueOf 与 toString\r",p:`valueOf()方法用于返回指定对象的原始值，若对象没有原始值，则将返回对象本身。toString()返回一个代表该对象的字符串。

valueOf偏向于运算，toString偏向于显示
对象转换时 ...`,l:"audition/js/javascript.html#valueof-与-tostring",a:"valueof-与-tostring"},"19.31":{t:"JavaScript变量在内存中具体存储形式？\r",p:`
基本数据类型：存在栈内存里
引用数据类型：指针存栈内存，指向堆内存中一块地址，内容存在堆内存中

`,l:"audition/js/javascript.html#javascript变量在内存中具体存储形式",a:"javascript变量在内存中具体存储形式"},"19.32":{t:"JavaScript的装箱和拆箱？\r",p:"",l:"audition/js/javascript.html#javascript的装箱和拆箱",a:"javascript的装箱和拆箱"},"19.33":{t:"装箱：把基本数据类型转化为对应的引用数据类型的操作\r",p:"\r",l:"audition/js/javascript.html#装箱-把基本数据类型转化为对应的引用数据类型的操作",a:"装箱-把基本数据类型转化为对应的引用数据类型的操作"},"19.34":{t:"拆箱：将引用数据类型转化为对应的基本数据类型的操作\r",p:`通过valueOf或者toString方法实现拆箱操作
var objNum = new Number(123);  
var objStr =new String(&quot;123&quot;); ...`,l:"audition/js/javascript.html#拆箱-将引用数据类型转化为对应的基本数据类型的操作",a:"拆箱-将引用数据类型转化为对应的基本数据类型的操作"},"19.35":{t:"null和undefined的异同点有哪些？\r",p:`
都是空变量
都是假值，转布尔值都是false
null == undefined 为 true
不同点
typeof判断null为object，判断undefined为undefined null转 ...`,l:"audition/js/javascript.html#null和undefined的异同点有哪些",a:"null和undefined的异同点有哪些"},"19.36":{t:"为什么typeof null 是object？\r",p:`不同的数据类型在底层都是通过二进制表示的，二进制前三位为000则会被判断为object类型，而null底层的二进制全都是0，那前三位肯定也是000，所以被判断为object
`,l:"audition/js/javascript.html#为什么typeof-null-是object",a:"为什么typeof-null-是object"},"19.37":{t:"== 与 === 的区别？\r",p:`
==：在比较过程中会存在隐式转换
===：需要类型相同，值相同，才能为true

`,l:"audition/js/javascript.html#与-的区别",a:"与-的区别"},"19.38":{t:"JavaScript的隐式转换规则？\r",p:`
转成string类型： +（字符串连接符）
转成number类型：++/--(自增自减运算符) + - * / %(算术运算符) &gt; &lt; &gt;= &lt;= == != === != ...`,l:"audition/js/javascript.html#javascript的隐式转换规则",a:"javascript的隐式转换规则"},"19.39":{t:"双等号左右两边的转换规则？\r",p:`
null == undefined 为 true
如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false转换为0，而true转换为1；
如果一个操作数是字符串，另一个操作数是数值 ...`,l:"audition/js/javascript.html#双等号左右两边的转换规则",a:"双等号左右两边的转换规则"},"19.40":{t:"undefined >= undefined 为什么是 false ？\r",p:`按照隐式转换规则，可转换成NaN &gt;= NaN，NaN 不等于 NaN，也不大于，所以是false
`,l:"audition/js/javascript.html#undefined-undefined-为什么是-false",a:"undefined-undefined-为什么是-false"},"19.41":{t:"null >= null 为什么是 true？\r",p:`按照隐式转换规则，可转换成0 &gt;= 0，0 等于 0，所以是true
`,l:"audition/js/javascript.html#null-null-为什么是-true",a:"null-null-为什么是-true"},"19.42":{t:"[] == ![] 为什么是 true ？\r",p:`按照双等号左右两边的转换规则

! 优先级高于 ==，[]不是假值，所以先转换成 [] == false
右边为布尔值，false先转数字0，所以可转换为[] == 0
左边为对象，[]调用toStr ...`,l:"audition/js/javascript.html#为什么是-true",a:"为什么是-true"},"19.43":{t:"0.1 + 0.2 === 0.3，对吗？\r",p:`不对，JavaScript的计算存在精度丢失问题

原因：JavaScript中小数是浮点数，需转二进制进行运算，有些小数无法用二进制表示，所以只能取近似值，所以造成误差
解决方法：
先变成整数运算， ...`,l:"audition/js/javascript.html#_0-1-0-2-0-3-对吗",a:"_0-1-0-2-0-3-对吗"},"19.44":{t:"什么是匿名函数？\r",p:`匿名函数：就是没有函数名的函数
`,l:"audition/js/javascript.html#什么是匿名函数",a:"什么是匿名函数"},"19.45":{t:"绑定点击事件有几种方式？\r",p:`三种
xxx.onclick = function (){}
&lt;xxx onclick=&quot;&quot;&gt;&lt;/xxx&gt;
xxx.addEventListener('cl ...`,l:"audition/js/javascript.html#绑定点击事件有几种方式",a:"绑定点击事件有几种方式"},"19.46":{t:"addEventListener的第三个参数是干嘛的？\r",p:`第三个变量传一个布尔值，需不需要阻止冒泡，默认是false，不阻止冒泡,决定事件是在捕获（true）或冒泡阶段(false)执行
`,l:"audition/js/javascript.html#addeventlistener的第三个参数是干嘛的",a:"addeventlistener的第三个参数是干嘛的"},"19.47":{t:"函数声明和函数表达式的区别？\r",p:`
函数声明：享受函数提升
函数表达式：归类于变量声明，享受变量提升
函数提升优先级 &gt; 变量提升优先级

console.log(fun) // fun () {}
// 函数表达式
var f ...`,l:"audition/js/javascript.html#函数声明和函数表达式的区别",a:"函数声明和函数表达式的区别"},"19.48":{t:"JavaScript的事件流模型有哪些？\r",p:`
事件冒泡：由最具体的元素接收，并往上传播
事件捕获：由最不具体的元素接收，并往下传播
DOM事件流：事件捕获 -&gt; 目标阶段 -&gt; 事件冒泡

`,l:"audition/js/javascript.html#javascript的事件流模型有哪些",a:"javascript的事件流模型有哪些"},"19.49":{t:"Ajax、Axios、Fetch有啥区别？\r",p:`
Ajax：是对XMLHttpRequest对象（XHR）的封装
Axios：是基于Promise对XHR对象的封装
Fetch：是window的一个方法，也是基于Promise，但是与XHR无关，不 ...`,l:"audition/js/javascript.html#ajax、axios、fetch有啥区别",a:"ajax、axios、fetch有啥区别"},"19.50":{t:"load、$(document).ready、DOMContentLoaded的区别？\r",p:`DOM文档加载的步骤为：

解析HTML结构。
加载外部脚本和样式表文件。
解析并执行脚本代码。
DOM树构建完成。// DOMContentLoaded触发、$(document).ready触发
 ...`,l:"audition/js/javascript.html#load、-document-ready、domcontentloaded的区别",a:"load、-document-ready、domcontentloaded的区别"},"19.51":{t:"如何阻止事件冒泡？\r",p:`function stopBubble(e) {
  if (e.stopPropagation) {
    e.stopPropagation()
  } else {
    window.ev ...`,l:"audition/js/javascript.html#如何阻止事件冒泡",a:"如何阻止事件冒泡"},"19.52":{t:"如何阻止事件默认行为？\r",p:`function stopDefault(e) {
  if (e.preventDefault) {
    e.preventDefault();
  } else {
    window.ev ...`,l:"audition/js/javascript.html#如何阻止事件默认行为",a:"如何阻止事件默认行为"},"19.53":{t:"什么是事件委托？\r",p:`当所有子元素都需要绑定相同的事件的时候，可以把事件绑定在父元素上，这就是事件委托，优点有：

绑定在父元素上只需要绑定一次，节省性能
子元素不需要每个都去绑定同一事件
如果后续又有新的子元素添加，会由 ...`,l:"audition/js/javascript.html#什么是事件委托",a:"什么是事件委托"},"19.54":{t:"如何实现数组去重？\r",p:`
使用 Map 去重

function quchong1(arr) {
  const newArr = []; // 创建一个空数组存储去重后的元素
  arr.reduce((pre, next ...`,l:"audition/js/javascript.html#如何实现数组去重",a:"如何实现数组去重"},"19.55":{t:"NaN是什么？有什么特点？\r",p:`NaN不等于自身，也就是 NaN === NaN 为 false NaN为假值，转布尔值为false

NaN本质是一个number，typeof NaN === number

`,l:"audition/js/javascript.html#nan是什么-有什么特点",a:"nan是什么-有什么特点"},"19.56":{t:"JavaScript继承方式有几种？ \r",p:`参考
`,l:"audition/js/javascript.html#javascript继承方式有几种",a:"javascript继承方式有几种"},"19.57":{t:"class继承super \r",p:`super 关键字用于在子类中访问和调用父类的构造函数、静态方法和原型方法
`,l:"audition/js/javascript.html#class继承super",a:"class继承super"},"19.58":{t:"数组常用方法（否影响原数组）\r",p:`array



方法
作用
是否影响原数组




push
在数组后添加元素，返回数组长度
✅


pop
删除数组最后一项，返回被删除项
✅


shift
删除数组第一项，并返回被删除项
✅
 ...`,l:"audition/js/javascript.html#数组常用方法-否影响原数组",a:"数组常用方法-否影响原数组"},"19.59":{t:"Math的常用方法有哪些？\r",p:`


方法
作用




Math.max(...arr)
取arr中的最大值


Math.min(...arr)
取arr中的最小值


Math.ceil(小数)
小数向上取整


Math.f ...`,l:"audition/js/javascript.html#math的常用方法有哪些",a:"math的常用方法有哪些"},"19.60":{t:"JS中有哪些不同类型的弹出框？\r",p:`在JS中有三种类型的弹出框可用，分别是：
Alert Confirm

Prompt

`,l:"audition/js/javascript.html#js中有哪些不同类型的弹出框",a:"js中有哪些不同类型的弹出框"},"19.61":{t:"如何将 JS 日期转换为ISO标准\r",p:`toISOString() 方法用于将js日期转换为ISO标准。 它使用ISO标准将js Date对象转换为字符串。如：
var date = new Date();
var n = date.toI ...`,l:"audition/js/javascript.html#如何将-js-日期转换为iso标准",a:"如何将-js-日期转换为iso标准"},"19.62":{t:"如何在JS中编码和解码 URL\r",p:`encodeURI() 函数用于在JS中对URL进行编码。它将url字符串作为参数并返回编码的字符串。
注意： encodeURI()不会编码类似这样字符： / ? : @ &amp; = + $ # ...`,l:"audition/js/javascript.html#如何在js中编码和解码-url",a:"如何在js中编码和解码-url"},"19.63":{t:"什么是BOM？有哪些api？\r",p:`BOM就是browser object model，浏览器对象模型,window，location，navigator，history



api
作用
代表方法或属性




window.his ...`,l:"audition/js/javascript.html#什么是bom-有哪些api",a:"什么是bom-有哪些api"},"19.64":{t:"BOM 和 DOM 的关系\r",p:`
BOM全称Browser Object Model，即浏览器对象模型，主要处理浏览器窗口和框架，没有统一遵循的标准
DOM全称Document Object Model，即文档对象模型，是 HTML ...`,l:"audition/js/javascript.html#bom-和-dom-的关系",a:"bom-和-dom-的关系"},"19.65":{t:"JS中的substr()和substring()函数有什么区别\r",p:"",l:"audition/js/javascript.html#js中的substr-和substring-函数有什么区别",a:"js中的substr-和substring-函数有什么区别"},"19.66":{t:"substr()\r",p:`substr() 函数的形式为substr(startIndex,length)。 它从startIndex返回子字符串并返回'length'个字符数。
var s = &quot;hello&quo ...`,l:"audition/js/javascript.html#substr",a:"substr"},"19.67":{t:"substring() \r",p:`substring() 函数的形式为substring(startIndex,endIndex)。 它返回从startIndex到endIndex - 1的子字符串。
var s = &quot;he ...`,l:"audition/js/javascript.html#substring",a:"substring"},"19.68":{t:'解释一下 "use strict" ?\r',p:"“use strict”是Es5中引入的js指令。 使用“use strict”指令的目的是强制执行严格模式下的代码。 在严格模式下，咱们不能在不声明变量的情况下使用变量。 早期版本的js忽略了“us ...",l:"audition/js/javascript.html#解释一下-use-strict",a:"解释一下-use-strict"},"19.69":{t:"input标签\r",p:`
&lt;input&gt; 标签规定了用户可以在其中输入数据的输入字段。
&lt;input&gt; 元素在&lt;form&gt;元素中使用，用来声明允许用户输入数据的 input 控件。输入字段 ...`,l:"audition/js/javascript.html#input标签",a:"input标签"},"19.70":{t:"属性\r",p:`参考
`,l:"audition/js/javascript.html#属性",a:"属性"},"19.71":{t:"arguements\r",p:`类数组，arguments 是一个特殊的对象，表示函数调用时传入的参数列表。它是一个类数组对象，可以通过数字索引获取其中的参数。
arguments 对象可以在函数内部访问，无需像其他参数一样在函数定 ...`,l:"audition/js/javascript.html#arguements",a:"arguements"},"19.72":{t:"类数组转数组方法\r",p:`
Array.from()

var arr = Array.from(arguments);


Array.prototype.slice.call()

var arr = Array.prot ...`,l:"audition/js/javascript.html#类数组转数组方法",a:"类数组转数组方法"},"19.73":{t:"for...in和for...of\r",p:`for...in用key遍历，用于遍历对象的可枚举属性，遍历的顺序不保证与对象属性的添加顺序一致
for...of用值遍历，用于遍历可迭代对象（Iterable）的元素，遍历的顺序不保证与对象属性的添 ...`,l:"audition/js/javascript.html#for-in和for-of",a:"for-in和for-of"},"19.74":{t:"可迭代对象（Iterable）有哪些\r",p:`
使用 for...of 循环来遍历其元素
要成为可迭代对象，对象必须实现 Symbol.iterator 方法，该方法返回一个迭代器对象。迭代器对象必须包含一个 next() 方法，用于提供下一个值 ...`,l:"audition/js/javascript.html#可迭代对象-iterable-有哪些",a:"可迭代对象-iterable-有哪些"},"19.75":{t:"new的过程\r",p:`
创建一个空对象：new 关键字会创建一个空对象，作为即将创建的对象实例。
将空对象绑定到构造函数的原型链上：new 关键字会将空对象的原型链指向构造函数的原型对象。这样，新创建的对象就可以访问构造函 ...`,l:"audition/js/javascript.html#new的过程",a:"new的过程"},"19.76":{t:"事件处理函数event\r",p:`
event.target：表示事件的目标元素，即触发事件的具体元素。
event.currentTarget：表示事件的当前目标元素，即当前正在处理事件的元素。(冒泡时当前目标元素会变)
event ...`,l:"audition/js/javascript.html#事件处理函数event",a:"事件处理函数event"},"19.77":{t:"执行上下文\r",p:`
执行上下文是一种对Javascript代码执行环境的抽象概念
全局执行上下文：只有一个，浏览器中的全局对象就是 window对象，this 指向这个全局对象
函数执行上下文：存在无数个，只有在函数被 ...`,l:"audition/js/javascript.html#执行上下文",a:"执行上下文"},"19.78":{t:"执行栈\r",p:`执行栈，也叫调用栈，具有 LIFO（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文

当Javascript引擎开始执行你第一行脚本代码的时候，它就会创建一个全局执行上下文然后将它压到执行 ...`,l:"audition/js/javascript.html#执行栈",a:"执行栈"},"20.0":{t:"# Object.prototype\r",p:"\r",l:"audition/js/objectprototype.html",a:"object-prototype"},"20.1":{t:"object\r",p:`在 JavaScript 中，几乎所有的对象都是 Object 类型的实例，它们都会从 Object.prototype 继承属性和方法
`,l:"audition/js/objectprototype.html#object",a:"object"},"20.2":{t:"Object()\r",p:`创建一个新的 Object 对象。该对象将会包裹（wrapper）传入的参数
`,l:"audition/js/objectprototype.html#object",a:"object"},"20.3":{t:"Object.assign()\r",p:`
通过复制一个或多个对象来创建一个新的对象。浅拷贝
Object.assign()方法将所有可枚举属性从一个或多个源对象复制到目标对象，返回修改后的对象。

const target = { a: 1 ...`,l:"audition/js/objectprototype.html#object-assign",a:"object-assign"},"20.4":{t:"Object.create()\r",p:`
Object.create() 方法用于创建一个新的实例对象，使用现有的对象来作为新创建实例对象的原型对象（prototype）。
新创建实例对象.__proto__ === 传入的对象

cons ...`,l:"audition/js/objectprototype.html#object-create",a:"object-create"},"20.5":{t:"Object.defineProperty()\r",p:`Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。
`,l:"audition/js/objectprototype.html#object-defineproperty",a:"object-defineproperty"},"20.6":{t:"语法\r",p:`Object.defineProperty(obj, prop, descriptor)

obj要定义属性的对象。
prop要定义或修改的属性的名称或 Symbol 。
descriptor要定义或 ...`,l:"audition/js/objectprototype.html#语法",a:"语法"},"20.7":{t:"Object.defineProperties()\r",p:`给对象添加多个属性并分别指定它们的配置。
var obj = {};
Object.defineProperties(obj, {
  'property1': {
    value: true,
 ...`,l:"audition/js/objectprototype.html#object-defineproperties",a:"object-defineproperties"},"20.8":{t:"Object.entries()\r",p:"Object.entries() 方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for...in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环还会枚举原型链中的属性）。 ...",l:"audition/js/objectprototype.html#object-entries",a:"object-entries"},"20.9":{t:"Object.freeze()\r",p:"Object.freeze() 方法可以冻结一个对象。一个被冻结的对象再也不能被修改；冻结了一个对象则不能向这个对象添加新的属性，不能删除已有属性，不能修改该对象已有属性的可枚举性、可配置性、可写性， ...",l:"audition/js/objectprototype.html#object-freeze",a:"object-freeze"},"20.10":{t:"Object.fromEntries() \r",p:`Object.fromEntries() 方法把键值对列表转换为一个对象。
const entries = new Map([
  ['foo', 'bar'],
  ['baz', 42]
]);
 ...`,l:"audition/js/objectprototype.html#object-fromentries",a:"object-fromentries"},"20.11":{t:"Object.getPrototypeOf()\r",p:`Object.getPrototypeOf() 方法返回指定对象的原型（内部[[Prototype]]属性的值）。
`,l:"audition/js/objectprototype.html#object-getprototypeof",a:"object-getprototypeof"},"20.12":{t:"语法\r",p:`Object.getPrototypeOf(object)

object:要返回其原型的对象。
返回值:给定对象的原型。如果没有继承属性，则返回 null 。

const prototype1 = ...`,l:"audition/js/objectprototype.html#语法",a:"语法"},"20.13":{t:"Object.setPrototypeOf()\r",p:`Object.setPrototypeOf() 方法设置一个指定的对象的原型（即，内部[[Prototype]] 属性）到另一个对象或 null。
Object.setPrototypeOf(obj, ...`,l:"audition/js/objectprototype.html#object-setprototypeof",a:"object-setprototypeof"},"20.14":{t:"Object.prototype.isPrototypeOf()\r",p:`isPrototypeOf() 方法用于测试一个对象是否存在于另一个对象的原型链上。针对对象本身，不是对象.prototype
prototypeObj.isPrototypeOf(object)

 ...`,l:"audition/js/objectprototype.html#object-prototype-isprototypeof",a:"object-prototype-isprototypeof"},"20.15":{t:"instanceof\r",p:"instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。在表达式 &quot;object instanceof AFunction&quot;中，o ...",l:"audition/js/objectprototype.html#instanceof",a:"instanceof"},"20.16":{t:"Object.getOwnPropertyDescriptor()\r",p:`Object.getOwnPropertyDescriptor() 方法返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）
const  ...`,l:"audition/js/objectprototype.html#object-getownpropertydescriptor",a:"object-getownpropertydescriptor"},"20.17":{t:"Object.getOwnPropertyNames()\r",p:`
Object.getOwnPropertyNames() 方法返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括 Symbol 值作为名称的属性）组成的数组。
返回一个数组，该数组对 ...`,l:"audition/js/objectprototype.html#object-getownpropertynames",a:"object-getownpropertynames"},"20.18":{t:"Object.getOwnPropertySymbols()\r",p:`Object.getOwnPropertySymbols() 方法返回一个给定对象自身的所有 Symbol 属性的数组。
var obj = {};
var a = Symbol(&quot;a&qu ...`,l:"audition/js/objectprototype.html#object-getownpropertysymbols",a:"object-getownpropertysymbols"},"20.19":{t:"Object.hasOwn()\r",p:`如果指定的对象自身有指定的属性，则静态方法 Object.hasOwn() 返回 true。如果属性是继承的或者不存在，该方法返回 false。
const object1 = {
  prop: ' ...`,l:"audition/js/objectprototype.html#object-hasown",a:"object-hasown"},"20.20":{t:"Object.prototype.hasOwnProperty()\r",p:`hasOwnProperty() 方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性（也就是，是否有指定的键）。

属性值为null或undefind时也会返回true，有值就会返回true
 ...`,l:"audition/js/objectprototype.html#object-prototype-hasownproperty",a:"object-prototype-hasownproperty"},"20.21":{t:"Object.is() \r",p:`Object.is() 方法判断两个值是否为同一个值。返回一个布尔值
Object.is(value1, value2);
Object.is() 方法判断两个值是否为同一个值，如果满足以下任意条件则 ...`,l:"audition/js/objectprototype.html#object-is",a:"object-is"},"20.22":{t:"Object.is() 与 ==和===\r",p:`
Object.is() 与 == 不同。== 运算符在判断相等前对两边的变量（如果它们不是同一类型）进行强制转换（这种行为将 &quot;&quot; == false 判断为 true），而 Ob ...`,l:"audition/js/objectprototype.html#object-is-与-和",a:"object-is-与-和"},"20.23":{t:"Object.isExtensible()\r",p:`Object.isExtensible() 方法判断一个对象是否是可扩展的（是否可以在它上面添加新的属性）。
`,l:"audition/js/objectprototype.html#object-isextensible",a:"object-isextensible"},"20.24":{t:"Object.isFrozen(obj)\r",p:`Object.isFrozen() 方法判断一个对象是否被冻结。
`,l:"audition/js/objectprototype.html#object-isfrozen-obj",a:"object-isfrozen-obj"},"20.25":{t:"Object.keys()\r",p:`Object.keys() 方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和正常循环遍历该对象时返回的顺序一致。
const object1 = {
  a: 'som ...`,l:"audition/js/objectprototype.html#object-keys",a:"object-keys"},"20.26":{t:"Object.values()\r",p:`Object.values() 方法返回一个给定对象自身的所有可枚举属性值的数组，值的顺序与使用 for...in 循环的顺序相同（区别在于 for-in 循环枚举原型链中的属性）。
var obj  ...`,l:"audition/js/objectprototype.html#object-values",a:"object-values"},"20.27":{t:"Object.preventExtensions()\r",p:`Object.preventExtensions() 方法让一个对象变的不可扩展，也就是永远不能再添加新的属性。
`,l:"audition/js/objectprototype.html#object-preventextensions",a:"object-preventextensions"},"20.28":{t:"Object.prototype.propertyIsEnumerable()\r",p:`propertyIsEnumerable() 方法返回一个布尔值，表示指定的属性是否可枚举。
`,l:"audition/js/objectprototype.html#object-prototype-propertyisenumerable",a:"object-prototype-propertyisenumerable"},"20.29":{t:"Object.seal()\r",p:`Object.seal()方法封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置。当前属性的值只要原来是可写的就可以改变。
`,l:"audition/js/objectprototype.html#object-seal",a:"object-seal"},"20.30":{t:"Object.prototype.toString()\r",p:`toString() 方法返回一个表示该对象的字符串。该方法旨在重写（自定义）派生类对象的类型转换的逻辑。

默认情况下，toString() 不接受任何参数。然而，继承自 Object 的对象可能用 ...`,l:"audition/js/objectprototype.html#object-prototype-tostring",a:"object-prototype-tostring"},"20.31":{t:"Object.prototype.valueOf()\r",p:`Object 的 valueOf() 方法将 this 值转换为一个对象。此方法旨在用于自定义类型转换的逻辑时，重写派生类对象。
function MyNumberType(n) {
  this.n ...`,l:"audition/js/objectprototype.html#object-prototype-valueof",a:"object-prototype-valueof"},"20.32":{t:"\r",p:"\r",l:"audition/js/objectprototype.html#",a:""},"20.33":{t:"\r",p:"\r",l:"audition/js/objectprototype.html#",a:""},"20.34":{t:"\r",p:"\r",l:"audition/js/objectprototype.html#",a:""},"20.35":{t:"\r",p:"\r",l:"audition/js/objectprototype.html#",a:""},"20.36":{t:"\r",p:"\r",l:"audition/js/objectprototype.html#",a:""},"20.37":{t:"\r",p:"\r",l:"audition/js/objectprototype.html#",a:""},"20.38":{t:"\r",p:"\r",l:"audition/js/objectprototype.html#",a:""},"20.39":{t:"\r",p:"\r",l:"audition/js/objectprototype.html#",a:""},"20.40":{t:"\r",p:"\r",l:"audition/js/objectprototype.html#",a:""},"20.41":{t:"\r",p:"\r",l:"audition/js/objectprototype.html#",a:""},"20.42":{t:"\r",p:"\r",l:"audition/js/objectprototype.html#",a:""},"20.43":{t:"\r",p:`
`,l:"audition/js/objectprototype.html#",a:""},"21.0":{t:"# promise\r",p:`
promise是es6处理异步的一种方式，它的本质是一个对象,
当我们new一个promise，此时我们需要传递一个回调函数，这个函数为立即执行的，称之为（executor）
回调有两个参数 res ...`,l:"audition/js/promise.html",a:"promise"},"21.1":{t:"reject和catch\r",p:`// 一、
promise.then((res) =&gt; {
    console.log('then:', res);
}).catch((err) =&gt; {
    console.l ...`,l:"audition/js/promise.html#reject和catch",a:"reject和catch"},"21.2":{t:"promise的状态\r",p:`
它有三种状态分别为 初始状态pending 已完成fulfilled 已失败rejected。

pending(待定)，执行了executor，状态还在等待中，没有被兑现，也没有被拒绝
fulfi ...`,l:"audition/js/promise.html#promise的状态",a:"promise的状态"},"21.3":{t:"resolve不同值的区别\r",p:`
如果resolve传入一个普通的值或者对象，只能传递接受一个参数，那么这个值会作为then回调的参数

const promise = new Promise((resolve, reject) = ...`,l:"audition/js/promise.html#resolve不同值的区别",a:"resolve不同值的区别"},"21.4":{t:"Promise的实例方法\r",p:`
实例方法，存放在Promise.prototype上的方法，也就是Promise的原型对象上，当我new Promise的时候，会把返回的该对象的 promise[[prototype]]（对象原型 ...`,l:"audition/js/promise.html#promise的实例方法",a:"promise的实例方法"},"21.5":{t:"then方法\r",p:`
then方法可以接受参数，一个参数为成功的回调，另一个参数为失败的回调。

const promise = new Promise((resolve,reject)=&gt;{
   resolve ...`,l:"audition/js/promise.html#then方法",a:"then方法"},"21.6":{t:"catch方法\r",p:`
catch的多次调用

const promise = new Promise((resolve, reject) =&gt; {
  reject('ice error')
})

promise ...`,l:"audition/js/promise.html#catch方法",a:"catch方法"},"21.7":{t:"finally方法\r",p:`无论promise状态是fulfilled还是rejected都会执行一次finally方法
const promise = new Promise((resolve, reject) =&gt; { ...`,l:"audition/js/promise.html#finally方法",a:"finally方法"},"21.8":{t:"Promise中的类方法/静态方法\r",p:`
Promise.resolve

Promise.resolve('ice')
//等价于
new Promise((resolve, reject) =&gt; resolve('ice'))

 ...`,l:"audition/js/promise.html#promise中的类方法-静态方法",a:"promise中的类方法-静态方法"},"21.9":{t:"promise其他\r",p:`resolve里储存异步数据，外部则还是同步的
function fn() {
    return new Promise((res) =&gt; {
        console.log(&qu ...`,l:"audition/js/promise.html#promise其他",a:"promise其他"},"21.10":{t:"acync await\r",p:`
acync里面没有await则不起作用相当于还是同步的
await调用函数后，当前函数后的所有代码会被放进微任务队列

async function fn2(){
    console.log(& ...`,l:"audition/js/promise.html#acync-await",a:"acync-await"},"22.0":{t:"# SET&MAP\r",p:"",l:"audition/js/SET&MAP.html",a:"set-map"},"22.1":{t:"Set(集合)\r",p:`Set 是一种叫做集合的数据结构

向 Set 加入值的时候，不会发生类型转换，所以5和&quot;5&quot;是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value- ...`,l:"audition/js/SET&MAP.html#set-集合",a:"set-集合"},"22.2":{t:"Set 实例属性\r",p:`
constructor： 构造函数
size：元素数量

let set = new Set([1, 2, 3, 2, 1])

console.log(set.length)    // unde ...`,l:"audition/js/SET&MAP.html#set-实例属性",a:"set-实例属性"},"22.3":{t:"Set 实例方法\r",p:`
delete(value)：存在即删除集合中value
has(value)：判断集合中是否存在 value
clear()：清空集合
keys()：返回一个包含集合中所有键的迭代器
values( ...`,l:"audition/js/SET&MAP.html#set-实例方法",a:"set-实例方法"},"22.4":{t:"转为数组\r",p:`Array.from方法可以将 Set 结构转为数组
const items = new Set([1, 2, 3, 2])
const array = Array.from(items)
conso ...`,l:"audition/js/SET&MAP.html#转为数组",a:"转为数组"},"22.5":{t:"所以Set可以使用数组里的 map、filter 方法\r",p:`let set = new Set([1, 2, 3])
set = new Set([...set].map(item =&gt; item * 2))
console.log([...set])  ...`,l:"audition/js/SET&MAP.html#所以set可以使用数组里的-map、filter-方法",a:"所以set可以使用数组里的-map、filter-方法"},"22.6":{t:"因此，Set 很容易实现交集（Intersect）、并集（Union）、差集（Difference）\r",p:`let set1 = new Set([1, 2, 3])
let set2 = new Set([1, 3, 4])
let intersect = new Set([...set1].filter ...`,l:"audition/js/SET&MAP.html#因此-set-很容易实现交集-intersect-、并集-union-、差集-difference",a:"因此-set-很容易实现交集-intersect-、并集-union-、差集-difference"},"22.7":{t:"Map(字典) \r",p:`参考
集合 与 字典 的区别：

共同点：集合、字典 可以储存不重复的值
不同点：集合 是以 [value, value]的形式储存元素，字典 是以 [key, value] 的形式储存

const ...`,l:"audition/js/SET&MAP.html#map-字典",a:"map-字典"},"22.8":{t:"属性方法\r",p:`
constructor：构造函数
size：返回字典中所包含的元素个数
set(key, value)：向字典中添加新元素
get(key)：通过键查找特定的数值并返回
has(key)：判断字典中 ...`,l:"audition/js/SET&MAP.html#属性方法",a:"属性方法"},"22.9":{t:"Map 转 Object\r",p:`function map2obj (map){
    let obj = Object.creat(null)
    for (let [key,value] of maps){
         ...`,l:"audition/js/SET&MAP.html#map-转-object",a:"map-转-object"},"22.10":{t:"Object 转 Map\r",p:`function obj2map (obj){
    let map = new Map()
    for (let key of Object.keys[obj]){
        map.s ...`,l:"audition/js/SET&MAP.html#object-转-map",a:"object-转-map"},"22.11":{t:"weakmap、map\r",p:`
map的键值对可以使基本数据类型，也可以是对象引用，weakmap只能是对象引用
Map中的键值对在不再被引用时不会被垃圾回收，除非Map对象本身被垃圾回收。而WeakMap中的键是弱引用，当对应的 ...`,l:"audition/js/SET&MAP.html#weakmap、map",a:"weakmap、map"},"23.0":{t:"# this\r",p:"\r",l:"audition/js/this.html",a:"this"},"23.1":{t:"node环境和浏览器环境\r",p:`

在 Node.js 环境下，全局的 this 指向的是一个空对象 {}，也就是说，如果在 Node.js 环境下，直接访问 this，得到的是一个空对象。在 Node.js 模块中，每个模块都有自 ...`,l:"audition/js/this.html#node环境和浏览器环境",a:"node环境和浏览器环境"},"23.2":{t:"this方法\r",p:`在 JavaScript 中，this 的值一般有以下几种情况：


全局作用域中的 this：在全局作用域中调用 this 时，它的值指向全局对象，即在浏览器中指向 window 对象，在 Node ...`,l:"audition/js/this.html#this方法",a:"this方法"},"23.3":{t:"this指向的四种情况？\r",p:`
new操作符创建实例

function Person(name) {
  this.name = name
  console.log(this)
}
// this指向当前person实例对象
 ...`,l:"audition/js/this.html#this指向的四种情况",a:"this指向的四种情况"},"23.4":{t:"apply、call、bind三者的区别\r",p:`
三者都可以改变函数的this对象指向
三者第一个参数都是this要指向的对象，如果如果没有这个参数或参数为undefined或null，则默认指向全局window
三者都可以传参，但是apply是数 ...`,l:"audition/js/this.html#apply、call、bind三者的区别",a:"apply、call、bind三者的区别"},"24.0":{t:"# 运算符\r",p:"",l:"audition/js/yunsuanfu.html",a:"运算符"},"24.1":{t:"==\r",p:`相等运算符（==）检查其两个操作数是否相等，返回一个布尔值结果。与严格相等运算符（===）不同，它会比较不同类型的操作数，并尝试强制类型转换。
`,l:"audition/js/yunsuanfu.html#",a:""},"24.2":{t:"隐式转换\r",p:`相等运算符（==）最终转换为数字进行比较
&quot;a&quot; -&gt; NaN
{} -&gt; NaN
undefined -&gt; NaN
NaN -&gt; NaN
[] -&gt; ...`,l:"audition/js/yunsuanfu.html#隐式转换",a:"隐式转换"},"24.3":{t:"优先级\r",p:`JavaScript 中一些常见运算符的优先级
从高到低：

括号：()
成员访问：.、[]
函数调用：()
后缀运算符：++、--
前缀运算符：+、-、!、typeof、void、await
乘法运 ...`,l:"audition/js/yunsuanfu.html#优先级",a:"优先级"},"25.0":{t:"同域名下的单点登录\r",p:`
将Cookie的domain属性设置为父域的域名（主域名），同时将 Cookie的path属性设置为根路径，将 Session ID（或 Token）保存到父域中。这样所有的子域应用就都可以访问到这 ...`,l:"audition/js/单点登录.html",a:"同域名下的单点登录"},"25.1":{t:"不同域名下的单点登录(一)\r",p:`

用户访问app系统，app系统是需要登录的，但用户现在没有登录。


跳转到SSO登录系统， SSO系统也没有登录，弹出用户登录页。


用户填写用户名、密码，SSO系统进行认证后，将登录状态写入 ...`,l:"audition/js/单点登录.html#不同域名下的单点登录-一",a:"不同域名下的单点登录-一"},"26.0":{t:"# 数组\r",p:"\r",l:"audition/js/数组方法.html",a:"数组"},"26.1":{t:"数组的方法\r",p:`
静态方法：

Array.from() 从可迭代或者类数组对象创建一个浅拷贝的数组实例
Array.of()  创建一个数组，参数是数组的值
Array()  创建一个数组，参数是数组的长度，值为0 ...`,l:"audition/js/数组方法.html#数组的方法",a:"数组的方法"},"26.2":{t:"数组去重\r",p:"\r",l:"audition/js/数组方法.html#数组去重",a:"数组去重"},"26.3":{t:"数组找一个值的方法\r",p:"\r",l:"audition/js/数组方法.html#数组找一个值的方法",a:"数组找一个值的方法"},"26.4":{t:"entries\r",p:`通过使用迭代器和解构赋值把索引和值一起返回
const words = [&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;];
for ...`,l:"audition/js/数组方法.html#entries",a:"entries"},"26.5":{t:"copywithin\r",p:`copyWithin()
将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组
参数如下：
target（必需）：从该位置开始替换数据。如果为负值，表示倒数。
start（可选）：从该位 ...`,l:"audition/js/数组方法.html#copywithin",a:"copywithin"},"27.0":{t:"JavaScript中的正则表达式（Regular Expression，简称RegExp）是一种强大的文本匹配工具，它可以用来查找、替换、分割文本等。\r",p:`下面是一些基本的正则表达式语法和用法：

创建正则表达式对象
您可以使用RegExp构造函数来创建正则表达式对象：

var regex = new RegExp(pattern, flags);

 ...`,l:"audition/js/正则表达式.html",a:"javascript中的正则表达式-regular-expression-简称regexp-是一种强大的文本匹配工具-它可以用来查找、替换、分割文本等。"},"28.0":{t:"# 项目\r",p:"",l:"audition/js/项目.html",a:"项目"},"28.1":{t:"组件时怎么封装的\r",p:`
先把组件样式写好，然后为每个组件配置一个公共代码，定义一个方法组建作为参数传入，内部为组件添加install函数，并且通过app.component注册组件，在通过export导出
创建一个声明文件 ...`,l:"audition/js/项目.html#组件时怎么封装的",a:"组件时怎么封装的"},"28.2":{t:"表单样式\r",p:`表单输入框，常规，禁用，尺寸，一键清空，密码显示隐藏，带icon图标，文本域自适应宽高，复合型输入框

Input组件的核心功能:双向数据绑定,原生input的v-model其实就是:value @i ...`,l:"audition/js/项目.html#表单样式",a:"表单样式"},"28.3":{t:"glup打包样式文件\r",p:`因为vite打包样式文件是会把所有的组件的样式合并到一个css文件中，每次都要全部引入所有的样式文件，做不到按需加载，样式文件将使用 gulp 进行打包
`,l:"audition/js/项目.html#glup打包样式文件",a:"glup打包样式文件"},"28.4":{t:"为什么选择gulp\r",p:"gulp很方便，不仅仅是打包css文件，经常用的一个series和parallel定义执行任务顺序执行并行执行，比如说打包时先删除之前的打包文件再打包，可以用series规定执行顺序，样式打包和组件打 ...",l:"audition/js/项目.html#为什么选择gulp",a:"为什么选择gulp"},"28.5":{t:"ts用在哪些方面\r",p:`在组件库上ts主要用来写打包的配置文件，执行命令的函数，删除之前的打包文件函数，获取路径的函数，在js的基础上声明了变量
`,l:"audition/js/项目.html#ts用在哪些方面",a:"ts用在哪些方面"},"28.6":{t:"axios怎么进行二次封装的\r",p:`把api放在一个文件，把请求的地址放在一个文件，写了一个配置文件，在里面重新定义了各种请求错误信息，和一个timeout，和一个获取数据之前的拦截器
`,l:"audition/js/项目.html#axios怎么进行二次封装的",a:"axios怎么进行二次封装的"},"28.7":{t:"怎么用的pinia\r",p:"pinia里存放了一个data是一个空数组，用来存放从服务器拿到的数据，在pinia的配置文件里写项目要用到的actions（方法）和getters（获取器），actions写一些复杂的逻辑和异步逻辑 ...",l:"audition/js/项目.html#怎么用的pinia",a:"怎么用的pinia"},"28.8":{t:"Node.js构建的后端服务器怎么写的\r",p:`用的express写的一些get、post等请求，通过中间件设置了querystring模块来解析请求体，设置了允许跨域的响应头
`,l:"audition/js/项目.html#node-js构建的后端服务器怎么写的",a:"node-js构建的后端服务器怎么写的"},"28.9":{t:"前后端分离\r",p:`
并行开发：前后端分离允许前端和后端团队并行开发，不受彼此的依赖关系限制。这可以显著加快整个开发过程，提高团队的效率。
更好的扩展性：由于前后端分离的松耦合性，您可以更容易地扩展和升级应用程序的不同部 ...`,l:"audition/js/项目.html#前后端分离",a:"前后端分离"},"28.10":{t:"http23\r",p:`HTTP/2：

HTTP/2是HTTP/1.1的升级版本，于2015年发布。它引入了一些重要的改进，其中最显著的是多路复用（multiplexing）功能。
多路复用允许在单个TCP连接上同时发送多 ...`,l:"audition/js/项目.html#http23",a:"http23"},"28.11":{t:"https mitm\r",p:`在HTTPS通信中，中间人攻击（Man-in-the-Middle Attack，缩写为MITM攻击）是一种攻击方式，攻击者试图在通信双方之间插入自己以截获、篡改或窃取通信内容。
正常的HTTPS通信 ...`,l:"audition/js/项目.html#https-mitm",a:"https-mitm"},"28.12":{t:"静态资源缓存\r",p:`配置资源文件的缓存可以通过使用HTTP响应头中的Cache-Control和Expires字段来实现。这些字段可以告诉客户端（浏览器）如何缓存和重新获取资源文件。
使用Cache-Control字段： ...`,l:"audition/js/项目.html#静态资源缓存",a:"静态资源缓存"},"28.13":{t:"layout shift 布局偏移\r",p:"布局偏移（Layout Shift）是指在网页加载过程中，元素的位置发生了突然而意外的变化，可能会导致用户体验的不良影响。这种突然的变化可能会使用户点击错位或产生其他交互问题，影响网页的可用性和可读性 ...",l:"audition/js/项目.html#layout-shift-布局偏移",a:"layout-shift-布局偏移"},"28.14":{t:"优化跨端应用性能\r",p:`代码优化：

选择高效的框架和库：选择经过优化和性能良好的框架和库，以确保代码执行效率和响应速度。
减少重绘和回流：避免频繁的DOM操作，合并多个操作，减少页面重绘和回流，提高性能。
优化网络请求：减 ...`,l:"audition/js/项目.html#优化跨端应用性能",a:"优化跨端应用性能"},"28.15":{t:"webgpu\r",p:`WebGPU是一种新兴的Web标准，旨在为Web开发者提供直接访问图形硬件的低级别图形编程接口。它是WebGL的继任者，旨在提供更高效、更可编程和更现代化的图形处理能力。
`,l:"audition/js/项目.html#webgpu",a:"webgpu"},"28.16":{t:"pnpm和npm\r",p:`而pnpm使用硬链接技术，跳过了解压的过程

速度
空间占用
并发安装
pnpm使用一种称为&quot;锁定文件链接&quot;的机制，将项目的依赖版本信息存储在单独的pnpm-lock.yaml文件 ...`,l:"audition/js/项目.html#pnpm和npm",a:"pnpm和npm"},"28.17":{t:"monorepo\r",p:`Monorepo（单一代码仓库）是一种软件开发模式，它将多个相关的项目或组件放置在同一个代码仓库中管理

Lerna
Yarn Workspaces

`,l:"audition/js/项目.html#monorepo",a:"monorepo"},"29.0":{t:"# Node.js\r",p:"\r",l:"audition/node/nodejs.html",a:"node-js"},"29.1":{t:"Node.js 如何处理 ES6 模块\r",p:`学习 JavaScript 语言，你会发现它有两种格式的模块。&lt;br&gt;
一种是 ES6 模块，简称 ESM；另一种是 Node.js 专用的 CommonJS 模块，简称 CJS。这两种模 ...`,l:"audition/node/nodejs.html#node-js-如何处理-es6-模块",a:"node-js-如何处理-es6-模块"},"29.2":{t:"两种模块的差异\r",p:"语法上面，CommonJS 模块使用require()加载一个模块对象和module.exports输出一个模块对象，ES6 模块使用import引入具体数据和export导出指定数据。&lt;br& ...",l:"audition/node/nodejs.html#两种模块的差异",a:"两种模块的差异"},"29.3":{t:"两种模块的区分\r",p:"Node.js 要求 ES6 模块采用.mjs后缀文件名。也就是说，只要脚本文件里面使用import或者export命令，那么就必须采用.mjs后缀名。Node.js 遇到.mjs文件，就认为它是 E ...",l:"audition/node/nodejs.html#两种模块的区分",a:"两种模块的区分"},"29.4":{t:"加载 \r",p:`ES6 模块import命令可以加载 CommonJS 模块，但是只能整体加载，不能只加载单一的输出项，但是可以这样写：
import packageMain from 'commonjs-packa ...`,l:"audition/node/nodejs.html#加载",a:"加载"},"29.5":{t:"同时支持两种格式的模块\r",p:`是在package.json文件的exports字段，指明两种格式模块各自的加载入口。
&quot;exports&quot;：{ 
    &quot;require&quot;: &quot;./ ...`,l:"audition/node/nodejs.html#同时支持两种格式的模块",a:"同时支持两种格式的模块"},"29.6":{t:"nodejs的内置模块\r",p:`可以直接在node中使用
`,l:"audition/node/nodejs.html#nodejs的内置模块",a:"nodejs的内置模块"},"29.7":{t:"process\r",p:`process表示控制当前node进程

process.exit()结束进程
process.nextTick(()=&gt;{})将函数插入到tick队列
process.nextTick的优先级 ...`,l:"audition/node/nodejs.html#process",a:"process"},"29.8":{t:"Path\r",p:`获取文件夹路径

path.resolve([...path]) 绝对路径，如果是相对路径则自动转为绝对路径
path.resolve(__dirname, path)

`,l:"audition/node/nodejs.html#path",a:"path"},"29.9":{t:"Fs\r",p:`读取磁盘中的文件

fs.readFile
fs.appendFile
fs.mkdir
fs.rmdir

`,l:"audition/node/nodejs.html#fs",a:"fs"},"29.10":{t:"node是单线程的怎么做高并发\r",p:`Node.js 通过非阻塞 I/O、异步编程和事件循环等机制，以及多进程和集群的方式，实现了高并发处理能力
`,l:"audition/node/nodejs.html#node是单线程的怎么做高并发",a:"node是单线程的怎么做高并发"},"29.11":{t:"\r",p:"\r",l:"audition/node/nodejs.html#",a:""},"29.12":{t:"",p:`
`,l:"audition/node/nodejs.html#",a:""},"30.0":{t:"1. 存储\r",p:`cookie、localstorage和sessionStorage三者都是在开发中用到的临时存储客户端会话信息或者数据的方法
`,l:"audition/node/node的存储.html",a:"_1-存储"},"30.1":{t:"存储的时间有效期不同\r",p:`
cookie的有效期是可以设置的，默认的情况下是关闭浏览器后失效
sessionStorage的有效期是仅保持在当前页面，关闭当前会话页或者浏览器后就会失效
localStorage的有效期是在不进 ...`,l:"audition/node/node的存储.html#存储的时间有效期不同",a:"存储的时间有效期不同"},"30.2":{t:"存储的大小不同\r",p:`
cookie的存储是4kb左右，存储量较小，一般页面最多存储20条左右信息
localStorage和sessionStorage的存储容量是5Mb(官方介绍，可能和浏览器有部分差异性)

`,l:"audition/node/node的存储.html#存储的大小不同",a:"存储的大小不同"},"30.3":{t:"与服务端的通信\r",p:`
cookie会参与到与服务端的通信中，一般会携带在http请求的头部中，例如一些关键密匙验证等。
localStorage和sessionStorage是单纯的前端存储，不参与与服务端的通信

`,l:"audition/node/node的存储.html#与服务端的通信",a:"与服务端的通信"},"30.4":{t:"操作\r",p:`
cookie

cookie的创建（修改和创建相同，创建同样名称会覆盖之前的）document.cookie=&quot;username=John Doe&quot;
cookie的读取 var  ...`,l:"audition/node/node的存储.html#操作",a:"操作"},"30.5":{t:"对于浏览器的支持\r",p:`
cookie出现的时间较早，目前见到的浏览器都支持
localStorage和sessionStorage出现的时间较晚，对于版本较低的浏览器不支持(比如IE8版本以下的都不支持)

`,l:"audition/node/node的存储.html#对于浏览器的支持",a:"对于浏览器的支持"},"30.6":{t:"2. 什么是token？token是用来干嘛的 \r",p:"\r",l:"audition/node/node的存储.html#_2-什么是token-token是用来干嘛的",a:"_2-什么是token-token是用来干嘛的"},"30.7":{t:"token\r",p:"是“令牌”的意思。Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即 ...",l:"audition/node/node的存储.html#token",a:"token"},"30.8":{t:"是用来干嘛的\r",p:`使用token机制的身份验证方法

客户端使用用户名和密码请求登录  客户端 --&gt; 服务端
服务端收到请求，验证用户名和密码   **服务端验证 --&gt; 生成token
验证成功后，服务 ...`,l:"audition/node/node的存储.html#是用来干嘛的",a:"是用来干嘛的"},"30.9":{t:"token存在哪里\r",p:`
存localStorage里，后期每次请求接口都需要把他当做一个字段传给后台，会有xss攻击
存cookie里，会自动发送，缺点不能跨域，会有csrf攻击

`,l:"audition/node/node的存储.html#token存在哪里",a:"token存在哪里"},"30.10":{t:"cookie\r",p:`Cookie是一种在客户端（浏览器）存储数据的机制，它允许服务器在浏览器中存储少量的数据，并在需要时读取这些数据。常见的使用场景包括用户认证、购物车、网站偏好设置等。
Cookie是由服务器发送给浏览 ...`,l:"audition/node/node的存储.html#cookie",a:"cookie"},"31.0":{t:"# vite\r",p:`相较于webpack，vite采用不同方式

开发时，并不对代码打包，直接用ESM方式来运行项目
在项目部署再打包

`,l:"audition/pack/vite.html",a:"vite"},"31.1":{t:"命令\r",p:`&quot;scripts&quot;: 
{
&quot;dev&quot;: &quot;vite&quot;,
&quot;build&quot;: &quot;vite build&quot; ...`,l:"audition/pack/vite.html#命令",a:"命令"},"31.2":{t:"vite脚手架\r",p:`pnpm create vite
`,l:"audition/pack/vite.html#vite脚手架",a:"vite脚手架"},"31.3":{t:"vite.config.js\r",p:`配置文件采用ES6模块化规范
可以使用 defineConfig 工具函数，可以获取类型提示
`,l:"audition/pack/vite.html#vite-config-js",a:"vite-config-js"},"32.0":{t:"# webpack\r",p:`使用步骤：

初始化项目 pnpm init
安装webpack，webpackcil
在项目中创建src目录，写代码默认(index.js)
在终端执行pnpm webpack 默认在dist的ma ...`,l:"audition/pack/webpack.html",a:"webpack"},"32.1":{t:"webpack.config.js\r",p:`配置文件采用commonjs模块化规范
`,l:"audition/pack/webpack.html#webpack-config-js",a:"webpack-config-js"},"32.2":{t:"mode\r",p:`mode：production生产模式，development开发模式
`,l:"audition/pack/webpack.html#mode",a:"mode"},"32.3":{t:"entry\r",p:`entry:

单一入口，打包成一个文件
[]数组形式里写多个入口，打包成一个文件

entry:['./src/file_1.js', './src/file_2.js']


{}对象里写多个入口 ...`,l:"audition/pack/webpack.html#entry",a:"entry"},"32.4":{t:"output\r",p:`output:

{filename:&quot;boundle.js&quot;}
文件名不一样之前打包的不会删除，{filename:&quot;boundle.js&quot;,clean:tr ...`,l:"audition/pack/webpack.html#output",a:"output"},"32.5":{t:"loader\r",p:"webpack 只能理解 JavaScript 和 JSON 文件，这是 webpack 开箱可用的自带能力。loader 让 webpack 能够去处理其他类型的文件，并将它们转换为有效 模块，以供 ...",l:"audition/pack/webpack.html#loader",a:"loader"},"32.6":{t:"bable\r",p:`兼容问题，将新代码转为旧代码，提高兼容性
配置
rules:[
   {
    test: /\\.m?js$/,
    exclude: /(node_modules|bower_componen ...`,l:"audition/pack/webpack.html#bable",a:"bable"},"32.7":{t:"plugin\r",p:`插件 是 webpack 的 支柱 功能。Webpack 自身也是构建于你在 webpack 配置中用到的 相同的插件系统 之上！
插件目的在于解决 loader 无法实现的其他事。
plugins: ...`,l:"audition/pack/webpack.html#plugin",a:"plugin"},"32.8":{t:"webpack-dev-server\r",p:`启动一个本地开发服务器，把代码部署到服务器上，实时自动刷新

提供静态资源的服务（express）和Socket服务
socket server 是一个 websocket 的长连接，双方可以通信

`,l:"audition/pack/webpack.html#webpack-dev-server",a:"webpack-dev-server"},"32.9":{t:"devtool&sourcemap\r",p:`devtool:&quot;inline-source-map&quot;,此选项控制是否生成，以及如何生成 source map。
代码经过打包后会被压缩，让调试和错误定位边的非常困难，Source ...`,l:"audition/pack/webpack.html#devtool-sourcemap",a:"devtool-sourcemap"},"33.0":{t:"最全前端八股文\r",p:`这里是 html 的面试题

这里是 css 的面试题

这里是 jvavscript 的面试题

这里是 ES6 的面试题

这里是 vue 的面试题

这里是 TypeScript 的面试题

这 ...`,l:"audition/question.html",a:"最全前端八股文"},"34.0":{t:"# 基础知识\r",p:"\r",l:"audition/react/basic.html",a:"基础知识"},"34.1":{t:"React 特性有很多\r",p:`
JSX 语法
单向数据绑定,用户操作action，触发setstate更新seate
虚拟 DOM
声明式编程
Component

`,l:"audition/react/basic.html#react-特性有很多",a:"react-特性有很多"},"34.2":{t:"如何避免不必要的render？\r",p:`
在React 中，类组件只要执行了setState 方法，就一定会触发 render 函数执行
函数组件useState会判断当前值有无发生改变确定是否执行render方法，一旦父组件发生渲染，子组 ...`,l:"audition/react/basic.html#如何避免不必要的render",a:"如何避免不必要的render"},"34.3":{t:"请求数据的时机\r",p:`
vue是在组件实例创建之后DOM挂载之前拿数据，created,setup

模板与数据的绑定，确保数据在DOM挂载时已经准备好了，通过Vue的响应式系统来实现数据的自动更新。


react是在组 ...`,l:"audition/react/basic.html#请求数据的时机",a:"请求数据的时机"},"34.4":{t:"函数组件和类组件\r",p:`函数组件和类组件是 React 中两种主要的组件类型，它们在语法和用法上有一些区别。

语法：函数组件是以函数的形式定义的组件，使用函数声明或函数表达式的方式创建。而类组件是以 ES6 类的形式定义的 ...`,l:"audition/react/basic.html#函数组件和类组件",a:"函数组件和类组件"},"34.5":{t:"类组件的生命周期\r",p:`挂载阶段：componentWillMount （17废弃）- render - componentDidMount
更新阶段：componentWillReceiveProps  （17废弃）- s ...`,l:"audition/react/basic.html#类组件的生命周期",a:"类组件的生命周期"},"34.6":{t:"react17之后\r",p:`
挂载阶段（Mounting Phase）：

constructor：组件被创建时调用，用于初始化状态和绑定方法。
static getDerivedStateFromProps：在组件实例化和更新 ...`,l:"audition/react/basic.html#react17之后",a:"react17之后"},"34.7":{t:"static getDerivedStateFromProps(nextProps, prevState)\r",p:`
该生命周期在 render方法之前调用，在初始化和后续更新都会被调用
它接收两个参数，一个是传进来的 nextProps 和之前的 prevState。
他应该返回一个对象来更新 state。如果返 ...`,l:"audition/react/basic.html#static-getderivedstatefromprops-nextprops-prevstate",a:"static-getderivedstatefromprops-nextprops-prevstate"},"34.8":{t:"getSnapshotBeforeUpdate(prevProps, prevState)\r",p:`在更新阶段 render 后挂载到真实 DOM 前进行的操作，它使得组件能在发生更改之前从 DOM 中捕获一些信息。此组件返回的任何值将作为 componentDidUpdate 的第三个参数。

  ...`,l:"audition/react/basic.html#getsnapshotbeforeupdate-prevprops-prevstate",a:"getsnapshotbeforeupdate-prevprops-prevstate"},"34.9":{t:"有状态组件和无状态组件\r",p:`

有状态组件是指在其内部维护了状态（state）的组件。这种组件通常是通过继承 React.Component 或 React.PureComponent 来创建的，也可以使用 React Hook ...`,l:"audition/react/basic.html#有状态组件和无状态组件",a:"有状态组件和无状态组件"},"34.10":{t:"react的响应式原理\r",p:`
从底层实现来看修改数据：在react中，组件的状态是不能被修改的，setState没有修改原来那块内存中的变量，而是去新开辟一块内存； 而vue则是直接修改保存状态的那块原始内存。
数据修改了，接下 ...`,l:"audition/react/basic.html#react的响应式原理",a:"react的响应式原理"},"34.11":{t:"react fiber\r",p:"react fiber使得diff的过程被分成一小段一小段的，因为它有了“保存工作进度”的能力。js会比较一部分虚拟dom，然后让渡主线程，给浏览器去做其他工作，然后继续比较，依次往复，等到最后比较完 ...",l:"audition/react/basic.html#react-fiber",a:"react-fiber"},"34.12":{t:"为什么vue不用fiber\r",p:`
react因为先天的不足——无法精确更新，所以需要react fiber把组件渲染工作切片；而vue基于数据劫持，更新粒度很小，没有这个压力；
react fiber这种数据结构使得节点可以回溯到其 ...`,l:"audition/react/basic.html#为什么vue不用fiber",a:"为什么vue不用fiber"},"34.13":{t:"react的事件机制\r",p:`react自身实现了一套自己的事件机制，包括事件注册、事件的合成、事件冒泡、事件派发

react 的所有事件并没有绑定到具体的dom节点上而是绑定在了document 上，然后由统一的事件处理程序d ...`,l:"audition/react/basic.html#react的事件机制",a:"react的事件机制"},"34.14":{t:"React事件机制流程\r",p:`注册过程要进行两件事：事件注册；事件存储(react17废除)。

虚拟DOM阶段，处理组件的props是否有声明为事件，得到事件类型 click,change 和对应的事件处理程序，
将这些事件在d ...`,l:"audition/react/basic.html#react事件机制流程",a:"react事件机制流程"},"34.15":{t:"合成事件\r",p:"React 合成事件（SyntheticEvent）是 React 模拟原生 DOM 事件所有能力的一个事件对象，即在react中，我们绑定的事件onClick等，并不是原生事件，而是由原生事件合成的 ...",l:"audition/react/basic.html#合成事件",a:"合成事件"},"34.16":{t:"原生事件和合成事件是如何对应起来的\r",p:`这个对应关系存放在 React 事件插件中EventPlugin，React 在一开始就将事件插件全部加载进来，

registrationNameModule， 它包含了 React 事件到它对应的 ...`,l:"audition/react/basic.html#原生事件和合成事件是如何对应起来的",a:"原生事件和合成事件是如何对应起来的"},"34.17":{t:"listenerBank事件池\r",p:`
事件对象可能会被频繁创建和回收，因此 React16之前(17废除) 引入事件池，在事件池中获取或释放事件对象。
即 React 事件对象不会被释放掉，而是存放进一个数组中，当事件触发，就从这个数组 ...`,l:"audition/react/basic.html#listenerbank事件池",a:"listenerbank事件池"},"34.18":{t:"React的事件和普通的HTML事件有什么不同？\r",p:`
原生事件阻止冒泡肯定会阻止合成事件的触发。
合成事件的阻止冒泡不会影响原生事件。

节点上的原生事件的执行是在目标阶段，然而合成事件的执行是在冒泡阶段，所以原生事件会先合成事件执行，然后再往父节点冒 ...`,l:"audition/react/basic.html#react的事件和普通的html事件有什么不同",a:"react的事件和普通的html事件有什么不同"},"34.19":{t:"执行顺序\r",p:`
React 所有事件都挂载在 document 对象上当真实 DOM 元素触发事件，会冒泡到 document 对象后，再处理 React 事件
所以会先执行原生事件，然后处理 React 事件最后 ...`,l:"audition/react/basic.html#执行顺序",a:"执行顺序"},"34.20":{t:"React17 的事件机制\r",p:`
事件统一绑定container上，ReactDOM.render(app， container);而不是document上，这样好处是有利于微前端的，微前端一个前端系统中可能有多个应用，如果继续采取 ...`,l:"audition/react/basic.html#react17-的事件机制",a:"react17-的事件机制"},"34.21":{t:"react的高阶组件\r",p:`HOC是一种用于组件重用逻辑的技术，本质上是一个函数，接受一个组件作为参数并返回一个新的增强组件，
HOC可以通过将一些通用的功能、状态或行为添加到现有组件中，从而提供一种灵活的复制方式。它可以用于在 ...`,l:"audition/react/basic.html#react的高阶组件",a:"react的高阶组件"},"34.22":{t:"React.createClass和extends Component的区别\r",p:`
语法区别，extends Component是ES6语法，用constructor构造器来构造默认的属性和状态。
propType 和 getDefaultProps
React.createCla ...`,l:"audition/react/basic.html#react-createclass和extends-component的区别",a:"react-createclass和extends-component的区别"},"34.23":{t:"组件渲染的时机\r",p:`React 组件在组件的状态 state 或者组件的属性 props 改变的时候，会重新渲染
shouldComponentUpdate方法默认返回true，这就是导致每次更新都重新渲染的原因。
`,l:"audition/react/basic.html#组件渲染的时机",a:"组件渲染的时机"},"34.24":{t:"react可以在render阶段访问refs吗\r",p:`三个阶段，render阶段，pre-commit阶段，commit阶段
DOM的读取在pre-commit阶段，DOM的使用在commit阶段
不可以，render阶段dom还没生成，无法获取dom
 ...`,l:"audition/react/basic.html#react可以在render阶段访问refs吗",a:"react可以在render阶段访问refs吗"},"34.25":{t:"React 中 keys 的作用\r",p:`keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移出的辅助标识
在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性。在 React Diff 算法中 React ...`,l:"audition/react/basic.html#react-中-keys-的作用",a:"react-中-keys-的作用"},"34.26":{t:"父子组件生命周期执行顺序\r",p:`父子组件初始化

父组件 constructor
父组件 getDerivedStateFromProps
父组件 render
子组件 constructor
子组件 getDerivedState ...`,l:"audition/react/basic.html#父子组件生命周期执行顺序",a:"父子组件生命周期执行顺序"},"34.27":{t:"高阶函数\r",p:`

接受一个或多个函数作为输入


输出一个函数
高阶组件的主要功能是封装并分离组件的通用逻辑，让通用逻辑在组件间更好地被复用


props 保持一致


不要再 render() 方法中使用高阶组 ...`,l:"audition/react/basic.html#高阶函数",a:"高阶函数"},"34.28":{t:"react中引入css的方式有哪几种？区别？\r",p:`
在组件内直接使用 &lt;div style={div1}&gt;123&lt;/div&gt;
组件中引入 .css 文件，样式是全局生效，样式之间会互相影响
组件中引入 .module.css  ...`,l:"audition/react/basic.html#react中引入css的方式有哪几种-区别",a:"react中引入css的方式有哪几种-区别"},"34.29":{t:"在react中组件间过渡动画如何实现？\r",p:`
CSSTransition：在前端开发中，结合 CSS 来完成过渡动画效果

in属性置为true时，CSSTransition首先会给其子组件加上xxx-enter、xxx-enter-activ ...`,l:"audition/react/basic.html#在react中组件间过渡动画如何实现",a:"在react中组件间过渡动画如何实现"},"34.30":{t:"按功能组织\r",p:`
每个功能模块对应一个目录，每个目录下包含同样的角色文件：
index.js 把所有的角色导入，统一导出
views 包含功能模块中所有的React组件，包括展示组件和容器组件

`,l:"audition/react/basic.html#按功能组织",a:"按功能组织"},"34.31":{t:"React项目是如何捕获错误的？\r",p:`错误边界是一种 React 组件，这种组件可以捕获发生在其子组件树任何位置的 JavaScript 错误，并打印这些错误，同时展示降级 UI，而并不会渲染那些发生崩溃的子组件
形成错误边界组件的两个条 ...`,l:"audition/react/basic.html#react项目是如何捕获错误的",a:"react项目是如何捕获错误的"},"35.0":{t:"# diff\r",p:"\r",l:"audition/react/diff.html",a:"diff"},"35.1":{t:"react \r",p:`
策略一，树的diff：tree diff————层级控制，对dom节点的跨层级操作不做优化，只对两棵树同一层级进行比较。即同一个父节点下的所有子节点。当发现节点已经不存在，则该节点及其子节点会被完全 ...`,l:"audition/react/diff.html#react",a:"react"},"35.2":{t:"vue2、双端比较\r",p:`
生成新的虚拟DOM树：在每次数据更新时，Vue.js会重新构建一棵新的虚拟DOM树，表示新的UI结构。
比较新旧虚拟DOM树的根节点：Vue.js会比较新旧虚拟DOM树的根节点，判断它们是否相同类型 ...`,l:"audition/react/diff.html#vue2、双端比较",a:"vue2、双端比较"},"35.3":{t:"双端比较：\r",p:`四个指针：

使用旧列表的头一个节点oldStartNode与新列表的头一个节点newStartNode对比
使用旧列表的最后一个节点oldEndNode与新列表的最后一个节点newEndNode对比 ...`,l:"audition/react/diff.html#双端比较",a:"双端比较"},"35.4":{t:"Vue3 Diff —— 最长递增子序列\r",p:`

前置与后置的预处理

前置节点的处理是定义了一个j变量,分别指向新，老两个组子节点，比较指向的新，老节点是否相同，如果相同指针 +1,直到两个节点不同时结束前置节点的处理
后置节点的处理是定义了索 ...`,l:"audition/react/diff.html#vue3-diff-——-最长递增子序列",a:"vue3-diff-——-最长递增子序列"},"35.5":{t:"快速diff\r",p:`新老两组的子节点都有剩余，该状态下主要核心为3个部分：

构建source数组用于存放新的一组子节点每个节点在老的一组中存在的原来位置(索引)

首先是定义一个长度为剩余新的一组子节点的长度的数组so ...`,l:"audition/react/diff.html#快速diff",a:"快速diff"},"35.6":{t:"说说React Jsx转换成真实DOM过程？\r",p:`
所有的 JSX 代码最后都会转换成React.createElement(...) ，Babel帮助我们完成了这个转换的过程。
createElement函数对props进行处理，对默认props进 ...`,l:"audition/react/diff.html#说说react-jsx转换成真实dom过程",a:"说说react-jsx转换成真实dom过程"},"36.0":{t:"# hook\r",p:"\r",l:"audition/react/hook.html",a:"hook"},"36.1":{t:"hooks解决了那些问题，限制\r",p:`
组件之间难以复用状态逻辑
复杂的组件层次结构，随着组件复杂度的增加，内部通查会充斥各种状态和副作用，然而很多逻辑都分散在类组件的各生命周期里，而不是聚焦在一起。
在 React 中使用 Class  ...`,l:"audition/react/hook.html#hooks解决了那些问题-限制",a:"hooks解决了那些问题-限制"},"36.2":{t:"限制\r",p:`
不要在循环、条件或嵌套函数中调用 Hook；依赖顺序来判断 hook 对应关系，在调用时按顺序加入数组中，如果使用循环、条件或嵌套函数很有可能导致数组取值错位，执行错误的 Hook。保证了 hook ...`,l:"audition/react/hook.html#限制",a:"限制"},"36.3":{t:"useState (维护状态)\r",p:`const [state, setState] = useState(initialState);

通过钩子函数useState()勾出state，useState()中需要传递一个初始值，这个值就 ...`,l:"audition/react/hook.html#usestate-维护状态",a:"usestate-维护状态"},"36.4":{t:"传入 setState 函数的第二个参数的作用是什么？\r",p:`该函数会在 setState 函数调用完成并且组件开始重渲染的时候被调用，我们可以用该函数来监听渲染是否完成：
`,l:"audition/react/hook.html#传入-setstate-函数的第二个参数的作用是什么",a:"传入-setstate-函数的第二个参数的作用是什么"},"36.5":{t:"关于setState是同步还是异步的问题\r",p:"在 React 的 setState 函数实现中，会根据一个变量 isBatchingUpdates 判断是直接更新 this.state 还是放到一个updateQueue中延时更新。而 isBat ...",l:"audition/react/hook.html#关于setstate是同步还是异步的问题",a:"关于setstate是同步还是异步的问题"},"36.6":{t:"setState()同步、异步总结\r",p:`

异步的情况：
由React控制的事件处理函数，以及生命周期函数调用setState时表现为异步 。（会触发batchedUpdates把 isBatchingUpdates 修改为 true）
大 ...`,l:"audition/react/hook.html#setstate-同步、异步总结",a:"setstate-同步、异步总结"},"36.7":{t:"useEffect (完成副作用操作)\r",p:`

useEffect 是 React 中的一个 Hook，用于处理副作用操作（Side Effects），例如订阅事件、获取数据、修改 DOM 等。它在组件渲染后执行，并可以根据指定的依赖项进行条件 ...`,l:"audition/react/hook.html#useeffect-完成副作用操作",a:"useeffect-完成副作用操作"},"36.8":{t:"useLayoutEffect\r",p:`useLayoutEffect 和 useEffect 不同的地方是采用了同步执行
useLayoutEffect 是在 DOM 更新之后，浏览器绘制之前，这样可以方便修改 DOM，获取 DOM 信息 ...`,l:"audition/react/hook.html#uselayouteffect",a:"uselayouteffect"},"36.9":{t:"useContext (使用共享状态)\r",p:`可以使用 useContext ，来获取父级组件传递过来的 context 值，这个当前值就是最近的父级组件 Provider 设置的 value 值
useContext 只能用于函数组件中，无法在 ...`,l:"audition/react/hook.html#usecontext-使用共享状态",a:"usecontext-使用共享状态"},"36.10":{t:"useCallback 它可以用来缓存函数，以避免在每次渲染时都创建新的函数实例\r",p:`
在 React 组件中，每次渲染时都会创建新的函数实例，如果这些函数作为 prop 传递给子组件，可能会导致子组件的不必要重新渲染，尤其在使用 React.memo 进行性能优化时更容易发生。
通过 ...`,l:"audition/react/hook.html#usecallback-它可以用来缓存函数-以避免在每次渲染时都创建新的函数实例",a:"usecallback-它可以用来缓存函数-以避免在每次渲染时都创建新的函数实例"},"36.11":{t:"useCallback使用场景\r",p:`
只有当函数作为 prop 传递给子组件，并且子组件使用了 React.memo 进行了性能优化时，才有必要考虑使用 useCallback
函数不依赖于组件的状态或属性,不考虑useCallback ...`,l:"audition/react/hook.html#usecallback使用场景",a:"usecallback使用场景"},"36.12":{t:"useMemo\r",p:`用于在函数组件中缓存计算结果。它可以在函数组件的渲染过程中缓存计算的值，并在依赖项未发生变化时直接返回缓存的值，从而避免不必要的重复计算，提高组件性能。
useMemo 接受两个参数：第一个参数是一个 ...`,l:"audition/react/hook.html#usememo",a:"usememo"},"36.13":{t:"useMemo和useCallback区别\r",p:`useMemo和useCallback用法差不多，都是在第一次渲染的时候执行一次，然后在依赖项改变时再次执行，不同点在于，useMemo缓存的计算结果，useCallback缓存的函数
`,l:"audition/react/hook.html#usememo和usecallback区别",a:"usememo和usecallback区别"},"36.14":{t:"React.memo\r",p:`
React.memo 是一个用于优化性能的高阶组件，它会将子组件进行缓存，以避免不必要的渲染。
它默认使用浅比较来比较组件接收的 props 是否发生变化，只有在 props 发生变化时，才会触发子 ...`,l:"audition/react/hook.html#react-memo",a:"react-memo"},"36.15":{t:"memo useMemo useCallback\r",p:`memo：

父组件重新渲染，没有被 memo 包裹的子组件也会重新渲染
被 memo 包裹的组件只有在 props 改变后，才会重新渲染
memo 只会对新旧 props 做浅比较，所以对于引用类型 ...`,l:"audition/react/hook.html#memo-usememo-usecallback",a:"memo-usememo-usecallback"},"36.16":{t:"useRef\r",p:`
useRef 可以用来在函数组件中保存和访问 DOM 元素或其他可变的值，而不需要触发组件的重新渲染。
useRef 返回一个可变的 ref 对象，它的.current 属性可以用来存储和访问任何值 ...`,l:"audition/react/hook.html#useref",a:"useref"},"36.17":{t:"ref函数组件中转发\r",p:`useRef 可以用于访问组件实例或 DOM 元素，具体取决于将 useRef 关联到的目标。


访问 DOM 元素：当你将 useRef 关联到一个 DOM 元素上时，useRef 将提供对该 D ...`,l:"audition/react/hook.html#ref函数组件中转发",a:"ref函数组件中转发"},"36.18":{t:"useImperativeHandle\r",p:`useImperativeHandle 可以配合 forwardRef 自定义暴露给父组件的实例值。
`,l:"audition/react/hook.html#useimperativehandle",a:"useimperativehandle"},"36.19":{t:"useSyncExternalStore\r",p:"useSyncExternalStore 能够让 React 组件在 concurrent 模式下安全地有效地读取外接数据源，在组件渲染过程中能够检测到变化，并且在数据源发生变化的时候，能够调度更新。 ...",l:"audition/react/hook.html#usesyncexternalstore",a:"usesyncexternalstore"},"36.20":{t:"useTransition\r",p:`它用于协调 Suspense 和并发模式（Concurrent Mode）下的异步更新。useTransition 允许我们在渲染过程中控制异步更新的优先级，从而改善用户体验。
`,l:"audition/react/hook.html#usetransition",a:"usetransition"},"36.21":{t:"useDeferredValue \r",p:`useDeferredValue 的实现效果也类似于 transtion，当迫切的任务执行后，再得到新的状态，而这个新的状态就称之为 DeferredValue。
`,l:"audition/react/hook.html#usedeferredvalue",a:"usedeferredvalue"},"37.0":{t:"# React Router 版本5\r",p:"",l:"audition/react/router.html",a:"react-router-版本5"},"37.1":{t:"路由\r",p:`路由的本质就是页面的URL发生改变时，页面的显示结果可以根据URL的变化而变化，但是页面不会刷新
`,l:"audition/react/router.html#路由",a:"路由"},"37.2":{t:"react-router-dom的常用API\r",p:`BrowserRouter、HashRouter Route
Link、NavLink switch

redirect

`,l:"audition/react/router.html#react-router-dom的常用api",a:"react-router-dom的常用api"},"37.3":{t:"BrowserRouter、HashRouter\r",p:`使用两者作为最顶层组件包裹其他组件
BrowserRouter:

使用 HTML5 的 History API，通过修改 URL 的路径来实现路由导航。
基于浏览器的 pushState 和 pop ...`,l:"audition/react/router.html#browserrouter、hashrouter",a:"browserrouter、hashrouter"},"37.4":{t:"Route组件\r",p:"route组件是用于路径的匹配，通过该组件将url地址和React组件进行映射，映射后当url地址变为指定地址时指定的组件就会显示，否则不显示。通过props传进来的path与context传进来的p ...",l:"audition/react/router.html#route组件",a:"route组件"},"37.5":{t:"redirect\r",p:`用于路由的重定向，当这个组件出现时，就会执行跳转到对应的to路径中
`,l:"audition/react/router.html#redirect",a:"redirect"},"37.6":{t:"switch\r",p:`swich组件的作用适用于当匹配到第一个组件的时候，后面的组件就不应该继续匹配
`,l:"audition/react/router.html#switch",a:"switch"},"37.7":{t:"四个钩子\r",p:`useHistory useParams
useLocation useRouteMatch
`,l:"audition/react/router.html#四个钩子",a:"四个钩子"},"37.8":{t:"useHistory\r",p:`history对象，用来读取和操作浏览器的历史记录（页面跳转）等功能，属性：

length —— 历史记录的数量
action —— 当前历史记录的状态，pop（前进、后退、新记录创建、索引发生变化 ...`,l:"audition/react/router.html#usehistory",a:"usehistory"},"37.9":{t:"useParams\r",p:`设置动态参数后，在组件的内部可以使用useParams()钩子来读取参数：
const Student = () =&gt; {
    const {id} = useParams();
    r ...`,l:"audition/react/router.html#useparams",a:"useparams"},"37.10":{t:"useLocation\r",p:`useLocation 会返回当前 URL的 location对象

pathname —— 请求的路径
search —— 查询字符串 获取查询参数?name=why&amp;age=18
hash ...`,l:"audition/react/router.html#uselocation",a:"uselocation"},"37.11":{t:"useRouteMatch\r",p:`router5的useRouteMatch获取当前路由匹配的信息，有isExact（是否匹配布尔值），和params，path，url等信息，router6时被废弃，用useMatch代替
`,l:"audition/react/router.html#useroutematch",a:"useroutematch"},"37.12":{t:"参数传递\r",p:`
动态路由,将path在Route匹配时写成/detail/:id，params参数

props.match.params.xxx获取
useParams()钩子来读取参数



&lt;NavLi ...`,l:"audition/react/router.html#参数传递",a:"参数传递"},"37.13":{t:"Routes组件\r",p:`和版本5不同，6中的Route组件不能单独使用，而是必须要放到Routes组件中。简言之Routes就是一个存放Route的容器。
`,l:"audition/react/router.html#routes组件",a:"routes组件"},"37.14":{t:"route组件\r",p:`并且Route组件必须放到Routes中，当浏览器的地址发生变化时，会自动对Routes中的所有Route进行匹配，匹配到的则显示，其余Route则不再继续匹配。

path —— 要匹配的路径
el ...`,l:"audition/react/router.html#route组件",a:"route组件"},"37.15":{t:"Outlet组件\r",p:`在版本6中Route组件是可以嵌套的，可以通过嵌套Route来构建出嵌套路由，像这样
&lt;Route path='/students' element={&lt;StudentList/&gt;} ...`,l:"audition/react/router.html#outlet组件",a:"outlet组件"},"37.16":{t:"useMatch\r",p:`useMatch 只有一个功能，挂钩在内部使用此函数来匹配相对于当前位置的路由路径。
matchPath将路由路径模式与 URL 路径名匹配，并返回有关匹配的信息。当您需要手动运行路由器的匹配算法以确 ...`,l:"audition/react/router.html#usematch",a:"usematch"},"37.17":{t:"react router 的render和component和children的区别\r",p:`component使用React.createElement() 来创建该组件，而render是直接运行赋值给render这个prop的函数并带上props参数来创建该组件。
component 这个 ...`,l:"audition/react/router.html#react-router-的render和component和children的区别",a:"react-router-的render和component和children的区别"},"37.18":{t:"Link和a的区别\r",p:`&lt;Link&gt; 的“跳转”行为只会触发相匹配的&lt;Route&gt; 对应的页面内容更新,它的to、query、hash 属性会被组合在一起并渲染为 href 属性。
Link阻止a标签 ...`,l:"audition/react/router.html#link和a的区别",a:"link和a的区别"},"37.19":{t:"Link、NavLink\r",p:`通常路径的跳转是使用Link组件，最终会被渲染成a元素，其中属性to代替a标题的href属性
NavLink是在Link基础之上增加了一些样式属性，例如组件被选中时，发生样式变化，则可以设置NavLi ...`,l:"audition/react/router.html#link、navlink",a:"link、navlink"},"38.0":{t:"setState\r",p:`setState()会对一个组件的 state 对象安排一次更新。当 state 改变了，该组件就会重新渲染。
调用 setState 其实是异步的，在调用 setState 之后，this.stat ...`,l:"audition/react/state&props.html",a:"setstate"},"38.1":{t:"传入 setState 函数的第二个参数的作用是什么？\r",p:`该函数会在 setState 函数调用完成并且组件开始重渲染的时候被调用，我们可以用该函数来监听渲染是否完成：
`,l:"audition/react/state&props.html#传入-setstate-函数的第二个参数的作用是什么",a:"传入-setstate-函数的第二个参数的作用是什么"},"38.2":{t:"关于setState是同步还是异步的问题\r",p:"在 React 的 setState 函数实现中，会根据一个变量 isBatchingUpdates 判断是直接更新 this.state 还是放到一个updateQueue中延时更新。而 isBat ...",l:"audition/react/state&props.html#关于setstate是同步还是异步的问题",a:"关于setstate是同步还是异步的问题"},"38.3":{t:"setState()同步、异步总结\r",p:`

异步的情况：
由React控制的事件处理函数，以及生命周期函数调用setState时表现为异步 。（会触发batchedUpdates把 isBatchingUpdates 修改为 true）
大 ...`,l:"audition/react/state&props.html#setstate-同步、异步总结",a:"setstate-同步、异步总结"},"38.4":{t:"setState()异步的好处，为什么要设计成异步的\r",p:"例如，如果 Parent 和 Child 在同一个 click 事件中都调用了 setState ，这样就可以确保 Child 不会被重新渲染两次。取而代之的是，React 会将该 state 等到浏 ...",l:"audition/react/state&props.html#setstate-异步的好处-为什么要设计成异步的",a:"setstate-异步的好处-为什么要设计成异步的"},"38.5":{t:"react的state和props区别\r",p:`props（“properties” 的缩写）和 state 都是普通的 JavaScript 对象。它们都是用来保存信息的，这些信息可以控制组件的渲染输出，而它们的几个重要的不同点就是：

prop ...`,l:"audition/react/state&props.html#react的state和props区别",a:"react的state和props区别"},"38.6":{t:"react的props的验证\r",p:"React 为我们提供了 PropTypes 以供验证使用。当我们向 Props 传入 的数据无效（向 Props 传入的数据类型和验证的数据类型不符）就会 在控制台发出警告信息。它可以避免随着应用越 ...",l:"audition/react/state&props.html#react的props的验证",a:"react的props的验证"},"38.7":{t:"父组件props发生变化时调用的生命周期函数\r",p:`
组件第一次渲染时不会执行componentWillReceiveProps；
当props发生变化的时时候会执行componentWillReceiveProps；
在componentWillRe ...`,l:"audition/react/state&props.html#父组件props发生变化时调用的生命周期函数",a:"父组件props发生变化时调用的生命周期函数"},"38.8":{t:"控制是否首次渲染\r",p:`import React, { useEffect, useState } from 'react';

function MyComponent() {
  const [isFirstRender ...`,l:"audition/react/state&props.html#控制是否首次渲染",a:"控制是否首次渲染"},"39.0":{t:"# react和vue区别\r",p:"\r",l:"audition/react/vueOrReact.html",a:"react和vue区别"},"39.1":{t:"核心思想\r",p:`vue：进行数据拦截、代理，对侦测数据的变化更敏感，更精确
React：推崇函数式编程，数据不可变
`,l:"audition/react/vueOrReact.html#核心思想",a:"核心思想"},"39.2":{t:"响应式原理不同\r",p:`vue：vue则是直接修改保存状态的那块原始内存，vue用defineproperty和proxy对数据进行劫持，vue能准确知道视图模版中哪一块用到了这个数据，可以自动找到引用组件进行渲染
reac ...`,l:"audition/react/vueOrReact.html#响应式原理不同",a:"响应式原理不同"},"39.3":{t:"语法\r",p:`vue：模板语法+指令，简单易懂
react：jsx+inlinestyle相对复杂
`,l:"audition/react/vueOrReact.html#语法",a:"语法"},"39.4":{t:"diff\r",p:`vue：双端比较，最长递增子序列
react：从左到右依次对比，最后一个放到最前面，会把前面的节点依次移动
`,l:"audition/react/vueOrReact.html#diff",a:"diff"},"39.5":{t:"vuex和redux\r",p:`redux：数据不可变，新state替换旧state
vuex：数据可变，直接修改
`,l:"audition/react/vueOrReact.html#vuex和redux",a:"vuex和redux"},"40.0":{t:"# 响应式\r",p:"",l:"audition/react/响应式.html",a:"响应式"},"40.1":{t:"react、vue的响应式原理\r",p:`
从底层实现来看修改数据：在react中，组件的状态是不能被修改的，setState没有修改原来那块内存中的变量，而是去新开辟一块内存； 而vue则是直接修改保存状态的那块原始内存。
数据修改了，接下 ...`,l:"audition/react/响应式.html#react、vue的响应式原理",a:"react、vue的响应式原理"},"40.2":{t:"每次的视图更新流程是这样的：\r",p:`
组件渲染生成一棵新的虚拟dom树；
新旧虚拟dom树对比，找出变动的部分；（也就是常说的diff算法）
为真正改变的部分创建真实dom，把他们挂载到文档，实现页面重渲染；

`,l:"audition/react/响应式.html#每次的视图更新流程是这样的",a:"每次的视图更新流程是这样的"},"41.0":{t:"redux和vuex和pinia\r",p:"Redux： Redux 是一个独立于框架的状态管理库，最初是为 React 设计的，但可以在其他框架中使用。它的核心概念包括单一的全局状态树、纯函数来处理状态变化以及通过 action 来触发状态的 ...",l:"audition/react/状态管理器.html",a:"redux和vuex和pinia"},"41.1":{t:"vuex的五大部分\r",p:`
State（状态）：State 是应用程序的中央数据存储库，代表了应用程序的整体状态。
Mutation（变更）：Mutation 是修改 State 的唯一途径。
Action（动作）：Actio ...`,l:"audition/react/状态管理器.html#vuex的五大部分",a:"vuex的五大部分"},"41.2":{t:"pinia\r",p:`
store
State（状态）
Actions（动作）
Getters（获取器）
Mutations没有了，用this获取数据

`,l:"audition/react/状态管理器.html#pinia",a:"pinia"},"41.3":{t:"Redux\r",p:`Redux是一个可预测的状态容器

状态（State）
容器（Container）
可预测（Predictable）

Redux是一个状态容器，所以使用Redux必须先创建容器对象，它的所有操作都是 ...`,l:"audition/react/状态管理器.html#redux",a:"redux"},"41.4":{t:"store常用的方法\r",p:`createStore可以帮助创建 store store.dispatch 帮助派发 action , action 会传递给 store

store.getState 这个方法可以帮助获取 st ...`,l:"audition/react/状态管理器.html#store常用的方法",a:"store常用的方法"},"41.5":{t:"多个reducer的Redux用法\r",p:`
一个复杂的reducer分成几个reducer，最后用combineReducers合并
创建reducer的参数state可以写默认值
创建store后，需要引入react-redux中提供的Pr ...`,l:"audition/react/状态管理器.html#多个reducer的redux用法",a:"多个reducer的redux用法"},"41.6":{t:"redux的中间件\r",p:"中间件的作用： 就是在 源数据 到 目标数据 中间做各种处理，有利于程序的可拓展性，通常情况下，一个中间件就是一个函数，且一个中间件最好只做一件事情。 调用 dispatch 触发 reducer之前 ...",l:"audition/react/状态管理器.html#redux的中间件",a:"redux的中间件"},"41.7":{t:"redux applyMiddleware.js\r",p:`//

export default function applyMiddleware(...middlewares) {
  return (createStore) =&gt; (reducer, ...`,l:"audition/react/状态管理器.html#redux-applymiddleware-js",a:"redux-applymiddleware-js"},"41.8":{t:"第三方中间件\r",p:`import { createStore, applyMiddleware } from 'redux';
import thunkMiddleware from 'redux-thunk'; //异 ...`,l:"audition/react/状态管理器.html#第三方中间件",a:"第三方中间件"},"41.9":{t:"自定义中间件`next(action);`调用下一个中间件或 reducer\r",p:`const middleware1 = store =&gt; next =&gt; action =&gt; {
  console.log('Middleware 1: Before action ...`,l:"audition/react/状态管理器.html#自定义中间件-next-action-调用下一个中间件或-reducer",a:"自定义中间件-next-action-调用下一个中间件或-reducer"},"41.10":{t:"函数柯里化（Currying）\r",p:"嵌套函数，相当于c(b(a()))，a的返回值传给b，b的返回值传给c\nconst fun = a =&gt; b =&gt; c =&gt; {\n  console.log(`a: ${a}, b: ...",l:"audition/react/状态管理器.html#函数柯里化-currying",a:"函数柯里化-currying"},"42.0":{t:"# TypeScript\r",p:`参考
`,l:"audition/ts/ts.html",a:"typescript"},"42.1":{t:"数组\r",p:`let arr : string[] = [&quot;a&quot;,&quot;b&quot;]
let arr2：Array&lt;string&gt; = [&quot;a&quot;,&qu ...`,l:"audition/ts/ts.html#数组",a:"数组"},"42.2":{t:"函数\r",p:`//函数声明
function sun(x:number,y:number):number{
    return x+y
}
//函数表达式
let mySum:(x:number,y:number ...`,l:"audition/ts/ts.html#函数",a:"函数"},"42.3":{t:"参数\r",p:`//可选参数
function buildNmae(firstName: string, lastName?: string){
    if(lastName){
        return fi ...`,l:"audition/ts/ts.html#参数",a:"参数"},"42.4":{t:"函数重载\r",p:`函数重载或方法重载是使用相同名称和不同参数数量或类型创建多个方法的一种能力。 方法就是为同一个函数提供多个函数类型定义来进行函数重载，编译器会根据这个列表去处理函数的调用
type Combinabl ...`,l:"audition/ts/ts.html#函数重载",a:"函数重载"},"42.5":{t:"元组\r",p:`元组是 TypeScript 中特有的类型，元组最重要的特性是可以限制数组元素的个数和类型，它特别适合用来实现多值返回。
let x: [string, number]; 
// 类型必须匹配且个数必 ...`,l:"audition/ts/ts.html#元组",a:"元组"},"42.6":{t:"元祖类型的解构赋值\r",p:`let employee: [number, string?] = [1, &quot;Semlinker&quot;];
let [id, username] = employee;
console ...`,l:"audition/ts/ts.html#元祖类型的解构赋值",a:"元祖类型的解构赋值"},"42.7":{t:"void\r",p:`void表示没有任何类型，和其他类型是平等关系，不能直接赋值:
let a: void; 
let b: number = a; // Error

你只能为它赋予null和undefined（在st ...`,l:"audition/ts/ts.html#void",a:"void"},"42.8":{t:"never\r",p:`never类型表示的是那些永不存在的值的类型。
值会永不存在的两种情况：

如果一个函数执行时抛出了异常，那么这个函数永远不存在返回值（因为抛出异常会直接中断程序运行，这使得程序运行不到返回值那一步， ...`,l:"audition/ts/ts.html#never",a:"never"},"42.9":{t:"any\r",p:`在 TypeScript 中，任何类型都可以被归为 any 类型。这让 any 类型成为了类型系统的顶级类型.
`,l:"audition/ts/ts.html#any",a:"any"},"42.10":{t:"unknown\r",p:"unknown与any一样，所有类型都可以分配给unknown unknown与any的最大区别是： 任何类型的值可以赋值给any，同时any类型的值也可以赋值给任何类型。unknown 任何类型的值 ...",l:"audition/ts/ts.html#unknown",a:"unknown"},"42.11":{t:"object、Object 和 \r",p:`
小 object 代表的是所有非原始类型，也就是说我们不能把 number、string、boolean、symbol等 原始类型赋值给 object。在严格模式下，null 和 undefined ...`,l:"audition/ts/ts.html#",a:""},"42.12":{t:"类型推断\r",p:`我们把 TypeScript 这种基于赋值表达式推断类型的能力称之为类型推断
在 TypeScript 中，具有初始化值的变量、有默认值的函数参数、函数返回的类型都可以根据上下文推断出来。比如我们能根 ...`,l:"audition/ts/ts.html#类型推断",a:"类型推断"},"42.13":{t:"类型断言\r",p:`// 尖括号 语法
let someValue: any = &quot;this is a string&quot;;
let strLength: number = (&lt;string&gt; ...`,l:"audition/ts/ts.html#类型断言",a:"类型断言"},"42.14":{t:"非空断言\r",p:"在上下文中当类型检查器无法断定类型时，一个新的后缀表达式操作符 ! 可以用于断言操作对象是非 null 和非 undefined 类型。具体而言，x! 将从 x 值域中排除 null 和 undefi ...",l:"audition/ts/ts.html#非空断言",a:"非空断言"},"42.15":{t:"确定赋值断言\r",p:`允许在实例属性和变量声明后面放置一个 ! 号，从而告诉 TypeScript 该属性会被明确地赋值。为了更好地理解它的作用，我们来看个具体的例子：
let x!: number;
initialize ...`,l:"audition/ts/ts.html#确定赋值断言",a:"确定赋值断言"},"42.16":{t:"字面量类型\r",p:`TypeScript 支持 3 种字面量类型：字符串字面量类型、数字字面量类型、布尔字面量类型，对应的字符串字面量、数字字面量、布尔字面量分别拥有与其值一样的字面量类型
{
  let specifi ...`,l:"audition/ts/ts.html#字面量类型",a:"字面量类型"},"42.17":{t:"let和const分析\r",p:`将 const 定义为一个不可变更的常量，在缺省类型注解的情况下，TypeScript 推断出它的类型直接由赋值字面量的类型决定
{
  const str = 'this is string'; / ...`,l:"audition/ts/ts.html#let和const分析",a:"let和const分析"},"42.18":{t:"接口\r",p:`在面向对象语言中，接口（Interfaces）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implement）。
TypeScript 中的接口是一个非常灵活 ...`,l:"audition/ts/ts.html#接口",a:"接口"},"42.19":{t:"可选 | 只读属性\r",p:`interface Person {
  readonly name: string;
  age?: number;
}

只读属性用于限制只能在对象刚刚创建的时候修改其值。此外 TypeScrip ...`,l:"audition/ts/ts.html#可选-只读属性",a:"可选-只读属性"},"42.20":{t:"任意属性\r",p:`有时候我们希望一个接口中除了包含必选和可选属性之外，还允许有其他的任意属性，这时我们可以使用 索引签名 的形式来满足上述要求。
interface Person {
    name: string; ...`,l:"audition/ts/ts.html#任意属性",a:"任意属性"},"42.21":{t:"鸭式辨型法\r",p:`所谓的鸭式辨型法就是像鸭子一样走路并且嘎嘎叫的就叫鸭子，即具有鸭子特征的认为它就是鸭子，也就是通过制定规则来判定对象是否实现这个接口。
interface LabeledValue {
  label ...`,l:"audition/ts/ts.html#鸭式辨型法",a:"鸭式辨型法"},"42.22":{t:"绕开额外属性检查的方式\r",p:`
鸭式辨型法
类型断言
索引签名

`,l:"audition/ts/ts.html#绕开额外属性检查的方式",a:"绕开额外属性检查的方式"},"42.23":{t:"索引签名\r",p:`interface Props { 
  name: string; 
  age: number; 
  money?: number;
  [key: string]: any;
}

let p ...`,l:"audition/ts/ts.html#索引签名",a:"索引签名"},"42.24":{t:"interface 和 type\r",p:`
TypeScript 的核心原则之一是对值所具有的结构进行类型检查。 而接口的作用就是为这些类型命名和为你的代码或第三方代码定义数据模型。
type(类型别名)会给一个类型起个新名字。 type 有 ...`,l:"audition/ts/ts.html#interface-和-type",a:"interface-和-type"},"42.25":{t:"Objects / Functions\r",p:`两者都可以用来描述对象或函数的类型，但是语法不同
//interface
interface Point {
  x: number;
  y: number;
}

interface SetPoi ...`,l:"audition/ts/ts.html#objects-functions",a:"objects-functions"},"42.26":{t:"Other Types\r",p:`与接口不同，类型别名还可以用于其他类型，如基本类型（原始值）、联合类型、元组。
// primitive
type Name = string;

// object
type PartialPoin ...`,l:"audition/ts/ts.html#other-types",a:"other-types"},"42.27":{t:"接口可以定义多次,类型别名不可以\r",p:`与类型别名不同，接口可以定义多次，会被自动合并为单个接口。
interface Point { x: number; }
interface Point { y: number; }
const po ...`,l:"audition/ts/ts.html#接口可以定义多次-类型别名不可以",a:"接口可以定义多次-类型别名不可以"},"42.28":{t:"扩展\r",p:`两者的扩展方式不同，但并不互斥。接口可以扩展类型别名，同理，类型别名也可以扩展接口。

接口的扩展就是继承，通过 extends 来实现。类型别名的扩展就是交叉类型，通过 &amp; 来实现。

接口 ...`,l:"audition/ts/ts.html#扩展",a:"扩展"},"42.29":{t:"泛型\r",p:`用了一个 类型 T，这个 T 是一个抽象类型，只有在调用的时候才确定它的值，这就不用我们复制粘贴无数份代码了。
function identity&lt;T&gt;(arg: T): T {
  re ...`,l:"audition/ts/ts.html#泛型",a:"泛型"},"42.30":{t:"泛型约束\r",p:`类型约束使用 extends 关键字。简单来说就是你定义一个类型，然后让 T 实现这个接口即可
interface Sizeable {
  size: number;
}
function trac ...`,l:"audition/ts/ts.html#泛型约束",a:"泛型约束"},"42.31":{t:" ",p:"",l:"audition/ts/ts.html#",a:""},"42.32":{t:"泛型工具\r",p:`

typeof
typeof 的主要用途是在类型上下文中获取变量或者属性的类型


keyof
keyof 操作符是在 TypeScript 2.1 版本引入的，该操作符可以用于获取某种类型的所有键 ...`,l:"audition/ts/ts.html#泛型工具",a:"泛型工具"},"43.0":{t:"# vue-router\r",p:`官方文档
`,l:"audition/vue/vue-router.html",a:"vue-router"},"43.1":{t:"vue-router\r",p:"",l:"audition/vue/vue-router.html#vue-router",a:"vue-router"},"43.2":{t:"vue-router是什么，描述一下它的原理？\r",p:`Vue Router是Vue官方的路由管理器，有hash和history两种模式

hash模式是通过监听hashchange事件来实现更新页面部分内容的操作，url后面会带有#号
history模式 ...`,l:"audition/vue/vue-router.html#vue-router是什么-描述一下它的原理",a:"vue-router是什么-描述一下它的原理"},"43.3":{t:"如何实现\r",p:"vue-router中有个监听器，用来监听History的变化（浏览器地址改变、点击前进后退按钮）。当监听到History变化之后，vue-router就会依据路由表当中声明了的路由对应匹配的组件，然 ...",l:"audition/vue/vue-router.html#如何实现",a:"如何实现"},"43.4":{t:"hash模式\r",p:"即url中的#以及后面部分，#相当于一个锚点，#后面的内容就是锚点值，当监听锚点值的变化就会改变局部的页面数据。当浏览器向服务器发送请求时，只会把#前面部分发送给服务器，一般前面部分的是不变的，所以h ...",l:"audition/vue/vue-router.html#hash模式",a:"hash模式"},"43.5":{t:"history模式\r",p:"HTML5 Mode是html5新增 history模式，所以也称为history 模式。history 模式改变 url 的方式会导致浏览器向服务器发送请求，但是history 模式可以传输复杂一些 ...",l:"audition/vue/vue-router.html#history模式",a:"history模式"},"43.6":{t:"路由跳转方式有哪些？\r",p:`
内置组件跳转
router.push({ path: '/home' }),
router.replace({ path: '/home' })
router.go()
redirect() 在路由 ...`,l:"audition/vue/vue-router.html#路由跳转方式有哪些",a:"路由跳转方式有哪些"},"43.7":{t:"说一下路由守卫？\r",p:`
为什么：如果需要用户登陆，我们来守卫页面，强制用户跳转到登录页面

路由守卫分为全局路由守卫，路由独享守卫，组件路由守卫

全局路由守卫

全局前置守卫beforeEach,接收to、from、ne ...`,l:"audition/vue/vue-router.html#说一下路由守卫",a:"说一下路由守卫"},"43.8":{t:"完整的导航解析流程\r",p:`
导航被触发。
在失活的组件里调用 beforeRouteLeave 守卫。
调用全局的 beforeEach 守卫。
在渲染该组件的路由被确认前访问组件实例 beforeRouteEnter。
在路 ...`,l:"audition/vue/vue-router.html#完整的导航解析流程",a:"完整的导航解析流程"},"43.9":{t:"懒加载\r",p:`为给客户更好的客户体验，首屏组件加载速度更快一些，解决白屏问题，懒加载简单来说就是延迟加载或按需加载，即在需要的时候的时候进行加载。
也就是，组件现在路由里注册但不进行组件的加载与执行，等到需要访问组 ...`,l:"audition/vue/vue-router.html#懒加载",a:"懒加载"},"43.10":{t:"懒加载实现\r",p:`
懒加载实现的前提：ES6的动态加载模块 - import（），调用import（）之处，被作为分离的模块起点，意思是，被请求的模块和它引用的所有子模块，会分离到一个单独的 chunk 中。

`,l:"audition/vue/vue-router.html#懒加载实现",a:"懒加载实现"},"43.11":{t:"Vue-router路由懒加载的方式\r",p:`
vue-router配置路由，使用vue的异步组件技术，可以实现懒加载，此时一个组件会生成一个js文件。
component: resolve =&gt; require(['放入需要加载的路由地址 ...`,l:"audition/vue/vue-router.html#vue-router路由懒加载的方式",a:"vue-router路由懒加载的方式"},"43.12":{t:"路由元信息\r",p:`将任意信息附加到路由上，如过渡名称、谁可以访问路由等。这些事情可以通过接收属性对象的meta属性来实现，并且它可以在路由地址和导航守卫上都被访问到。
`,l:"audition/vue/vue-router.html#路由元信息",a:"路由元信息"},"43.13":{t:"数据获取\r",p:`有时候，进入某个路由后，需要从服务器获取数据。例如，在渲染用户信息时，你需要从服务器获取用户的数据。我们可以通过两种方式来实现：

导航完成之后获取：先完成导航，然后在接下来的组件生命周期钩子中获取数 ...`,l:"audition/vue/vue-router.html#数据获取",a:"数据获取"},"43.14":{t:"vue路由的传参方式\r",p:`
动态路由参数：可以在路由定义中使用冒号（:）来定义动态的路由参数。
查询参数：查询参数是通过 URL 的查询字符串传递的键值对
路由对象参数：可以通过在编程式导航中传递query一个包含参数的路由对 ...`,l:"audition/vue/vue-router.html#vue路由的传参方式",a:"vue路由的传参方式"},"43.15":{t:"params和query\r",p:`params：
动态路由参数,传递方式：params 是通过路由的路径进行传递的，参数直接嵌入在路由路径中。在路由组件中可以通过 $route.params 来获取传递的参数。
query：
查询参数 ...`,l:"audition/vue/vue-router.html#params和query",a:"params和query"},"44.0":{t:"# vue\r",p:"\r",l:"audition/vue/vue.html",a:"vue"},"44.1":{t:"对vue的理解\r",p:`
他是一个流行的前端框架
提供组件化开发
响应式数据绑定
指令和插值表达式
路由
状态管理
过渡和动画：Vue支持在组件间添加过渡效果和动画

`,l:"audition/vue/vue.html#对vue的理解",a:"对vue的理解"},"44.2":{t:"单页面应用\r",p:`单页应用(SPA - single page application)

只在第一次加载页面时，返回唯一的html页面和它的公共静态资源，后续的页面跳转都不会从服务端拿html文件。（hash和his ...`,l:"audition/vue/vue.html#单页面应用",a:"单页面应用"},"44.3":{t:"vue生命周期\r",p:`


Vue2(选项式API)
Vue3(setup)
描述




beforeCreate
setup
实例创建前


created
setup
实例创建后


beforeMount
onBe ...`,l:"audition/vue/vue.html#vue生命周期",a:"vue生命周期"},"44.4":{t:"setup\r",p:"setup函数是组件中的一个特殊函数，用于在组件实例创建之前进行一些初始化操作。你可以使用onBeforeMount和onMounted这两个函数来模拟beforeCreate和created的行为。 ...",l:"audition/vue/vue.html#setup",a:"setup"},"44.5":{t:"各自生命周期的事情\r",p:`beforeCreate   setup
created        setup              常用于数据请求、事件监听、定时器开启等
beforeMount    onBeforeMo ...`,l:"audition/vue/vue.html#各自生命周期的事情",a:"各自生命周期的事情"},"44.6":{t:"vue父子组件生命周期\r",p:`
渲染过程
父beforeCreate -&gt; 父created -&gt; 父beforeMount -&gt; 子beforeCreate -&gt; 子created -&gt; 子befo ...`,l:"audition/vue/vue.html#vue父子组件生命周期",a:"vue父子组件生命周期"},"44.7":{t:"注意\r",p:`如果子组件是异步组件的话它们的执行顺序会发生改变，会先执行完父组件的生命周期然后再执行子组件的生命周期
`,l:"audition/vue/vue.html#注意",a:"注意"},"44.8":{t:"v-if和v-show\r",p:`
v-if表示一个dom元素是否被创建，而v-show则是控制这个dom元素的display属性是否为none
一般在频繁切换状态的地方使用v-show,v-if则更适合条件不经常改变的场景，因为它切 ...`,l:"audition/vue/vue.html#v-if和v-show",a:"v-if和v-show"},"44.9":{t:"v-for和v-if优先级\r",p:`
开发过程中一般不建议同时将v-for和v-if放在一个标签中使用
Vue2中v-for的优先级会更高，所以会先执行循环，再进行v-if判断，所以这样就会导致无论需不需展示这个元素，都会先遍历整个列表 ...`,l:"audition/vue/vue.html#v-for和v-if优先级",a:"v-for和v-if优先级"},"44.10":{t:"说一下computed和watch\r",p:`
computed是计算属性,当一个属性受一个或者多个属性影响的时候可以使用.watch是侦听器,当我们需要根据一个属性的变化而做出一些处理的时候,可以使用watch来对这个属性进行监听
comput ...`,l:"audition/vue/vue.html#说一下computed和watch",a:"说一下computed和watch"},"44.11":{t:"computed和methods的区别？\r",p:`computed和methods的差异是它具备缓存性，如果依赖项不变时不会重新计算。
`,l:"audition/vue/vue.html#computed和methods的区别",a:"computed和methods的区别"},"44.12":{t:"computed为什么是同步的\r",p:"computed属性可以依赖于其他响应式数据（例如data属性或其他computed属性）。Vue.js会自动追踪这些依赖关系，并在依赖发生变化时重新计算computed属性的值。由于依赖关系是同步跟 ...",l:"audition/vue/vue.html#computed为什么是同步的",a:"computed为什么是同步的"},"44.13":{t:"computed和watch的区别？\r",p:`
computed计算属性不支持异步，watch用来进行异步操作

在计算属性中进行异步操作可能会导致无法正确地追踪依赖关系和触发更新。如果计算属性中使用异步操作，将无法准确确定何时重新计算属性的值。 ...`,l:"audition/vue/vue.html#computed和watch的区别",a:"computed和watch的区别"},"44.14":{t:"computed和watch使用场景\r",p:`
计算属性computed常用场景是简化在template模板中的复杂表达式，模板中出现太多逻辑判断会造成模板不易维护。
computed不支持异步
都是以 Vue 的依赖追踪机制为基础，当某个依赖数 ...`,l:"audition/vue/vue.html#computed和watch使用场景",a:"computed和watch使用场景"},"44.15":{t:"computed的原理\r",p:`computed 的实现是基于 Watcher 实例对象(被观察者)的
`,l:"audition/vue/vue.html#computed的原理",a:"computed的原理"},"44.16":{t:"computed的两种定义方式\r",p:`一种是方法，另一种是 get，set 属性。而且，其内部监听的对象必须是已经定义响应式的属性，比如 data 的属性、vuex 的属性。
`,l:"audition/vue/vue.html#computed的两种定义方式",a:"computed的两种定义方式"},"44.17":{t:"computed属性的初始化\r",p:`
vue 在创建 computed 属性时候，遍历computed属性，为每个computed属性都创建一个watcher,对每个computed属性进行get劫持
get劫持是最关键的步骤

将co ...`,l:"audition/vue/vue.html#computed属性的初始化",a:"computed属性的初始化"},"44.18":{t:"computed 属性\r",p:"vue 在创建 computed 属性时候，会循环所有计算属性，每一个计算属性会创建一个 watcher，(并且在通过 defineProperty(vue2),proxy(vue3) 定义监听)，在 ...",l:"audition/vue/vue.html#computed-属性",a:"computed-属性"},"44.19":{t:"依赖收集的时机\r",p:`computed 收集时机和 data 一样，是在组件挂载前，但是其收集对象是自己属性对应的 watch，而 data 本身所有数据对应一个 watch。
`,l:"audition/vue/vue.html#依赖收集的时机",a:"依赖收集的时机"},"44.20":{t:"watch和watchEffect区别和用法\r",p:`
watch 那样接收一个明确的数据源,watchEffect 也是一个监听器,它只接收一个回调函数。而在这个回调函数当中，它会自动监听响应数据，当回调函数里面的响应数据发生变化，回调函数就会立即执行 ...`,l:"audition/vue/vue.html#watch和watcheffect区别和用法",a:"watch和watcheffect区别和用法"},"44.21":{t:"vue2和vue3区别\r",p:`
写法上的区别:vue2使用的是options(选项)Api,vue3的是composition Api(当然vue3也兼容composition api)。options Api中methods，c ...`,l:"audition/vue/vue.html#vue2和vue3区别",a:"vue2和vue3区别"},"44.22":{t:"VUE初始化阶段\r",p:`
解析 Vue 模板：Vue 应用程序的入口是一个 HTML 模板，其中包含 Vue 的标识符和指令。在初始化阶段，Vue 会解析模板，识别其中的指令和数据绑定。
创建 Vue 实例：Vue 会根据解 ...`,l:"audition/vue/vue.html#vue初始化阶段",a:"vue初始化阶段"},"44.23":{t:"Vue2 实现响应式的核心是通过「数据劫持」和「观察者模式」来实现的。\r",p:`
数据劫持：Vue 使用 Object.defineProperty() 方法来劫持对象的属性，为其添加 getter 和 setter。当访问或修改这些属性时，Vue 可以捕捉到，并执行相应的逻辑。 ...`,l:"audition/vue/vue.html#vue2-实现响应式的核心是通过「数据劫持」和「观察者模式」来实现的。",a:"vue2-实现响应式的核心是通过「数据劫持」和「观察者模式」来实现的。"},"44.24":{t:"数组的改进\r",p:`
响应式数组，vue3数组可以直接使用
reactive和readonly
watchEffect的数组侦听
v-for的key属性
Array.prototype方法的修改：Vue 3对一些数组方法 ...`,l:"audition/vue/vue.html#数组的改进",a:"数组的改进"},"44.25":{t:"vue插件使用\r",p:`将组件实例挂载到全局，
vue实例会有一个use函数,它接受的是一个带有install函数的对象和一个可选的选项对象,当我们使用 vue.use(plugin)或者app.use(plugin)会调用 ...`,l:"audition/vue/vue.html#vue插件使用",a:"vue插件使用"},"44.26":{t:"vue插槽\r",p:`插槽slot可以理解为占坑，当使用一个组件的时候，在组件标签里的对应的内容就会替换掉这个组件中的slot标签。

插槽分为默认插槽，具名插槽，作用域插槽。
默认插槽 子组件中用slot标签来确定渲染位 ...`,l:"audition/vue/vue.html#vue插槽",a:"vue插槽"},"44.27":{t:"组件通信\r",p:`


方式
Vue2
Vue3




父传子
props
props


父传子
$attrs
attrs


父传子孙
provide/inject
provide/inject


子传父
$e ...`,l:"audition/vue/vue.html#组件通信",a:"组件通信"},"44.28":{t:"prosps\r",p:`props定义在子组件里，父组件通过v-bind给子组件传值，子组件渲染出来
`,l:"audition/vue/vue.html#prosps",a:"prosps"},"44.29":{t:"emit\r",p:`
子组件通过自定义事件往父组件里传值，父组件调用子组件通过v-on接收，
父组件里给子组件自定义事件@xxx=func，func是写在父组件中的函数，子组件通过某种方式比如@click=$emit(' ...`,l:"audition/vue/vue.html#emit",a:"emit"},"44.30":{t:"attrs\r",p:`:=attrs
const attrs = useAttrs()
`,l:"audition/vue/vue.html#attrs",a:"attrs"},"44.31":{t:"ref\r",p:`在Vue中，使用ref可以在组件中引用子组件或DOM元素

子组件的ref：当在父组件中使用ref引用子组件时，ref会被赋值为子组件实例。这意味着通过ref可以直接访问子组件的属性和方法，并在父组件 ...`,l:"audition/vue/vue.html#ref",a:"ref"},"44.32":{t:"slot\r",p:`作用域插槽：可以传递数据的插槽，子组件可以将数据传给父组件，父组件在自己的模板中使用该数据。
父接收一个参数slotProps，它是一个包含了插槽数据的对象。
//子
&lt;div &gt;
    ...`,l:"audition/vue/vue.html#slot",a:"slot"},"44.33":{t:"vuex\r",p:`
Vuex是Vue中的全局状态管理框架，它可以管理应用的所有组件的状态。并不是每个项目都需要引入Vuex的，当我们的项目有很多个页面，并且这些页面共享着多个数据状态，此时我们可以引入Vuex。
Vue ...`,l:"audition/vue/vue.html#vuex",a:"vuex"},"44.34":{t:"pinia\r",p:`
创建Store，import {defineStore} from 'pinia',

import {defineStore} from 'pinia'
exporet default mySto ...`,l:"audition/vue/vue.html#pinia",a:"pinia"},"44.35":{t:"调用其他store\r",p:`在 action 里调用其他 store 里的 action 也比较简单，引入对应的 store 后即可访问其内部的方法了。
// src/store/app.ts

export const use ...`,l:"audition/vue/vue.html#调用其他store",a:"调用其他store"},"44.36":{t:"vue自定义指令\r",p:`vue自定义指令
`,l:"audition/vue/vue.html#vue自定义指令",a:"vue自定义指令"},"44.37":{t:"keep-alive\r",p:`&lt;KeepAlive&gt; 是一个内置组件，它的功能是在多个组件间动态切换时缓存被移除的组件实例。

通常我们切换组件的时候，上一个组件就会被销毁，而当我们使用&lt;KeepAlive&gt ...`,l:"audition/vue/vue.html#keep-alive",a:"keep-alive"},"44.38":{t:"activated\r",p:`
首次执行执行顺序：created =&gt; mounted =&gt; activated ...
第二次或以后使用组件时触发activated， beforeCreate created bef ...`,l:"audition/vue/vue.html#activated",a:"activated"},"44.39":{t:"deactivated\r",p:`
使用了keep-alive就不会调用beforeDestroy(组件销毁前钩子)和destroyed(组件销毁)，因为组件没被销毁，被缓存起来了。

`,l:"audition/vue/vue.html#deactivated",a:"deactivated"},"44.40":{t:"vue2混入-Mixin\r",p:`混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。

Mi ...`,l:"audition/vue/vue.html#vue2混入-mixin",a:"vue2混入-mixin"},"44.41":{t:"`Object.defineProperty`和`proxy`区别\r",p:`
Object.defineProperty 只能代理属性，Proxy 代理的是对象。
对象上新增属性，Proxy可以监听到，Object.defineProperty不能。
Object.defin ...`,l:"audition/vue/vue.html#object-defineproperty-和-proxy-区别",a:"object-defineproperty-和-proxy-区别"},"44.42":{t:"vue3内置组件\r",p:`vue3新增了两个内置组件分别是Teleport和Suspense。
`,l:"audition/vue/vue.html#vue3内置组件",a:"vue3内置组件"},"44.43":{t:"teleport\r",p:`可以称之为传送门，作用将其插槽内容渲染到 DOM 中的另一个位置，接收两个参数to（要去的位置）和disabled（是否留在原位置）。接收比如下面代码
&lt;teleport to=&quot;#p ...`,l:"audition/vue/vue.html#teleport",a:"teleport"},"44.44":{t:"Suspense组件\r",p:`
&lt;Suspense&gt; 组件用于协调对组件树中嵌套的异步依赖的处理。
它一般用于包裹多个异步组件处理多个异步组件加载前与完成后的统一状态
&lt;Suspense&gt; 组件可以通过插槽 ...`,l:"audition/vue/vue.html#suspense组件",a:"suspense组件"},"44.45":{t:"nextTick及原理\r",p:"",l:"audition/vue/vue.html#nexttick及原理",a:"nexttick及原理"},"44.46":{t:"vue中的nextTick是干什么用的?\r",p:"在下次 DOM 更新循环结束之后执行延迟回调。它的作用是在 Vue 更新视图后，通过回调函数来访问更新后的 DOM，这个回调函数会在 DOM 更新循环结束之后执行，确保在访问更新后的 DOM 时是准确 ...",l:"audition/vue/vue.html#vue中的nexttick是干什么用的",a:"vue中的nexttick是干什么用的"},"44.47":{t:"vue虚拟dom,diff算法\r",p:"",l:"audition/vue/vue.html#vue虚拟dom-diff算法",a:"vue虚拟dom-diff算法"},"44.48":{t:"什么是虚拟dom？\r",p:`每当我们用原生JS或者JQ操作DOM时，浏览器会从头开始进行DOM树的构建，频繁的操作DOM开销是很大的。
而虚拟DOM就是为了减少这些操作的，虚拟DOM首先会通过状态生成一个虚拟节点树（js对象）， ...`,l:"audition/vue/vue.html#什么是虚拟dom",a:"什么是虚拟dom"},"44.49":{t:"说一下diff算法（对比两棵vdom 树，找到有差异的部分）\r",p:`在vue中是当状态发生改变，用来计算改变后的虚拟DOM与改变前的虚拟DOM之间的差异的算法。
diff算法的本质是找出两个对象之间的差异，目的是尽可能复用节点，也就是通过移动代替新增。
两棵树的 di ...`,l:"audition/vue/vue.html#说一下diff算法-对比两棵vdom-树-找到有差异的部分",a:"说一下diff算法-对比两棵vdom-树-找到有差异的部分"},"44.50":{t:"vue的diff流程\r",p:`
生成新的虚拟DOM树：在每次数据更新时，Vue.js会重新构建一棵新的虚拟DOM树，表示新的UI结构。
比较新旧虚拟DOM树的根节点：Vue.js会比较新旧虚拟DOM树的根节点，判断它们是否相同类型 ...`,l:"audition/vue/vue.html#vue的diff流程",a:"vue的diff流程"},"44.51":{t:"props使用，透传\r",p:`
props 父传子 在父组件里引用的子组件上使用v-bind或：传给子组件，子组件用const props = defineProps([&quot;isShow&quot;])接收
可透传：在上级 ...`,l:"audition/vue/vue.html#props使用-透传",a:"props使用-透传"},"44.52":{t:"emit\r",p:`
定义一个方法,将参数hide传递给父组件，父组件通过@hide监听并接收参数。
可透传

子组件children.vue
const emit = defineEmit([&quot;hide&qu ...`,l:"audition/vue/vue.html#emit",a:"emit"},"44.53":{t:"Vue.nextTick、this.$nextTick（vue2），nextTick（vue3）\r",p:`
组件的更新是异步执行的，这意味着当您修改组件的数据或状态时，Vue并不会立即对DOM进行更新。相反，Vue会将更新操作推入一个更新队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watc ...`,l:"audition/vue/vue.html#vue-nexttick、this-nexttick-vue2-nexttick-vue3",a:"vue-nexttick、this-nexttick-vue2-nexttick-vue3"},"44.54":{t:"v-for的key\r",p:"为了配合diff算法更加高效，key是为了让diff算法更精准的识别到新旧dom的差异的节点，判断元素是新创建的还是被移动的元素，从而减少不必要的元素渲染，v-for不写key默认是index，ind ...",l:"audition/vue/vue.html#v-for的key",a:"v-for的key"},"44.55":{t:"suspense\r",p:"Suspense是一种用于在异步组件加载期间显示占位符内容的特性。有两个插槽#default和#fallback，#default是显示具体内容，#fallback是占位符，当异步组件一些耗时的任务是 ...",l:"audition/vue/vue.html#suspense",a:"suspense"},"44.56":{t:"ref和reactive区别\r",p:`
ref适合基础类型的值将其包装为响应式对象，储存在value中
reactive适合复杂数据类型的对象将其包装成响应式对象，追踪更新对象的多个属性
ref需要用value读取更新值，reactive ...`,l:"audition/vue/vue.html#ref和reactive区别",a:"ref和reactive区别"},"44.57":{t:"slot\r",p:`具名插槽
//父
&lt;template&gt;
  &lt;div&gt;
    &lt;child-component&gt;
      &lt;template v-slot:header ...`,l:"audition/vue/vue.html#slot",a:"slot"},"44.58":{t:"Vue的双向绑定和单向数据流冲突吗?\r",p:"",l:"audition/vue/vue.html#vue的双向绑定和单向数据流冲突吗",a:"vue的双向绑定和单向数据流冲突吗"},"44.59":{t:"单双向绑定，指的是View层和Model层之间的映射关系。\r",p:`
在React中，当View层发生更改时，用户通过发出Actions进行处理，Actions中通过setState对State进行更新，State更新后触发View更新。可以看出，View层不能直接修 ...`,l:"audition/vue/vue.html#单双向绑定-指的是view层和model层之间的映射关系。",a:"单双向绑定-指的是view层和model层之间的映射关系。"},"44.60":{t:"单向数据流 vs 双向数据流\r",p:`

数据流指的是组件之间的数据流动。


Vue与React都是单向数据流的模型，虽然vue有双向绑定v-model，但是vue和react父子组件之间数据传递，仍然还是遵循单向数据流的，父组件可以向 ...`,l:"audition/vue/vue.html#单向数据流-vs-双向数据流",a:"单向数据流-vs-双向数据流"},"44.61":{t:"SPA首屏加载速度慢的怎么解决？\r",p:`
网络延时问题
资源文件体积是否过大
资源是否重复发送请求去加载了
加载脚本的时候，渲染内容堵塞了

`,l:"audition/vue/vue.html#spa首屏加载速度慢的怎么解决",a:"spa首屏加载速度慢的怎么解决"},"44.62":{t:"解决方案\r",p:`
减小入口文件积 (路由懒加载，动态路由)
静态资源本地缓存(合理利用localStorage)
UI框架按需加载
图片资源的压缩
组件重复打包 （在webpack的config文件中，修改Commo ...`,l:"audition/vue/vue.html#解决方案",a:"解决方案"},"44.63":{t:"说下你的vue项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢？\r",p:`
文件夹和文件夹内部文件的语义一致性
就近原则，紧耦合的文件应该放到一起，且应以相对路径引用
公共的文件应该以绝对路径的方式从根目录引用
/src 外的文件不应该被引入
vue-cli脚手架已经帮我们 ...`,l:"audition/vue/vue.html#说下你的vue项目的目录结构-如果是大型项目你该怎么划分结构和划分组件呢",a:"说下你的vue项目的目录结构-如果是大型项目你该怎么划分结构和划分组件呢"},"44.64":{t:"vue使用css 通过 style 标签编写样式\r",p:`
scoped 属性决定编写的样式是否局部有效
lang 属性设置预处理器
内联样式风格的方式来根据最新状态设置和改变css

`,l:"audition/vue/vue.html#vue使用css-通过-style-标签编写样式",a:"vue使用css-通过-style-标签编写样式"},"45.0":{t:"# vue 的响应式\r",p:"\r",l:"audition/vue/vue响应式原理.html",a:"vue-的响应式"},"45.1":{t:"观察者模式和发布订阅模式\r",p:"\r",l:"audition/vue/vue响应式原理.html#观察者模式和发布订阅模式",a:"观察者模式和发布订阅模式"},"45.2":{t:"什么是观察者模式\r",p:"当对象之间存在一对多的依赖关系时，其中一个对象的状态发生改变，所有依赖它的对象都会收到通知，这就是观察者模式。在观察者模式中，只有两种主体：目标对象 (Object) 和 观察者 (Observer) ...",l:"audition/vue/vue响应式原理.html#什么是观察者模式",a:"什么是观察者模式"},"45.3":{t:"什么是发布订阅模式\r",p:"基于一个事件（主题）通道，希望接收通知的对象 Subscriber 通过自定义事件订阅主题，被激活事件的对象 Publisher 通过发布主题事件的方式通知各个订阅该主题的 Subscriber 对象 ...",l:"audition/vue/vue响应式原理.html#什么是发布订阅模式",a:"什么是发布订阅模式"},"45.4":{t:"vue2的响应式原理\r",p:"大意：通过observe里的defineReactive方法里面的Object.defineProperty方法的get（读取数据触发，收集依赖）和set（修改数据触发，派发更新依赖）进行响应式的绑定 ...",l:"audition/vue/vue响应式原理.html#vue2的响应式原理",a:"vue2的响应式原理"},"45.5":{t:"Vue2 响应系统\r",p:`其核心有三点：observe（响应式）、watcher(依赖)、dep（依赖管理）
在 vue2 初始化数据 data 和 computed 数据过程中。会涉及到以下几个对象：

Observe （响 ...`,l:"audition/vue/vue响应式原理.html#vue2-响应系统",a:"vue2-响应系统"},"45.6":{t:"Vue2 observe（响应式）\r",p:"\r",l:"audition/vue/vue响应式原理.html#vue2-observe-响应式",a:"vue2-observe-响应式"},"45.7":{t:"Object.defineProperty 数据劫持、数据代理\r",p:`被Object.defineProperty绑定过的对象，会变成「响应式」化。也就是改变这个对象的时候会触发get和set事件。进而触发一些视图更新。
const obj = {}

let val  ...`,l:"audition/vue/vue响应式原理.html#object-defineproperty-数据劫持、数据代理",a:"object-defineproperty-数据劫持、数据代理"},"45.8":{t:"defineReactive\r",p:`我们需要一个全局的变量来保存这个属性的值
// value使用了参数默认值
function defineReactive(data, key, value = data[key]) {
  cons ...`,l:"audition/vue/vue响应式原理.html#definereactive",a:"definereactive"},"45.9":{t:"observe\r",p:`如果obj有多个属性呢？我们可以新建一个类Observer来遍历该对象，Vue中用Observer类来管理上述响应式化Object.defineProperty的过程。
class Observer  ...`,l:"audition/vue/vue响应式原理.html#observe",a:"observe"},"45.10":{t:"数组是怎么做到响应式的\r",p:"改写了Array.prototype叫arraymothods，以Array.prototype为原型，创建了arraymothods的对象以object.setPrototypeOf强制让vue的数 ...",l:"audition/vue/vue响应式原理.html#数组是怎么做到响应式的",a:"数组是怎么做到响应式的"},"45.11":{t:"Vue2 watcher\r",p:`
dep收集的依赖就是watcher

2. observe中在数据被读的时候，触发getter方法，执行Dep来收集watcher（依赖），此时watcher在dep集合里
3. Dep使用发布订阅 ...`,l:"audition/vue/vue响应式原理.html#vue2-watcher",a:"vue2-watcher"},"45.12":{t:"watcher和数据之间的关系\r",p:`watcher订阅一个或多个数据，数据称为wacther的依赖，数据变化时（setter方法）通知watcher，watcher收到后执行回调，通知组件,通过虚拟dom和diff算法进行页面更新
!w ...`,l:"audition/vue/vue响应式原理.html#watcher和数据之间的关系",a:"watcher和数据之间的关系"},"45.13":{t:"watcher依赖的数据改变方式有\r",p:`
直接渲染render，
有通过computed计算属性改变

常见的场景有下面这几个：

数据变 → 使用数据的视图变
数据变 → 使用数据的计算属性变 → 使用计算属性的视图变
数据变 → 开发者 ...`,l:"audition/vue/vue响应式原理.html#watcher依赖的数据改变方式有",a:"watcher依赖的数据改变方式有"},"45.14":{t:"Vue2 dep\r",p:`使用发布订阅者模式

每个属性拥有自己的消息订阅器 dep，dep类里的this.subs=[],数组里存放所有订阅了该属性的观察者对象watcher,
我们通过defineReactive方法将da ...`,l:"audition/vue/vue响应式原理.html#vue2-dep",a:"vue2-dep"},"45.15":{t:"DEP怎么收集依赖的\r",p:`我们如何知道data中的某个属性被使用了，答案就是Object.defineProperty，因为读取某个属性就会触发get方法。可以将代码进行如下改造：
function defineReactiv ...`,l:"audition/vue/vue响应式原理.html#dep怎么收集依赖的",a:"dep怎么收集依赖的"},"45.16":{t:"vue3 的响应式原理\r",p:`因为 Object.definePorperty 只能对 对象的已知属性 进行操作，所有才会导致 没有在 data 中进行声明的对象属性直接赋值时无法触发视图更新

碍于 Object.defineP ...`,l:"audition/vue/vue响应式原理.html#vue3-的响应式原理",a:"vue3-的响应式原理"},"45.17":{t:"vue3 proxy\r",p:`Vue3 的响应式原理依赖了 Proxy 这个核心 API，通过 Proxy 可以劫持对象的某些操作。
const obj = { a: 1 };
const p = new Proxy(obj, { ...`,l:"audition/vue/vue响应式原理.html#vue3-proxy",a:"vue3-proxy"},"45.18":{t:"vue3的收集依赖\r",p:`get时，收集不同代理对象不同属性所依赖的副作用函数
set时，取出当前属性所依赖的所有副作用函数，重新执行
!内部的执行过程

调用 reactive() 返回一个 Proxy 代理对象，并劫持对象 ...`,l:"audition/vue/vue响应式原理.html#vue3的收集依赖",a:"vue3的收集依赖"},"45.19":{t:"vue3 reactive\r",p:`reactive 会返回如下一个 Proxy 对象
const reactive = (target) =&gt; {
  return new Proxy(target, {
    get(tar ...`,l:"audition/vue/vue响应式原理.html#vue3-reactive",a:"vue3-reactive"},"45.20":{t:"vue3 effect\r",p:"首先定义全局的 activeEffect，它永远指向当前正在执行的 effect 副作用函数。effect 为 fn 创建一个内部的副作用函数，然后立即执行，此时会触发对象的 get 操作，调用 tr ...",l:"audition/vue/vue响应式原理.html#vue3-effect",a:"vue3-effect"},"45.21":{t:"vue3 track\r",p:`track 会建立一个 对象（state） =&gt; 属性（counter） =&gt; effect 的一个依赖关系
const targetMap = new WeakMap();
functi ...`,l:"audition/vue/vue响应式原理.html#vue3-track",a:"vue3-track"},"45.22":{t:"vue3 trigger\r",p:`数据变化的时候就会触发代理对象的 set 操作，从而调用 trigger 方法
function trigger(target, key) {
  const depsMap = targetMap. ...`,l:"audition/vue/vue响应式原理.html#vue3-trigger",a:"vue3-trigger"},"45.23":{t:"副作用函数\r",p:"如果函数依赖于外部的状态，无法保证输出相同，就会带来副作用。Vue 通过一个副作用（effect）函数来跟踪当前正在运行的函数。副作用是一个函数包裹器，在函数被调用前就启动跟踪，而 Vue 在派发更新 ...",l:"audition/vue/vue响应式原理.html#副作用函数",a:"副作用函数"},"45.24":{t:"vue2/3的响应式原理比较\r",p:`
在 Vue 中体现最为明显的一点就是：Proxy 代理对象之后不仅可以拦截对象属性的读取、更新、方法调用之外，对整个对象的新增、删除、枚举等也能直接拦截，而 Object.definePropert ...`,l:"audition/vue/vue响应式原理.html#vue2-3的响应式原理比较",a:"vue2-3的响应式原理比较"},"45.25":{t:"vue3响应式核心方法\r",p:`响应式数据声明的核心API，ref,shallowRef,reactive,shallowReactive,readonly,shallowReadonly

shallow浅层作用形式,整个定义 类 ...`,l:"audition/vue/vue响应式原理.html#vue3响应式核心方法",a:"vue3响应式核心方法"},"45.26":{t:"核心方法注意\r",p:`
ref 虽然常常有文章说一般只用来 声明基础数据的响应式，但是其实所有的数据类型声明响应式时都可以使用ref，只是内部为了同时实现基础数据的响应式处理，封装成了一个具有 value 属性的对象，所以 ...`,l:"audition/vue/vue响应式原理.html#核心方法注意",a:"核心方法注意"},"45.27":{t:"activeEffect和effect\r",p:`
activeEffect自动把effect函数收集起来放进对应的dep里
effect副作用函数，函数收集起来放进dep里

let activeEffect
function effect(fn) ...`,l:"audition/vue/vue响应式原理.html#activeeffect和effect",a:"activeeffect和effect"},"45.28":{t:"track函数\r",p:"track函数用来把effect函数收集起来放进dep里，dep为什么用Set呢？因为Set可以自动去重。搜集起来之后，以后只要变量一改变，就执行trigger函数通知dep里所有依赖money变量的 ...",l:"audition/vue/vue响应式原理.html#track函数",a:"track函数"},"45.29":{t:"trigger\r",p:`function trigger(target,key){
    let depsMap = targetMAP.get(target)
    if(depsMap){
        let d ...`,l:"audition/vue/vue响应式原理.html#trigger",a:"trigger"},"45.30":{t:"Map\r",p:`对象里每一个属性都有一个dep，用Map用来存储dep
`,l:"audition/vue/vue响应式原理.html#map",a:"map"},"45.31":{t:"WeakMap\r",p:`来存储每个对象对应的Map
`,l:"audition/vue/vue响应式原理.html#weakmap",a:"weakmap"},"45.32":{t:"reactive\r",p:`receiver相当于proxy代理的对象，替代原对象target，在receiver上访问和修改
function reactive(target){
    const handler = {
  ...`,l:"audition/vue/vue响应式原理.html#reactive",a:"reactive"},"45.33":{t:"Reflect\r",p:`
get(target, key, receiver)：个人理解就是，访问target的key属性，但是this是指向receiver，所以实际是访问的值是receiver的key的值，但是这可不是直 ...`,l:"audition/vue/vue响应式原理.html#reflect",a:"reflect"},"45.34":{t:"proxy和Reflect\r",p:`
Proxy和Reflect的方法都是一一对应的，在Proxy里使用Reflect会提高语义化
Proxy的get对应Reflect.get
Proxy的set对应Reflect.set

`,l:"audition/vue/vue响应式原理.html#proxy和reflect",a:"proxy和reflect"},"46.0":{t:"# vue自定义指令\r",p:`vue 官方提供了v-text、v-for、v-model、v-if 等常用的指令。除此之外vue 还允许开发者自定义指令。面试经常会问什么是自定义指令?你用自定义指令做过哪些功能?
`,l:"audition/vue/vue自定义指令/vue自定义指令.html",a:"vue自定义指令"},"46.1":{t:"什么是自定义指令?\r",p:`vue 允许开发者自定义指令
`,l:"audition/vue/vue自定义指令/vue自定义指令.html#什么是自定义指令",a:"什么是自定义指令"},"46.2":{t:"自定义组件注册\r",p:"vue中指令的注册和组件的注册一样，提供了全局注册和局部注册两种方式，全局注册就是指我们定义的指令可以在项目中任意地方都可以使用，局部注册则意味着只能在注册的当前组件中使用。接下来我们就来学习这两种注 ...",l:"audition/vue/vue自定义指令/vue自定义指令.html#自定义组件注册",a:"自定义组件注册"},"46.3":{t:"钩子函数\r",p:`
directive的第二个参数是钩子函数对象

const myDirective = {
  // 在绑定元素的 attribute 前 或事件监听器应用前调用
  created(el, bin ...`,l:"audition/vue/vue自定义指令/vue自定义指令.html#钩子函数",a:"钩子函数"},"46.4":{t:"注意\r",p:`
当在组件上使用自定义指令时，它会始终应用于组件的根节点，和透传 attributes 类似。
在vue3中如果组件有多个根结点，则指令将会被忽略且抛出一个警告。
组件的一个根结点就是在一个&lt;d ...`,l:"audition/vue/vue自定义指令/vue自定义指令.html#注意",a:"注意"},"46.5":{t:"指令的使用\r",p:"\r",l:"audition/vue/vue自定义指令/vue自定义指令.html#指令的使用",a:"指令的使用"},"46.6":{t:"在`main.js`中引入指令文件\r",p:`全局挂载
import { createApp } from 'vue'
import App from './App.vue'
import vDebounce from '指令地址.js';
co ...`,l:"audition/vue/vue自定义指令/vue自定义指令.html#在-main-js-中引入指令文件",a:"在-main-js-中引入指令文件"},"46.7":{t:"常用自定义指令",p:"",l:"audition/vue/vue自定义指令/vue自定义指令.html#常用自定义指令",a:"常用自定义指令"},"47.0":{t:"# v-copy\r",p:`const vCopy = {
    beforeMount(el, binding) {
        el.copyContent = binding.value
        el.add ...`,l:"audition/vue/vue自定义指令/常用自定义指令/一键复制.html",a:"v-copy"},"48.0":{t:"# v-debounce\r",p:`

`,l:"audition/vue/vue自定义指令/常用自定义指令/防抖.html",a:"v-debounce"},"50.0":{t:"# 加油特种兵\r",p:"\r",l:"audition/实习经验/记录.html",a:"加油特种兵"},"50.1":{t:"vxe-grid\r",p:`vxe-grid的slots插槽内容:row行信息就是data的数据，rowIndex行索引
input是jsx语法，v-model={row.inputvalue}用来row.inputvalue进 ...`,l:"audition/实习经验/记录.html#vxe-grid",a:"vxe-grid"},"50.2":{t:"jsx语法遍历\r",p:`不能用v-for，只能用map来循环
{
    field: &quot;inspectionLevel&quot;,
    title: &quot;检查级别&quot;,
    align: ...`,l:"audition/实习经验/记录.html#jsx语法遍历",a:"jsx语法遍历"},"50.3":{t:"getCheckboxRecords\r",p:`需求：当checkbox选中时，对应行的input为必填
思考：没有用到required，判断当checkbox选中时，对应行的input的inputvalue是否为空。
解决：vxe-grid有一个 ...`,l:"audition/实习经验/记录.html#getcheckboxrecords",a:"getcheckboxrecords"},"50.4":{t:"弹框子组件用v-if\r",p:`弹框子组件用v-if包起来，这样不用了的话就会销毁
&lt;AddAndEditModal ref=&quot;addAndEditModal&quot; :operFlag=&quot;operFl ...`,l:"audition/实习经验/记录.html#弹框子组件用v-if",a:"弹框子组件用v-if"},"51.0":{t:"项目\r",p:`组件库，你认为一个组件都需要具备什么

丰富的组件集合，这包括但不限于按钮、表单输入、模态框、导航栏、表格、图表、轮播图等等
一致的设计语言
灵活的可定制性: 好的组件库应该提供灵活的可定制性选项，允 ...`,l:"audition/面试/b站.html",a:"项目"},"51.1":{t:"npm包管理器，你是怎么管理的\r",p:`
版本控制:
发布日志:
文档维护
持续集成和测试

`,l:"audition/面试/b站.html#npm包管理器-你是怎么管理的",a:"npm包管理器-你是怎么管理的"},"51.2":{t:"git\r",p:`git 回滚

git.rest 完全回退，放弃目标版本之后的提交
git.revert 创建一个新的提交，反做目标版本

`,l:"audition/面试/b站.html#git",a:"git"},"51.3":{t:"vue2和vue3的区别\r",p:`
写法上的区别:vue2使用的是options(选项)Api,vue3的是composition Api(当然vue3也兼容composition api)。options Api中methods，c ...`,l:"audition/面试/b站.html#vue2和vue3的区别",a:"vue2和vue3的区别"},"51.4":{t:"vite 和 wabpack区别\r",p:`
vite是es6模块
webpack是commonjs

`,l:"audition/面试/b站.html#vite-和-wabpack区别",a:"vite-和-wabpack区别"},"51.5":{t:"vite的优势在哪\r",p:`
vite是es6模块，利用了浏览器原生支持的 ES 模块，Webpack 需要使用自己的模块系统和构建过程，对模块进行打包和转换，导致构建速度较慢。
Vite 采用了按需编译的策略，只在需要时编译单 ...`,l:"audition/面试/b站.html#vite的优势在哪",a:"vite的优势在哪"},"51.6":{t:"请求可以取消吗\r",p:"axios的请求可以通过创建了一个 CancelToken.source 实例并将其 token 属性传给Axios 请求的选项中的 cancelToken 字段，我们可以调用 cancel() 方法 ...",l:"audition/面试/b站.html#请求可以取消吗",a:"请求可以取消吗"},"51.7":{t:"代码题\r",p:`
数组转树结构

function ArrayToTree(arr,pid=0){
    if(!Array.isArray(arr) || !arr.length) return
    let  ...`,l:"audition/面试/b站.html#代码题",a:"代码题"},"52.0":{t:"vue的生命周期\r",p:`


Vue2(选项式API)
Vue3(setup)(选项式API)
描述




beforeCreate
-
实例创建前


created
-
实例创建后


beforeMount
onBe ...`,l:"audition/面试/天正.html",a:"vue的生命周期"},"52.1":{t:"vue数据挂载在哪个生命周期\r",p:`看实际情况，一般在created(或者BeforeRouter)里面就可以，如果涉及到需要页面加载完成之后的话用mounted
在created时，视图中的html并没有渲染出来，此时如果直接操作do ...`,l:"audition/面试/天正.html#vue数据挂载在哪个生命周期",a:"vue数据挂载在哪个生命周期"},"52.2":{t:"vue的data为什么要return\r",p:`其实就是一个作用域的问题，在自己的组件中可以访问，别的组件访问不到。
在vue中，data必须是一个函数且返回一个对象，这是因为在vue中每一个组件都是一个单独的实例，如果data是一个对象那么所有的 ...`,l:"audition/面试/天正.html#vue的data为什么要return",a:"vue的data为什么要return"},"52.3":{t:"axios的拦截响应怎么做\r",p:`拦截：
axios.interceptors.response.use(
    function(response){
        //拦截操作
        return response
 ...`,l:"audition/面试/天正.html#axios的拦截响应怎么做",a:"axios的拦截响应怎么做"},"52.4":{t:"组件通讯的方式\r",p:`


方式
Vue2
Vue3




父传子
props
props


子传父
$emit
emits


父传子
$attrs
attrs


子传父
$listeners
无(合并到 attr ...`,l:"audition/面试/天正.html#组件通讯的方式",a:"组件通讯的方式"},"52.5":{t:"vuex的五大部分\r",p:`
State（状态）：State 是应用程序的中央数据存储库，代表了应用程序的整体状态。
Mutation（变更）：Mutation 是修改 State 的唯一途径。
Action（动作）：Actio ...`,l:"audition/面试/天正.html#vuex的五大部分",a:"vuex的五大部分"},"52.6":{t:"pinia\r",p:`
store
State（状态）
Actions（动作）
Getters（获取器）
Mutations没有了，用this获取数据

在 Pinia 中，this.$patch 是一个用于修改状态的特殊 ...`,l:"audition/面试/天正.html#pinia",a:"pinia"},"52.7":{t:"computed和watch区别\r",p:`Watch适用于需要在属性变化时执行异步或开销较大的操作的场景。你可以监视一个或多个属性，并在属性变化时执行特定的操作
Computed属性是基于它们的依赖进行缓存的，只有当依赖发生变化时，才会重新计 ...`,l:"audition/面试/天正.html#computed和watch区别",a:"computed和watch区别"},"52.8":{t:"组件的技术选型你应该怎么考虑\r",p:"\r",l:"audition/面试/天正.html#组件的技术选型你应该怎么考虑",a:"组件的技术选型你应该怎么考虑"},"52.9":{t:"data是个什么格式的\r",p:"\r",l:"audition/面试/天正.html#data是个什么格式的",a:"data是个什么格式的"},"52.10":{t:"你的前端是怎么学的 系统学过吗",p:"",l:"audition/面试/天正.html#你的前端是怎么学的-系统学过吗",a:"你的前端是怎么学的-系统学过吗"},"53.0":{t:"数组存储怎么压缩\r",p:"",l:"audition/面试/字节.html",a:"数组存储怎么压缩"},"53.1":{t:"数据类型\r",p:`js基本，number,String,boolen,null,undefined,bigint,symbol 引用，object，array，function
typeof判断基本null返回obje ...`,l:"audition/面试/字节.html#数据类型",a:"数据类型"},"53.2":{t:"let，const，栈，堆，栈堆那个访问快\r",p:`
let const都是有块作用域的
let 声明的是变量，const声明的是常量，引用类型地址和基本类型存放在栈里，当函数执行完毕后，栈会自动释放这些内存，因此栈的管理非常高效。引用类型的值放在堆里 ...`,l:"audition/面试/字节.html#let-const-栈-堆-栈堆那个访问快",a:"let-const-栈-堆-栈堆那个访问快"},"53.3":{t:"settimeout和settineinterval哪个更准确，设为0怎样\r",p:`setTimeout函数会尽可能快地将任务放入任务队列中,4ms延时
`,l:"audition/面试/字节.html#settimeout和settineinterval哪个更准确-设为0怎样",a:"settimeout和settineinterval哪个更准确-设为0怎样"},"53.4":{t:"事件循环\r",p:"js是单线程的，为了避免耗时任务阻塞队列，有了同步任务和异步任务，同步任务执行完会在异步任务队列里拿任务，异步任务右分为，宏任务微任务，他们都有各自的队列，执行宏任务期间产生的微任务会放入微任务队列， ...",l:"audition/面试/字节.html#事件循环",a:"事件循环"},"53.5":{t:"tcp，udp\r",p:`tcp：面向链接，可靠，字节流，保证数据顺序和完整性
udp：无连接，不可靠，数据报，不保证数据顺序和完整性
`,l:"audition/面试/字节.html#tcp-udp",a:"tcp-udp"},"53.6":{t:"http如何建立连接\r",p:`三次握手
`,l:"audition/面试/字节.html#http如何建立连接",a:"http如何建立连接"},"53.7":{t:"https如何防窃听和篡改，抓过包没，可以修改吗\r",p:`ssl/tsl加密，ssl有对称加密和非对称加密
抓包（Packet Capture）是指拦截和记录通过网络传输的数据包的过程。网络抓包工具可以截获在网络上发送和接收的数据
`,l:"audition/面试/字节.html#https如何防窃听和篡改-抓过包没-可以修改吗",a:"https如何防窃听和篡改-抓过包没-可以修改吗"},"53.8":{t:"promise状态，状态可以改变吗，常用的静态方法\r",p:`pending,fuillied,rejected,fuillied到rejected状态不可变，all，some,
`,l:"audition/面试/字节.html#promise状态-状态可以改变吗-常用的静态方法",a:"promise状态-状态可以改变吗-常用的静态方法"},"53.9":{t:"vue怎么防止xss攻击\r",p:`xss攻击是恶意注入脚本，盗取存储在客户端的cookie或者有用户敏感信息，反射性（表单提交），存储型（脚本存在服务器里，脚本在服务器返回，在浏览器执行），dom型（修改web页面的dom触发攻击）
`,l:"audition/面试/字节.html#vue怎么防止xss攻击",a:"vue怎么防止xss攻击"},"53.10":{t:"vue如何渲染用户想要的自定义文本（文本编辑器）\r",p:"\r",l:"audition/面试/字节.html#vue如何渲染用户想要的自定义文本-文本编辑器",a:"vue如何渲染用户想要的自定义文本-文本编辑器"},"53.11":{t:"手写题1：settimeout(() => ，1000)怎么让1在2s后打印，不能直接修改时间\r",p:`

`,l:"audition/面试/字节.html#console-log-1",a:"console-log-1"},"53.12":{t:"手写题2：实例链式调用：如let a = new Man(); a.sleep(3000).sayHi().sleep(1000).sleep(2000).sayHi()；写出Man()构造函数\r",p:`\r
\r`,l:"audition/面试/字节.html#手写题2-实例链式调用-如let-a-new-man-a-sleep-3000-sayhi-sleep-1000-sleep-2000-sayhi-写出man-构造函数",a:"手写题2-实例链式调用-如let-a-new-man-a-sleep-3000-sayhi-sleep-1000-sleep-2000-sayhi-写出man-构造函数"},"53.13":{t:"手写题3：遍历DOM树打印每个元素的tagName\r",p:`    function traverseDOMTree(element) {
    // 打印当前元素的tagName
    console.log(element.tagName);

    ...`,l:"audition/面试/字节.html#手写题3-遍历dom树打印每个元素的tagname",a:"手写题3-遍历dom树打印每个元素的tagname"},"53.14":{t:"手写题4：打印数组全排列，`[1,2,3]` 打印`[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]`\r",p:`function permuteArray(nums) {
    const result = [];
    
    function backtrack(current, remaining) ...`,l:"audition/面试/字节.html#手写题4-打印数组全排列-1-2-3-打印-1-2-3-1-3-2-2-1-3-2-3-1-3-1-2-3-2-1",a:"手写题4-打印数组全排列-1-2-3-打印-1-2-3-1-3-2-2-1-3-2-3-1-3-1-2-3-2-1"},"53.15":{t:"项目难点、解决方案\r",p:"",l:"audition/面试/字节.html#项目难点、解决方案",a:"项目难点、解决方案"},"53.16":{t:"canvas、svg的区别\r",p:`Canvas是基于位图的绘图技术，图形缩放可能会导致图像模糊，它通过js来操作像素，并在画布上绘制图像、图形和动画。
SVG是一种基于矢量图形的绘图技术，使用XML格式描述图形。图形是矢量形式，可以无 ...`,l:"audition/面试/字节.html#canvas、svg的区别",a:"canvas、svg的区别"},"53.17":{t:"canvas绘制的图像怎么用图片形式直接展示(toDataUrl转base64)\r",p:`toDataUrl转base64
const dataURL = canvas.toDataURL(); // 获取Canvas内容的Base64图片数据

`,l:"audition/面试/字节.html#canvas绘制的图像怎么用图片形式直接展示-todataurl转base64",a:"canvas绘制的图像怎么用图片形式直接展示-todataurl转base64"},"53.18":{t:"图片类型和格式分别有哪些，对应的使用场景\r",p:"\r",l:"audition/面试/字节.html#图片类型和格式分别有哪些-对应的使用场景",a:"图片类型和格式分别有哪些-对应的使用场景"},"53.19":{t:"浏览器缓存\r",p:`
强缓存：
强缓存是通过设置HTTP响应头来实现的，让浏览器在一定时间内直接使用本地缓存而不发送请求到服务器。,Expires：指定一个绝对过期时间,Cache-Control：指定一个相对过期时间或 ...`,l:"audition/面试/字节.html#浏览器缓存",a:"浏览器缓存"},"53.20":{t:"虚拟内存\r",p:"虚拟内存通过将部分进程的数据和代码存储在磁盘上，使得每个进程都认为它拥有连续的私有内存空间，而不受实际物理内存大小的限制。这样，多个进程可以在有限的物理内存上运行，从而提高系统的整体性能和资源利用率。 ...",l:"audition/面试/字节.html#虚拟内存",a:"虚拟内存"},"53.21":{t:"CDN\r",p:`CDN就是根据用户位置分配最近的资源,用户在上网的时候不用直接访问源站，访问离他“最近的”一个 CDN 节点，术语叫边缘节点，其实就是缓存了源站内容的代理服务器
应用CDN后，DNS 返回的不再是 I ...`,l:"audition/面试/字节.html#cdn",a:"cdn"},"53.22":{t:"sessionstorage、localstorage\r",p:`浏览器存储，不和服务端进行交互

sessionstorage，存储临时数据，页面关闭就数据消失
localstorage，存储长期使用的数据，页面关闭还会存在，存储的信息在同一域中是共享的

无法像 ...`,l:"audition/面试/字节.html#sessionstorage、localstorage",a:"sessionstorage、localstorage"},"53.23":{t:"进程、线程、chrome内核分别有哪些进程、线程，chrome内核把浏览器多标签设计的进程还是线程，为什么这么设计？\r",p:`进程是运行的程序，一个进程可以有多个线程，分别执行不同的任务，

主进程，渲染进程，GPU进程，网络进程，插件进程，扩展进程，每个进程有多个线程

Chrome浏览器将多标签设计为多进程，每个标签页运 ...`,l:"audition/面试/字节.html#进程、线程、chrome内核分别有哪些进程、线程-chrome内核把浏览器多标签设计的进程还是线程-为什么这么设计",a:"进程、线程、chrome内核分别有哪些进程、线程-chrome内核把浏览器多标签设计的进程还是线程-为什么这么设计"},"53.24":{t:"事件循环输出题\r",p:"",l:"audition/面试/字节.html#事件循环输出题",a:"事件循环输出题"},"53.25":{t:"一面13题追问，怎么实现setTimeout的准时执行(裁剪时间戳，料到字节有补充追问的习惯)\r",p:`采用系统时间补偿法：修正每次时间间隔，前面耽误了时间，那么就缩小当前定时器的间隔时间。
`,l:"audition/面试/字节.html#一面13题追问-怎么实现settimeout的准时执行-裁剪时间戳-料到字节有补充追问的习惯",a:"一面13题追问-怎么实现settimeout的准时执行-裁剪时间戳-料到字节有补充追问的习惯"},"53.26":{t:"vue keep-alive的作用和实现原理\r",p:`keepalive缓存组件，

判断是否缓存：如果name不在inlcude中或者存在于exlude中则表示不缓存，直接返回vnode
需要缓存：是否缓存过，没有则加到存储缓存组件的对象this.ca ...`,l:"audition/面试/字节.html#vue-keep-alive的作用和实现原理",a:"vue-keep-alive的作用和实现原理"},"53.27":{t:"场景题：后端返回的64位大数，前端怎么处理精度丢失的问题\r",p:`bigint，第三方库，拆分合并
`,l:"audition/面试/字节.html#场景题-后端返回的64位大数-前端怎么处理精度丢失的问题",a:"场景题-后端返回的64位大数-前端怎么处理精度丢失的问题"},"53.28":{t:"手写题1：画0.5px的线\r",p:`transform: scaleY(0.5);
`,l:"audition/面试/字节.html#手写题1-画0-5px的线",a:"手写题1-画0-5px的线"},"53.29":{t:"手写题2：发布订阅模式实现event-bus\r",p:"",l:"audition/面试/字节.html#手写题2-发布订阅模式实现event-bus",a:"手写题2-发布订阅模式实现event-bus"},"53.30":{t:"手写题3：数组拍平，flat(3)代表拍平三层\r",p:`function flat (arr){
    let res = []
    for(let item of arr){
        if(Array.isArray(item)){
    ...`,l:"audition/面试/字节.html#手写题3-数组拍平-flat-3-代表拍平三层",a:"手写题3-数组拍平-flat-3-代表拍平三层"},"53.31":{t:"项目难点、解决方案\r",p:"",l:"audition/面试/字节.html#项目难点、解决方案",a:"项目难点、解决方案"},"53.32":{t:"实习有关\r",p:"",l:"audition/面试/字节.html#实习有关",a:"实习有关"},"53.33":{t:"offer情况\r",p:"",l:"audition/面试/字节.html#offer情况",a:"offer情况"},"53.34":{t:"从输入URL到渲染页面的全过程\r",p:`
解析url
DNS查询IP地址
建立连接
客户端发起请求
服务端响应，返回数据
渲染页面

`,l:"audition/面试/字节.html#从输入url到渲染页面的全过程",a:"从输入url到渲染页面的全过程"},"53.35":{t:"强缓存、协商缓存字段、状态码\r",p:`通过http，让浏览器在一定时间内直接使用本地缓存而不想服务器发送请求，设置expires设置一个绝对过期时间和Cache-Control设置一个相对时间最大缓存时间max-age =3000
浏览器 ...`,l:"audition/面试/字节.html#强缓存、协商缓存字段、状态码",a:"强缓存、协商缓存字段、状态码"},"53.36":{t:"长连接、短连接\r",p:`长链接：客户端和服务器之间建立一次连接后保持打开状态，直到到了超时时间或者一方主动断开连接
短连接：客户端和服务器之间建立一次连接后激励关闭链接，
`,l:"audition/面试/字节.html#长连接、短连接",a:"长连接、短连接"},"53.37":{t:"场景题：同一个程序在不同客户端上运行结果不同(运行环境相同)，你怎么排查原因？\r",p:`环境差异，日志记录，版本问题，测试用例，服务器配置，debugger
`,l:"audition/面试/字节.html#场景题-同一个程序在不同客户端上运行结果不同-运行环境相同-你怎么排查原因",a:"场景题-同一个程序在不同客户端上运行结果不同-运行环境相同-你怎么排查原因"},"53.38":{t:"手写题：连续子数组的最大和，除了暴力写三种做法(这道题讨论了40分钟，DP、双指针、分治都用了)",p:"",l:"audition/面试/字节.html#手写题-连续子数组的最大和-除了暴力写三种做法-这道题讨论了40分钟-dp、双指针、分治都用了",a:"手写题-连续子数组的最大和-除了暴力写三种做法-这道题讨论了40分钟-dp、双指针、分治都用了"},"54.0":{t:"项目都有那些组件\r",p:`组件库还需再加
`,l:"audition/面试/星环.html",a:"项目都有那些组件"},"54.1":{t:"垂直居中\r",p:"\r",l:"audition/面试/星环.html#垂直居中",a:"垂直居中"},"54.2":{t:"选择器\r",p:"\r",l:"audition/面试/星环.html#选择器",a:"选择器"},"54.3":{t:"dom的接口\r",p:"\r",l:"audition/面试/星环.html#dom的接口",a:"dom的接口"},"54.4":{t:"组件通讯方式\r",p:"\r",l:"audition/面试/星环.html#组件通讯方式",a:"组件通讯方式"},"54.5":{t:"vue通信方式",p:"",l:"audition/面试/星环.html#vue通信方式",a:"vue通信方式"},"55.0":{t:"# 环境搭建\r",p:`https://code.visualstudio.com/
国内镜像：更换域名vscode.cdn.azure.cn
`,l:"audition/面试/环境搭建.html",a:"环境搭建"},"55.1":{t:"插件\r",p:`
chinese
Live Server
open in browser
quokka.js
Tabnine AI
Vue Language Features (Volar)

`,l:"audition/面试/环境搭建.html#插件",a:"插件"},"55.2":{t:"node \r",p:`label
以管理员身份打开vscode终端，node才好用
`,l:"audition/面试/环境搭建.html#node",a:"node"},"55.3":{t:"vue\r",p:`npm init vue@latest
`,l:"audition/面试/环境搭建.html#vue",a:"vue"},"55.4":{t:"pnpm\r",p:`npm install pnpm -g
`,l:"audition/面试/环境搭建.html#pnpm",a:"pnpm"},"56.0":{t:"数组去重\r",p:`
使用Set数据结构：

const newarr = [...new Set(arr)]


使用filter()方法和indexOf()方法

const newarr = arr.filter( ...`,l:"audition/面试/萌泰.html",a:"数组去重"},"56.1":{t:"数组有那些属性\r",p:"\r",l:"audition/面试/萌泰.html#数组有那些属性",a:"数组有那些属性"},"56.2":{t:"computed和watch区别\r",p:`
用途不同：watch用于监听数据的变化并执行相应的操作，而computed用于根据数据的变化动态计算衍生出的属性值。
触发时机不同：watch是在数据变化时立即执行相应的操作，而computed是在 ...`,l:"audition/面试/萌泰.html#computed和watch区别",a:"computed和watch区别"},"56.3":{t:"那些地方可以用到watch\r",p:`watch可以在以下几个方面使用：

数据监听：watch最常见的用途是监听数据的变化。当数据发生变化时，可以执行相应的操作，如发送网络请求、更新其他数据、触发其他函数等。这对于需要在数据变化时执行一 ...`,l:"audition/面试/萌泰.html#那些地方可以用到watch",a:"那些地方可以用到watch"},"56.4":{t:"vue3的生命周期\r",p:"\r",l:"audition/面试/萌泰.html#vue3的生命周期",a:"vue3的生命周期"},"56.5":{t:"在哪个生命周期拿数据\r",p:`vue2在created中vue3在onmounted中
`,l:"audition/面试/萌泰.html#在哪个生命周期拿数据",a:"在哪个生命周期拿数据"},"56.6":{t:"css flex布局\r",p:`flex弹性布局，通过在父设置display：flex或inline-flex设置，常用属性flex-direction,justify-content,align-items,flex
`,l:"audition/面试/萌泰.html#css-flex布局",a:"css-flex布局"},"56.7":{t:"flex布局的常用属性\r",p:"\r",l:"audition/面试/萌泰.html#flex布局的常用属性",a:"flex布局的常用属性"},"56.8":{t:"垂直居中的方式\r",p:`三种
`,l:"audition/面试/萌泰.html#垂直居中的方式",a:"垂直居中的方式"},"56.9":{t:"vue的通讯方式\r",p:"\r",l:"audition/面试/萌泰.html#vue的通讯方式",a:"vue的通讯方式"},"56.10":{t:"position的属性\r",p:`
static（默认值）元素按照其在文档流中的顺序进行布局，不进行任何特殊的定位。此时 top、right、bottom、left 和 z-index 属性无效。
relative：元素的定位相对于其 ...`,l:"audition/面试/萌泰.html#position的属性",a:"position的属性"},"56.11":{t:"vue的单向数据流\r",p:"Vue 的单向数据流是指数据在 Vue 组件中的传递是单向的，从父组件向子组件传递。这意味着父组件可以通过 props 将数据传递给子组件，但子组件不能直接修改父组件的数据。任何修改都必须通过向父组件 ...",l:"audition/面试/萌泰.html#vue的单向数据流",a:"vue的单向数据流"},"56.12":{t:"为什么要用异步任务\r",p:`
避免阻塞：代码在执行这些操作期间将无法进行其他任务，导致程序停滞。通过使用异步操作，可以在等待这些操作完成的同时，继续执行其他任务，从而避免阻塞。
提升性能和响应性：在网络请求中，异步操作允许在等待 ...`,l:"audition/面试/萌泰.html#为什么要用异步任务",a:"为什么要用异步任务"},"56.13":{t:"为什么要用promise\r",p:"在JavaScript中，Promise（承诺）是一种用于处理异步操作的对象。它被广泛用于处理网络请求、文件读写、数据库操作等需要等待一段时间才能获取结果的任务。使用Promise可以更好地组织和控制 ...",l:"audition/面试/萌泰.html#为什么要用promise",a:"为什么要用promise"},"56.14":{t:"同步任务异步任务任务队列是一个什么样的关系\r",p:`
同步任务：是按照代码顺序依次执行的任务，会阻塞主线程的执行，直到任务完成
异步任务：是在特定条件下触发并在后台执行的任务，触发和执行是非阻塞的，通常是一些比较耗时的任务，它们的执行通常由底层的操作系 ...`,l:"audition/面试/萌泰.html#同步任务异步任务任务队列是一个什么样的关系",a:"同步任务异步任务任务队列是一个什么样的关系"},"56.15":{t:"事件循环\r",p:`事件循环：负责协调同步任务和异步任务和任务队列之间的关系的机制，不断地从任务队列中取出任务，按照一定顺序执行，一定事件循环周期内，先处理微任务队列中的任务在处理宏任务
`,l:"audition/面试/萌泰.html#事件循环",a:"事件循环"},"56.16":{t:"css选择器排序\r",p:`
内联样式的权重为1000。
ID选择器的权重为100。
类选择器、属性选择器和伪类选择器的权重为10。
元素选择器和伪元素选择器的权重为1。

`,l:"audition/面试/萌泰.html#css选择器排序",a:"css选择器排序"},"57.0":{t:"闭包\r",p:"\r",l:"audition/面试/记录.html",a:"闭包"},"57.1":{t:"媒体查询原理\r",p:"\r",l:"audition/面试/记录.html#媒体查询原理",a:"媒体查询原理"},"57.2":{t:"还有什么能改变this指向\r",p:"\r",l:"audition/面试/记录.html#还有什么能改变this指向",a:"还有什么能改变this指向"},"57.3":{t:"组件库封装模态框",p:"",l:"audition/面试/记录.html#组件库封装模态框",a:"组件库封装模态框"},"58.0":{t:"# 最全前端代码",p:"",l:"code/introductor.html",a:"最全前端代码"},"59.0":{t:"# code\r",p:"",l:"code/js/code.html",a:"code"},"59.1":{t:"防抖\r",p:`有事件触发就清空定时器，开始下一个定时
function debounce(fn, delay) {
    let timmer = null;
    return function () {
  ...`,l:"code/js/code.html#防抖",a:"防抖"},"59.2":{t:"节流\r",p:`在一定时间内执行一次
function throottle(fn,delay){
    let temmer = null;
    return function () {
        let ...`,l:"code/js/code.html#节流",a:"节流"},"59.3":{t:"深拷贝\r",p:"",l:"code/js/code.html#深拷贝",a:"深拷贝"},"59.4":{t:"递归实现深拷贝\r",p:`function deepcopy(obj) {
    if (typeof obj !== 'object' || obj === null) return obj;
    let copy
  ...`,l:"code/js/code.html#递归实现深拷贝",a:"递归实现深拷贝"},"59.5":{t:"JSON实现简单的\r",p:`function deepCopy(obj) {
  return JSON.parse(JSON.stringify(obj));
}


注意：

不能拷贝包含函数、正则表达式、undefined ...`,l:"code/js/code.html#json实现简单的",a:"json实现简单的"},"59.6":{t:"判断类型的函数\r",p:`function getType(obj) {
    let type = typeof obj;
    if (type !== 'object') {
        return type
 ...`,l:"code/js/code.html#判断类型的函数",a:"判断类型的函数"},"59.7":{t:"最长递增子序列\r",p:`var lengthOfLIS = function(nums) {
    const dp = new Array(nums.length).fill(1)
    for(let i= 0;i& ...`,l:"code/js/code.html#最长递增子序列",a:"最长递增子序列"},"59.8":{t:"bind\r",p:`Function.prototype.myBind = function (context) {
    // 判断调用对象是否为函数
    if (typeof this !== &quot;fu ...`,l:"code/js/code.html#bind",a:"bind"},"59.9":{t:"手写题4：打印数组全排列，`[1,2,3]` 打印`[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]`\r",p:`function permuteArray(nums) {
    const result = [];
    
    function backtrack(current, remaining) ...`,l:"code/js/code.html#手写题4-打印数组全排列-1-2-3-打印-1-2-3-1-3-2-2-1-3-2-3-1-3-1-2-3-2-1",a:"手写题4-打印数组全排列-1-2-3-打印-1-2-3-1-3-2-2-1-3-2-3-1-3-1-2-3-2-1"},"59.10":{t:"手写题：连续子数组的最大和\r",p:`//动态规划
var maxSubArray = function(nums) {
    let max = nums[0]
    let dp = Array.from(nums.length) ...`,l:"code/js/code.html#手写题-连续子数组的最大和",a:"手写题-连续子数组的最大和"},"60.0":{t:"# promise\r",p:`class Mypromise {
    #value
    #reason
    #state = 0
    #rescallbacks = []
    #rejcallbacks = [ ...`,l:"code/promise/promise.html",a:"promise"},"61.0":{t:"# promiseall\r",p:`function promiseAll(promises) {
   return new Promise((resolve, reject) =&gt; {
       let result =  ...`,l:"code/promise/promiseall.html",a:"promiseall"},"61.1":{t:"promise.race\r",p:`function promiseRace(promises) {
  return new Promise((resolve, reject) =&gt; {
    for (let promise ...`,l:"code/promise/promiseall.html#promise-race",a:"promise-race"},"62.0":{t:"# vue3响应式proxy\r",p:`let activeEffect
function effect(fn){
    activeEffect = fn
    activeEffect()
    activeEffect=null ...`,l:"code/vue3响应式/vue3响应式.html",a:"vue3响应式proxy"},"63.0":{t:"# v-copy\r",p:`const vCopy = {
    beforeMount(el, binding) {
        el.copyContent = binding.value
        el.add ...`,l:"code/vue的自定义指令/一键复制.html",a:"v-copy"},"64.0":{t:"# v-debounce\r",p:`

`,l:"code/vue的自定义指令/防抖.html",a:"v-debounce"},"65.0":{t:"# 创建对象\r",p:"\r",l:"code/创建对象/creatobj.html",a:"创建对象"},"65.1":{t:"直接创建\r",p:`let current = {
    name: 'John',
    age: 20
}
console.log(current)

`,l:"code/创建对象/creatobj.html#直接创建",a:"直接创建"},"65.2":{t:"new object()创建\r",p:`let obj = new Object()
obj.name = 'John'
obj.age = 20

console.log(obj)

`,l:"code/创建对象/creatobj.html#new-object-创建",a:"new-object-创建"},"65.3":{t:"工厂方法1\r",p:`function createPerson(name, age) {
    // let o = new Object()
    return {
        name,
        ag ...`,l:"code/创建对象/creatobj.html#工厂方法1",a:"工厂方法1"},"65.4":{t:"工厂方法2\r",p:`function createPerson2(name, age) {
    let o = new Object()
    o.name = name
    o.age = age
    r ...`,l:"code/创建对象/creatobj.html#工厂方法2",a:"工厂方法2"},"65.5":{t:"构造函数\r",p:`function Person(name, age) {
    this.name = name
    this.age = age
}

let john3 = new Person('John ...`,l:"code/创建对象/creatobj.html#构造函数",a:"构造函数"},"65.6":{t:"原型（待定）\r",p:`function Person2() {
    
}
Person2.prototype.name = &quot;John&quot;
Person2.prototype.age = 28

le ...`,l:"code/创建对象/creatobj.html#原型-待定",a:"原型-待定"},"66.0":{t:"# 排序算法\r",p:"\r",l:"code/排序/排序.html",a:"排序算法"},"66.1":{t:"冒泡\r",p:`不多说闭着眼也写得出来
function bubblesort(arr) {
    for (var i = 0; i &lt; arr.length; i++) {
        for (va ...`,l:"code/排序/排序.html#冒泡",a:"冒泡"},"66.2":{t:"选择排序\r",p:`从i = 0开始从后面挑一个比a[i]小的且是最小的数与a[i]交换位置
function selectsort(arr) {
    for (var i = 0; i &lt; arr.lengt ...`,l:"code/排序/排序.html#选择排序",a:"选择排序"},"66.3":{t:"插入排序\r",p:`默认第一个元素被排好序，从第二个元素开始依次与之前的元素比较，指到比较到如果大于当前的的元素则退出循环，插入到当前的的元素的下一位
function insertsort(arr){
    for( ...`,l:"code/排序/排序.html#插入排序",a:"插入排序"},"66.4":{t:"希尔排序\r",p:"取一个增量gap，然后将所有距离为gap的元素分在同一组，并对每一组的元素进行直接插入排序。然后再取一个比第一增量小的整数作为第二增量，重复上述操作…,当增量的大小减到1时，就相当于整个序列被分到一组 ...",l:"code/排序/排序.html#希尔排序",a:"希尔排序"},"66.5":{t:"快速排序\r",p:`找到一个主元pivot的key和value，一般是中间的，让数组形成左边是小于key右边是大于key，然后左边的和右边的递归继续排序
function quicksort (arr){
    let ...`,l:"code/排序/排序.html#快速排序",a:"快速排序"},"67.0":{t:"# ArrayList\r",p:"\r",l:"code/数据结构/ArrayList.html",a:"arraylist"},"67.1":{t:"反转链表\r",p:`头插法
var reverseList = function (head) {
  let temp = new ListNode();
  let next = null;
  while (hea ...`,l:"code/数据结构/ArrayList.html#反转链表",a:"反转链表"},"67.2":{t:"回文链表\r",p:`放入数组，双指针一前一后判断判断
var isPalindrome = function(head) {
    let n = head.length
    let header = []
    ...`,l:"code/数据结构/ArrayList.html#回文链表",a:"回文链表"},"67.3":{t:"移除链表元素\r",p:`在head指针前造一个节点
var removeElements = function(head, val) {
    const prev = new ListNode(0)
    prev.n ...`,l:"code/数据结构/ArrayList.html#移除链表元素",a:"移除链表元素"},"67.4":{t:"相交链表\r",p:`set集合当有重复时return当前节点
var getIntersectionNode = function(headA, headB) {
    const set = new Set()
   ...`,l:"code/数据结构/ArrayList.html#相交链表",a:"相交链表"},"67.5":{t:"回形链表\r",p:`这种找重复值的第一时间要想到set，map
链表值不同，用快慢指针,慢指针和快指针相同时则是回形链表
var hasCycle = function(head) {
    let slow = he ...`,l:"code/数据结构/ArrayList.html#回形链表",a:"回形链表"},"67.6":{t:"删除排序链表中的重复元素\r",p:`指针
var deleteDuplicates = function(head) {
    if(!head) return head
    let prev = head
    let nex ...`,l:"code/数据结构/ArrayList.html#删除排序链表中的重复元素",a:"删除排序链表中的重复元素"},"67.7":{t:"合并两个有序链表\r",p:`递归
var mergeTwoLists = function(list1, list2) {
    if(list1 == null){
        return list2
    }els ...`,l:"code/数据结构/ArrayList.html#合并两个有序链表",a:"合并两个有序链表"},"68.0":{t:"# 二叉树\r",p:`
`,l:"code/数据结构/erchashu.html",a:"二叉树"},"69.0":{t:"# 哈希表\r",p:"\r",l:"code/数据结构/哈希/hash.html",a:"哈希表"},"69.1":{t:"哈希函数\r",p:`function hashFunc(str, size) {
    let hash = 0
    for (let i = 0; i &lt; str.length; i++) {
       ...`,l:"code/数据结构/哈希/hash.html#哈希函数",a:"哈希函数"},"69.2":{t:"put\r",p:`hashTable.prototype.put = function (key, value) {
    let index = hashFunc(key, this.limit)
    let  ...`,l:"code/数据结构/哈希/hash.html#put",a:"put"},"69.3":{t:"get\r",p:`hashTable.prototype.get = function (key) {
    let index = hashFunc(key, this.limit)
    let bucket  ...`,l:"code/数据结构/哈希/hash.html#get",a:"get"},"69.4":{t:"remove\r",p:`hashTable.prototype.remove = function (key) {
    let index = hashFunc(key, this.limit)
    let buck ...`,l:"code/数据结构/哈希/hash.html#remove",a:"remove"},"69.5":{t:"判断质数\r",p:`//判断质数
hashTable.prototype.isPrime= function(num) {
    let temp = parseInt(Math.sqrt(num));
    for ...`,l:"code/数据结构/哈希/hash.html#判断质数",a:"判断质数"},"69.6":{t:"得到质数\r",p:`hashTable.prototype.getPrime= function(num) {
    while(!this.isPrime(num)){
        num++
    }
    ...`,l:"code/数据结构/哈希/hash.html#得到质数",a:"得到质数"},"69.7":{t:"其他\r",p:`hashTable.prototype.isEmpty = function () {
    return this.count == 0
}

hashTable.prototype.size = ...`,l:"code/数据结构/哈希/hash.html#其他",a:"其他"},"70.0":{t:"# 栈\r",p:`普通构造函数封装
function Stack() {
    this.arr = [];

}

Stack.prototype.push = function(element) {
    th ...`,l:"code/数据结构/栈/栈.html",a:"栈"},"70.1":{t:"例子\r",p:`十进制转二进制
function dec2bin (number){
    const stack = new Stack()
    while (number &gt; 0) {
        ...`,l:"code/数据结构/栈/栈.html#例子",a:"例子"},"71.0":{t:"# 二叉搜索树\r",p:"",l:"code/数据结构/树/二叉搜索树.html",a:"二叉搜索树"},"71.1":{t:"什么是二叉搜索树?\r",p:`

二叉搜索树（BST，Binary Search Tree），也称二叉排序树或二叉查找树


二叉搜索树是一颗二叉树, 可以为空；如果不为空，满足以下性质：

非空左子树的所有键值小于其根结点的键值 ...`,l:"code/数据结构/树/二叉搜索树.html#什么是二叉搜索树",a:"什么是二叉搜索树"},"71.2":{t:"二叉搜索树的特点:\r",p:`
二叉搜索树的特点就是相对较小的值总是保存在左结点上, 相对较大的值总是保存在右结点上.
那么利用这个特点, 我们可以做什么事情呢?
查找效率非常高, 这也是二叉搜索树中, 搜索的来源.

`,l:"code/数据结构/树/二叉搜索树.html#二叉搜索树的特点",a:"二叉搜索树的特点"},"71.3":{t:"二叉搜索树常见的操作\r",p:`
insert(key)：向树中插入一个新的键。
search(key)：在树中查找一个键，如果结点存在，则返回true；如果不存在，则返回false。
inOrderTraverse：通过中序遍历方 ...`,l:"code/数据结构/树/二叉搜索树.html#二叉搜索树常见的操作",a:"二叉搜索树常见的操作"},"71.4":{t:"创建二叉搜索树\r",p:`
封装binarySerachTree的构造函数.
还需要封装一个用于保存每一个结点的类Node

该类包含三个属性: 结点对应的key, 指向的左子树, 指向的右子树


对于binarySerac ...`,l:"code/数据结构/树/二叉搜索树.html#创建二叉搜索树",a:"创建二叉搜索树"},"71.5":{t:"insert(key)\r",p:`插入叶子结点
    binarySerachTree.prototype.insert = function (key) {
        let newNode = new Node(key); ...`,l:"code/数据结构/树/二叉搜索树.html#insert-key",a:"insert-key"},"71.6":{t:"遍历二叉搜索树\r",p:`遍历二叉搜索树
`,l:"code/数据结构/树/二叉搜索树.html#遍历二叉搜索树",a:"遍历二叉搜索树"},"71.7":{t:"先序遍历\r",p:`先序遍历,从根节点开始
    binarySerachTree.prototype.preOrderTraversal = function (handler) {
        return t ...`,l:"code/数据结构/树/二叉搜索树.html#先序遍历",a:"先序遍历"},"71.8":{t:"中序遍历\r",p:`中序遍历，从左子树开始，根节点在中间
    binarySerachTree.prototype.inOrderTraversal = function (handler) {
        re ...`,l:"code/数据结构/树/二叉搜索树.html#中序遍历",a:"中序遍历"},"71.9":{t:"后序遍历\r",p:`根节点在最后
    binarySerachTree.prototype.postOrderTraversal = function (handler) {
        return this. ...`,l:"code/数据结构/树/二叉搜索树.html#后序遍历",a:"后序遍历"},"71.10":{t:"最大最小值\r",p:`    binarySerachTree.prototype.min = function () {
        let node = this.root
        while (node. ...`,l:"code/数据结构/树/二叉搜索树.html#最大最小值",a:"最大最小值"},"71.11":{t:"查找特定值 search(key)\r",p:`
查找特定值-递归法

    binarySerachTree.prototype.search = function (key) {
        return this.searchNode( ...`,l:"code/数据结构/树/二叉搜索树.html#查找特定值-search-key",a:"查找特定值-search-key"},"71.12":{t:"二叉搜索树的删除\r",p:`删除节点要从查找要删的节点开始, 找到节点后, 需要考虑三种情况:

该节点是也结点(没有子节点, 比较简单)
该节点有一个子节点(也相对简单)
该节点有两个子节点.(情况比较复杂)

查找删除的节点 ...`,l:"code/数据结构/树/二叉搜索树.html#二叉搜索树的删除",a:"二叉搜索树的删除"},"71.13":{t:"情况一: 没有子节点\r",p:`
这种情况相对比较简单, 我们需要检测current的left以及right是否都为null.
都为null之后还要检测一个东西, 就是是否current就是根, 都为null, 并且为跟根, 那么相 ...`,l:"code/数据结构/树/二叉搜索树.html#情况一-没有子节点",a:"情况一-没有子节点"},"71.14":{t:"情况二: 一个子节点\r",p:`::: warning caution
tip warning danger
:::
这种情况也不是很难.

要删除的current结点, 只有2个连接(如果有两个子结点, 就是三个连接了), 一个连 ...`,l:"code/数据结构/树/二叉搜索树.html#情况二-一个子节点",a:"情况二-一个子节点"},"71.15":{t:"情况三: 两个子节点\r",p:`&lt;!-- 又分三种情况 --&gt;

如果我们要删除的节点有两个子节点, 甚至子节点还有子节点, 这种情况下我们需要从下面的子节点中找到一个节点, 来替换当前的节点.


但是找到的这个节点有 ...`,l:"code/数据结构/树/二叉搜索树.html#情况三-两个子节点",a:"情况三-两个子节点"},"71.16":{t:"删除节点完整代码\r",p:`//删除
binarySerachTree.prototype.remove = function (key) {
    let current = this.root
    let parent ...`,l:"code/数据结构/树/二叉搜索树.html#删除节点完整代码",a:"删除节点完整代码"},"72.0":{t:"# 链表\r",p:"\r",l:"code/数据结构/链表/链表.html",a:"链表"},"72.1":{t:"js普通构造函数\r",p:`function linkedList() {
    function node(data) {
        this.data = data;
        this.next = null ...`,l:"code/数据结构/链表/链表.html#js普通构造函数",a:"js普通构造函数"},"72.2":{t:"增 append\r",p:`    linkedList.prototype.append = function (data) {
        var newNode = new node(data);
        // ...`,l:"code/数据结构/链表/链表.html#增-append",a:"增-append"},"72.3":{t:"tostring\r",p:`    linkedList.prototype.tostring = function () {
        var str = &quot;&quot;;
        var curren ...`,l:"code/数据结构/链表/链表.html#tostring",a:"tostring"},"72.4":{t:"insert\r",p:`    linkedList.prototype.insert = function (position, data) {
        var newNode = new node(data)
  ...`,l:"code/数据结构/链表/链表.html#insert",a:"insert"},"72.5":{t:"get\r",p:`    linkedList.prototype.get = function (position) {
        if (position &lt; 0 || position &gt;= t ...`,l:"code/数据结构/链表/链表.html#get",a:"get"},"72.6":{t:"indexOf\r",p:`    linkedList.prototype.indexOf = function (data) {
        let current = this.head
        let ind ...`,l:"code/数据结构/链表/链表.html#indexof",a:"indexof"},"72.7":{t:"update\r",p:`    linkedList.prototype.update = function (position, data) {
        if (position &lt; 0 || positio ...`,l:"code/数据结构/链表/链表.html#update",a:"update"},"72.8":{t:"remove\r",p:`    linkedList.prototype.remove = function (position) {
        if (position &lt; 0 || position &gt; ...`,l:"code/数据结构/链表/链表.html#remove",a:"remove"},"72.9":{t:"removedata\r",p:`    linkedList.prototype.removedata = function (data) {
        let current = this.head
        let  ...`,l:"code/数据结构/链表/链表.html#removedata",a:"removedata"},"72.10":{t:"isEmpty、size、clear\r",p:`    linkedList.prototype.isEmpty = function () {
        return this.length === 0
    }

    linkedL ...`,l:"code/数据结构/链表/链表.html#isempty、size、clear",a:"isempty、size、clear"},"72.11":{t:"js普通构造函数版本code\r",p:`:::details 完整代码
function linkedList() {
    function node(data) {
        this.data = data;
         ...`,l:"code/数据结构/链表/链表.html#js普通构造函数版本code",a:"js普通构造函数版本code"},"72.12":{t:"class语法糖版本code\r",p:`:::details 全部代码
class linkedList {
    // function node(data) {
    //     this.data = data;
    //  ...`,l:"code/数据结构/链表/链表.html#class语法糖版本code",a:"class语法糖版本code"},"73.0":{t:"# 优先级队列\r",p:"\r",l:"code/数据结构/队列/优先级队列.html",a:"优先级队列"},"73.1":{t:"普通构造函数封装\r",p:`
function Queue() {
    this.arr = [];

    
    Queue.prototype.dequeue = function () {
        ret ...`,l:"code/数据结构/队列/优先级队列.html#普通构造函数封装",a:"普通构造函数封装"},"73.2":{t:"class语法糖封装\r",p:`class Queue {
    constructor() {
        this.arr = [];
    }
    enqueue(value) {
        this.arr ...`,l:"code/数据结构/队列/优先级队列.html#class语法糖封装",a:"class语法糖封装"},"74.0":{t:"# 队列\r",p:"\r",l:"code/数据结构/队列/队列.html",a:"队列"},"74.1":{t:"普通构造函数封装\r",p:`function Queue() {
    this.arr = [];
    Queue.prototype.enqueue = function (element) {
        thi ...`,l:"code/数据结构/队列/队列.html#普通构造函数封装",a:"普通构造函数封装"},"74.2":{t:"例子\r",p:`function myQueue(numlist, num) {
    const queue = new Queue();
    for (let i = 0; i &lt; numlist.l ...`,l:"code/数据结构/队列/队列.html#例子",a:"例子"},"75.0":{t:"# 数组\r",p:`\r
\r`,l:"code/数组/array.html",a:"数组"},"75.1":{t:"Array.prototype.every() \r",p:`判断是否符合条件，有一个不符合就不行,返回true或false
let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
let result6 = arr.every((i ...`,l:"code/数组/array.html#array-prototype-every",a:"array-prototype-every"},"75.2":{t:"Array.prototype.some() \r",p:`判断是否符合条件，有一个符合就行,返回true或false
let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
let result7 = arr.some((item ...`,l:"code/数组/array.html#array-prototype-some",a:"array-prototype-some"},"75.3":{t:"Array.prototype.find()\r",p:`找到符合条件的第一个数,不改变原数组
let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
let result8 = arr.find((item, index) =& ...`,l:"code/数组/array.html#array-prototype-find",a:"array-prototype-find"},"75.4":{t:"Array.prototype.findLast()\r",p:`反方向查找，找到符合条件的第一个数,不改变原数组
let result99 = arr.findLast((item, index) =&gt; {
    return item &gt; 5
}) ...`,l:"code/数组/array.html#array-prototype-findlast",a:"array-prototype-findlast"},"75.5":{t:"Array.prototype.findIndex()\r",p:`找到符合条件的第一个数的索引,里面为回调函数,不改变原数组
let result9 = arr.findIndex((item, index) =&gt; {
    return item &gt; ...`,l:"code/数组/array.html#array-prototype-findindex",a:"array-prototype-findindex"},"75.6":{t:"Array.prototype.indexOf()\r",p:`返回某个元素的第一个索引，里面是一个值,不改变原数组
let result11 = arr.indexOf(6)
console.log('result11:', result11) //result ...`,l:"code/数组/array.html#array-prototype-indexof",a:"array-prototype-indexof"},"75.7":{t:"Array.prototype.lastIndexOf()\r",p:`方法返回指定元素在数组中的最后一个的索引
let result12 = arr.lastIndexOf(10)
console.log('result12:', result12) //result1 ...`,l:"code/数组/array.html#array-prototype-lastindexof",a:"array-prototype-lastindexof"},"75.8":{t:"Array.prototype.includes()\r",p:`判断是否包含某个元素,返回true或false
let result10 = arr.includes(10)

console.log('result10:', result10)

`,l:"code/数组/array.html#array-prototype-includes",a:"array-prototype-includes"},"75.9":{t:"Array.prototype.map()\r",p:`将数组中的每个元素映射到另一个数组中，不改变原数组,产生一个新的数组
let result14 = arr.map((item, index) =&gt; {
    return item * 2
 ...`,l:"code/数组/array.html#array-prototype-map",a:"array-prototype-map"},"75.10":{t:"Array.prototype.forEach()\r",p:`方法对数组的每个元素执行一次给定的函数，不产生数组，对原数组也没影响。
let arr8 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
let result27 = arr8.f ...`,l:"code/数组/array.html#array-prototype-foreach",a:"array-prototype-foreach"},"75.11":{t:"Array.prototype.flat()\r",p:`flat() 方法创建一个新的数组，并根据指定深度递归地将所有子数组元素拼接到新的数组中。
let arr = [1, [2, 3],[ 4, [5, [6, 7], 8], 9], 10]
let  ...`,l:"code/数组/array.html#array-prototype-flat",a:"array-prototype-flat"},"75.12":{t:"Array.prototype.flatMap()\r",p:`
flatMap() 方法对数组中的每个元素应用给定的回调函数，然后将结果展开一级，返回一个新数组。* 它等价于在调用 map() 方法后再调用深度为 1 的 flat() 方法（arr.map(.. ...`,l:"code/数组/array.html#array-prototype-flatmap",a:"array-prototype-flatmap"},"75.13":{t:"Array.prototype.fill ()\r",p:`用一个固定值填充一个数组中从起始索引（默认为 0）到终止索引（默认为 array.length）内的全部元素。它返回修改后的数组，改变原数组
//填充一个数到最后
let result15 = arr ...`,l:"code/数组/array.html#array-prototype-fill",a:"array-prototype-fill"},"75.14":{t:"Array.prototype.filter ()\r",p:`返回一个过滤后的新数组,不改变原数组
let result13 = arr.filter((item, index) =&gt; {
    return item &gt; 5
})

consol ...`,l:"code/数组/array.html#array-prototype-filter",a:"array-prototype-filter"},"75.15":{t:"Array.from()\r",p:`静态方法从可迭代或类数组对象创建一个新的浅拷贝的数组实例。
let arrfrom = 'foobar'
let result16 = Array.from(arrfrom)

console.log ...`,l:"code/数组/array.html#array-from",a:"array-from"},"75.16":{t:"Array.of() \r",p:`方法通过可变数量的参数创建一个新的 Array 实例，而不考虑参数的数量或类型。
Array.of() 和 Array() 构造函数之间的区别在于对单个参数的处理：Array.of(7) 创建一个具有 ...`,l:"code/数组/array.html#array-of",a:"array-of"},"75.17":{t:"Array.prototype.join() \r",p:`方法用于将数组中的元素连接成字符串。
let result18 = arr.join(',')

console.log('result18:', result18) //result18: '1,2 ...`,l:"code/数组/array.html#array-prototype-join",a:"array-prototype-join"},"75.18":{t:"Array.prototype.pop() \r",p:`方法用于删除数组中的最后一个元素,返回删除后的元素,改变原数组
let arr4 = [1, 2, 3, 4, 5, 6, 7, 8]
let result19 = arr4.pop()

conso ...`,l:"code/数组/array.html#array-prototype-pop",a:"array-prototype-pop"},"75.19":{t:"Array.prototype.push() \r",p:`方法用于添加一个或多个元素到数组的末尾。并返回该数组的新长度,改变原数组
let arr5 = [1, 2, 3, 4, 5, 6, 7, 8]
let result20 = arr5.push(9) ...`,l:"code/数组/array.html#array-prototype-push",a:"array-prototype-push"},"75.20":{t:"Array.prototype.shift()\r",p:`
方法从数组中删除第一个元素，并返回该元素的值。改变原数组
Array.prototype.pop() 有着和 shift相似的行为，但是是作用在数组的最后一个元素上的。

let arr11 = [ ...`,l:"code/数组/array.html#array-prototype-shift",a:"array-prototype-shift"},"75.21":{t:"Array.prototype.unshift()\r",p:`方法将一个或多个元素添加到数组的开头，并返回该数组的新长度,改变原数组。
let arr15 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
let result34 = arr1 ...`,l:"code/数组/array.html#array-prototype-unshift",a:"array-prototype-unshift"},"75.22":{t:"Array.prototype.keys()\r",p:`keys() 方法返回一个包含数组中每个索引键的 Array Iterator 对象。
let result21 = arr5.keys()

console.log('result21:', res ...`,l:"code/数组/array.html#array-prototype-keys",a:"array-prototype-keys"},"75.23":{t:"Array.prototype.values()\r",p:`values() 方法返回一个新的 Array Iterator 对象，该对象包含数组每个索引的值。
let result23 = arr5.values()

console.log('result ...`,l:"code/数组/array.html#array-prototype-values",a:"array-prototype-values"},"75.24":{t:"Array.prototype.entries()\r",p:`返回一个新的数组迭代器对象,类似generater函数
let arr6 = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;,  ...`,l:"code/数组/array.html#array-prototype-entries",a:"array-prototype-entries"},"75.25":{t:"Array.prototype.reduce()\r",p:`累加
`,l:"code/数组/array.html#array-prototype-reduce",a:"array-prototype-reduce"},"75.26":{t:"Array.prototype.reduceRight()\r",p:`reduceRight() 方法接受一个函数作为累加器（accumulator）和数组的每个值（从右到左）将其减少为单个值。
let arr9 = [[1, 2],[ 3, 4], [5, 6], [ ...`,l:"code/数组/array.html#array-prototype-reduceright",a:"array-prototype-reduceright"},"75.27":{t:"Array.prototype.reverse()\r",p:`方法将数组中元素的位置颠倒，并返回该数组。数组的第一个元素会变成最后一个，数组的最后一个元素变成第一个。该方法会改变原数组。
let arr10 = [1, 2, 3, 4, 5, 6, 7, 8,  ...`,l:"code/数组/array.html#array-prototype-reverse",a:"array-prototype-reverse"},"75.28":{t:"Array.prototype.slice()\r",p:`slice() 方法返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括end）。原始数组不会被改变。
let arr12 = [1, 2,  ...`,l:"code/数组/array.html#array-prototype-slice",a:"array-prototype-slice"},"75.29":{t:"Array.prototype.sort()\r",p:`sort() 方法用原地算法对数组的元素进行排序，并返回数组。默认排序顺序是在将元素转换为字符串，然后比较它们的 UTF-16 代码单元值序列时构建的
let arr13 = [1, 2, 3, 4, ...`,l:"code/数组/array.html#array-prototype-sort",a:"array-prototype-sort"},"75.30":{t:"Array.prototype.splice()\r",p:`splice() 方法通过删除或替换现有元素或者原地添加新的元素来修改数组，并以数组形式返回被修改的内容。此方法会改变原数组。
let arr14 = [1, 2, 3, 4, 5, 6, 7, 8, ...`,l:"code/数组/array.html#array-prototype-splice",a:"array-prototype-splice"},"75.31":{t:"Array.prototype.toLocaleString()\r",p:`返回一个字符串表示数组中的元素。数组中的元素将使用各自的 toLocaleString 方法转成字符串，这些字符串将使用一个特定语言环境的字符串（例如一个逗号 &quot;,&quot;）隔开。
le ...`,l:"code/数组/array.html#array-prototype-tolocalestring",a:"array-prototype-tolocalestring"},"75.32":{t:"Array.prototype.toString()\r",p:`方法返回一个字符串，表示指定的数组及其元素。
let arr17 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
let result36 = arr17.toString()

 ...`,l:"code/数组/array.html#array-prototype-tostring",a:"array-prototype-tostring"},"76.0":{t:"# 数组扁平化\r",p:`let arr3 = [1, 2, [3, 4, 5, 6, [7, 8, [9]]]]

`,l:"code/数组/array2one.html",a:"数组扁平化"},"76.1":{t:"1. flat\r",p:`let result16 = arr3.flat(Infinity)
console.log('result16:', result16)

`,l:"code/数组/array2one.html#_1-flat",a:"_1-flat"},"76.2":{t:"2. tostring\r",p:`function flatten(arr) {
    return arr.toString().split(',').map((item, index) =&gt; parseFloat(item ...`,l:"code/数组/array2one.html#_2-tostring",a:"_2-tostring"},"76.3":{t:"3. 递归\r",p:"",l:"code/数组/array2one.html#_3-递归",a:"_3-递归"},"76.4":{t:"一层\r",p:`let arr = [1, 2, 3, [6, 5, 4]]
let result = []
for (let i = 0; i &lt; arr.length; i++) {
    result  ...`,l:"code/数组/array2one.html#一层",a:"一层"},"76.5":{t:"多层\r",p:`function flatten2(arr) {
    let result = []
    for (let i = 0; i &lt; arr.length; i++) {
        i ...`,l:"code/数组/array2one.html#多层",a:"多层"},"76.6":{t:"forEach递归\r",p:`const eachFlatten = (arr = [], deep = 1) =&gt; {
    const result = [];
        (function flat(arr,d ...`,l:"code/数组/array2one.html#foreach递归",a:"foreach递归"},"76.7":{t:"reduce递归\r",p:`const reduceflat = (arr = [], deep = 1) =&gt; {
    if(deep&lt;=0) return arr;
    return arr.reduce ...`,l:"code/数组/array2one.html#reduce递归",a:"reduce递归"},"77.0":{t:"# reduce function\r",p:`let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

`,l:"code/数组/reduce.html",a:"reduce-function"},"77.1":{t:"累加\r",p:`let result1 = arr.reduce((pre,cur)=&gt;{
    return pre + cur
},0)
console.log('result:', result1)

`,l:"code/数组/reduce.html#累加",a:"累加"},"77.2":{t:"最大值\r",p:`let result2 = arr.reduce((pre,cur)=&gt;{
    return Math.max(pre,cur)})

console.log('result2:', res ...`,l:"code/数组/reduce.html#最大值",a:"最大值"},"77.3":{t:"数组去重\r",p:`let result3 = arr.reduce((pre,cur)=&gt;{
    if(pre.indexOf(cur) == -1){
        pre.push(cur)
    } ...`,l:"code/数组/reduce.html#数组去重",a:"数组去重"},"77.4":{t:"分类\r",p:`const arr2 = [1,1,2,3,3,5,6,6]

let result4 = arr2.reduce((pre,cur)=&gt;{
    if(pre[cur]){
         ...`,l:"code/数组/reduce.html#分类",a:"分类"},"77.5":{t:"翻转字符串\r",p:"let str = 'result,wolder'\nlet result5 = Array.from(str).reduce((pre,cur)=&gt;{ \n    return `${cur}${ ...",l:"code/数组/reduce.html#翻转字符串",a:"翻转字符串"},"78.0":{t:"# 流光按钮\r",p:"\r",l:"components/button/flowingbutton.html",a:"流光按钮"},"78.1":{t:"展示效果\r",p:`&lt;Flowing-button&gt;流光按钮&lt;/Flowing-button&gt;
`,l:"components/button/flowingbutton.html#展示效果",a:"展示效果"},"78.2":{t:"全局挂载\r",p:`import { createApp } from 'vue'
import App from './App.vue'
import  LJT  from 'ljt-btn'
const app =  ...`,l:"components/button/flowingbutton.html#全局挂载",a:"全局挂载"},"78.3":{t:"局部挂载\r",p:`import {Button} from 'ljt-btn'

在组件内挂载之后只需要引用下面这行代码，你就可以看到流光按钮啦！
&lt;Button&gt;流光按钮&lt;/Button&gt;

`,l:"components/button/flowingbutton.html#局部挂载",a:"局部挂载"},"78.4":{t:"禁用\r",p:`使用disabled给按钮添加禁用功能
&lt;Flowing-button disabled=&quot;true&quot;&gt;流光按钮&lt;/Flowing-button&gt;
&lt; ...`,l:"components/button/flowingbutton.html#禁用",a:"禁用"},"79.0":{t:"Button 按钮\r",p:`&lt;!-- &lt;el-button&gt;Default&lt;/el-button&gt;
&lt;el-button type=&quot;primary&quot;&gt;Primary ...`,l:"components/button/normal.html",a:"button-按钮"},"79.1":{t:"效果展示\r",p:`普通按钮
&lt;el-row class=&quot;mb-4&quot;&gt;
&lt;el-button&gt;Default&lt;/el-button&gt;
&lt;el-button  ...`,l:"components/button/normal.html#效果展示",a:"效果展示"},"79.2":{t:"全局挂载\r",p:`import { createApp } from 'vue'
import App from './App.vue'
import  LJT  from 'ljt-btn'
const app =  ...`,l:"components/button/normal.html#全局挂载",a:"全局挂载"},"79.3":{t:"局部挂载\r",p:`import {LButton} from 'ljt-btn'

在组件内挂载之后只需要引用下面这行代码，你就可以看到按钮啦！
&lt;L-button type=&quot;success&quot ...`,l:"components/button/normal.html#局部挂载",a:"局部挂载"},"79.4":{t:"类型\r",p:`可以选择想要的类型，例如：
type = 'primary'|'success'
//事例
&lt;L-button type=&quot;primary&quot;&gt;primary&lt;/L ...`,l:"components/button/normal.html#类型",a:"类型"},"79.5":{t:"朴素按钮\r",p:`给按钮添加plain变为朴素按钮,例如：
&lt;L-button type=&quot;primary&quot; plain&gt;primary&lt;/L-button&gt;
&lt;L-b ...`,l:"components/button/normal.html#朴素按钮",a:"朴素按钮"},"79.6":{t:"圆角\r",p:`给按钮添加round变为圆角按钮,例如：
&lt;L-button type=&quot;primary&quot; round&gt;primary&lt;/L-button&gt;
&lt;L-b ...`,l:"components/button/normal.html#圆角",a:"圆角"},"79.7":{t:"禁用\r",p:`给按钮添加disabled变为不可选中状态,例如：
&lt;L-button type=&quot;primary&quot; disabled&gt;primary&lt;/L-button&gt; ...`,l:"components/button/normal.html#禁用",a:"禁用"},"79.8":{t:"给按钮添加icon\r",p:"给按钮添加icon=&quot;name&quot;属性,选择自己喜欢的name就可以在按钮上添加icon,如果icon想放在右侧只需要添加icon-position=&quot;right&quot ...",l:"components/button/normal.html#给按钮添加icon",a:"给按钮添加icon"},"80.0":{t:"# 输入框\r",p:"\r",l:"components/from/input.html",a:"输入框"},"80.1":{t:"普通输入框\r",p:`&lt;Linput  placeholder=&quot;请输入内容&quot;&gt;&lt;/Linput&gt;
&lt;Linput  placeholder=&quot;请输入内容&quo ...`,l:"components/from/input.html#普通输入框",a:"普通输入框"},"80.2":{t:"禁用\r",p:`disabled
&lt;Linput disabled placeholder=&quot;请输入内容&quot;&gt;&lt;/Linput&gt;
&lt;Linput disabled pl ...`,l:"components/from/input.html#禁用",a:"禁用"},"80.3":{t:"尺寸\r",p:`medium,small,mini,不传则默认
medium
&lt;Linput size=&quot;medium&quot; placeholder=&quot;请输入内容&quot;&gt;& ...`,l:"components/from/input.html#尺寸",a:"尺寸"},"80.4":{t:"一键清空\r",p:`当输入框有值时可一键清空
&lt;Linput size=&quot;medium&quot;  v-model=&quot;tel&quot; clearable placeholder=&quot ...`,l:"components/from/input.html#一键清空",a:"一键清空"},"80.5":{t:"密码框\r",p:"&lt;Linput size=&quot;medium&quot; v-model=&quot;tel&quot; type=&quot;password&quot; showPassword pl ...",l:"components/from/input.html#密码框",a:"密码框"},"80.6":{t:"带icon输入框\r",p:"&lt;Linput size=&quot;medium&quot; v-model=&quot;tel&quot; clearable prefixIcon=&quot;bianji&quot; p ...",l:"components/from/input.html#带icon输入框",a:"带icon输入框"},"80.7":{t:"复合输入框\r",p:`&lt;div class=&quot;upfile&quot;&gt;
&lt;Linput v-model=&quot;tel&quot; placeholder=&quot;请输入内容&quot ...`,l:"components/from/input.html#复合输入框",a:"复合输入框"},"80.8":{t:"自适应高度文本域\r",p:`设置autosize=&quot;{ minRows: 2, maxRows: 5 }最小行数为2，最大行数为5
&lt;Linput type=&quot;textarea&quot; :autos ...`,l:"components/from/input.html#自适应高度文本域",a:"自适应高度文本域"},"81.0":{t:"安装\r",p:`npm install ljt-btn

`,l:"components/guild/installation.html",a:"安装"},"82.0":{t:"# icon\r",p:"\r",l:"components/icon/icon.html",a:"icon"},"82.1":{t:"效果展示\r",p:`&lt;Licon name=&quot;apple-line&quot; color=&quot;red&quot;&gt;&lt;/Licon&gt;
&lt;Licon name=&quot;a ...`,l:"components/icon/icon.html#效果展示",a:"效果展示"},"82.2":{t:"全局挂载\r",p:`import { createApp } from 'vue'
import App from './App.vue'
import  LJT  from 'ljt-btn'
const app =  ...`,l:"components/icon/icon.html#全局挂载",a:"全局挂载"},"82.3":{t:"局部挂载\r",p:`import {Licon} from 'ljt-btn'

在组件内挂载之后只需要引用下面这行代码，选择你想要的图标name，你就可以看到图标啦！
&lt;Licon name=&quot;jinr ...`,l:"components/icon/icon.html#局部挂载",a:"局部挂载"},"82.4":{t:"徽标提示\r",p:`我们可以设置dot属性后，让我们图标右上角展示一个小红点；设置badge属性后，会在图标右上角展示相应的徽标,例如：
&lt;Licon name=&quot;apple-line&quot; dot ...`,l:"components/icon/icon.html#徽标提示",a:"徽标提示"},"82.5":{t:"颜色\r",p:`我们可以设置color属性更改你想要的颜色,例如：
&lt;Licon name=&quot;apple-line&quot; color=&quot;red&quot;/&gt;

说明：部分图标不 ...`,l:"components/icon/icon.html#颜色",a:"颜色"},"82.6":{t:"使用\r",p:"",l:"components/icon/icon.html#使用",a:"使用"},"82.7":{t:"logo\r",p:`&lt;Licon name=&quot;apple-line&quot; color=&quot;red&quot;/&gt;
&lt;Licon name=&quot;apple-fill&quo ...`,l:"components/icon/icon.html#logo",a:"logo"},"82.8":{t:"链接\r",p:`&lt;Licon name=&quot;attachment-2&quot; /&gt;
&lt;Licon name=&quot;attachment-line&quot; /&gt;
&lt;L ...`,l:"components/icon/icon.html#链接",a:"链接"},"82.9":{t:"筛选\r",p:`&lt;Licon name=&quot;apps-fill&quot; /&gt;
&lt;Licon name=&quot;shaixuan&quot; /&gt;
&lt;Licon name= ...`,l:"components/icon/icon.html#筛选",a:"筛选"},"82.10":{t:"点赞收藏\r",p:`&lt;Licon name=&quot;dianzan&quot; /&gt;
&lt;Licon name=&quot;shandian&quot; /&gt;
&lt;Licon name=&q ...`,l:"components/icon/icon.html#点赞收藏",a:"点赞收藏"},"82.11":{t:"声音\r",p:`&lt;Licon name=&quot;shengyinguanbi&quot; /&gt;
&lt;Licon name=&quot;shengyin&quot; /&gt;
&lt;Licon  ...`,l:"components/icon/icon.html#声音",a:"声音"},"82.12":{t:"箭头\r",p:`&lt;Licon name=&quot;a-xiala2&quot; /&gt;
&lt;Licon name=&quot;jinru&quot; /&gt;
&lt;Licon name=&quo ...`,l:"components/icon/icon.html#箭头",a:"箭头"},"82.13":{t:"分享\r",p:`&lt;Licon name=&quot;dianhua&quot; /&gt;
&lt;Licon name=&quot;a-fenxiang2&quot; /&gt;
&lt;Licon name ...`,l:"components/icon/icon.html#分享",a:"分享"},"82.14":{t:"删除\r",p:`&lt;Licon name=&quot;shanchu&quot; /&gt;
&lt;Licon name=&quot;guanbi&quot; /&gt;
&lt;Licon name=&quo ...`,l:"components/icon/icon.html#删除",a:"删除"},"82.15":{t:"编写文字\r",p:`&lt;Licon name=&quot;bianji&quot; /&gt;
&lt;Licon name=&quot;bofangjilu&quot; /&gt;
&lt;Licon name=& ...`,l:"components/icon/icon.html#编写文字",a:"编写文字"},"82.16":{t:"设置帮助\r",p:`&lt;Licon name=&quot;shezhi&quot; /&gt;
&lt;Licon name=&quot;saoyisao&quot; /&gt;
&lt;Licon name=&qu ...`,l:"components/icon/icon.html#设置帮助",a:"设置帮助"},"83.0":{t:"# 超链接\r",p:"\r",l:"components/link/link.html",a:"超链接"},"83.1":{t:"下划线\r",p:`underline属性添加下划线
&lt;Llink href=&quot;#&quot;  underline&gt;这是超链接&lt;/Llink&gt;
&lt;Llink href=&quot ...`,l:"components/link/link.html#下划线",a:"下划线"},"83.2":{t:"禁用\r",p:`disabled属性禁用
&lt;Llink href=&quot;#&quot;  disabled&gt;禁用超链接&lt;/Llink&gt;
&lt;Llink href=&quot;#&qu ...`,l:"components/link/link.html#禁用",a:"禁用"},"84.0":{t:"# 文件上传\r",p:"\r",l:"components/upload/upload.html",a:"文件上传"},"84.1":{t:"点击上传\r",p:`multiple可以上传多个文件 accept设置只允许上传文件类型
&lt;Lupload multiple accept=&quot;image/*&quot; @getFilesList=&qu ...`,l:"components/upload/upload.html#点击上传",a:"点击上传"},"84.2":{t:"拖拽上传\r",p:`添加drag属性
&lt;div class=&quot;upfile&quot;&gt;
&lt;Lupload multiple accept=&quot;image/*&quot; @getFi ...`,l:"components/upload/upload.html#拖拽上传",a:"拖拽上传"},"85.0":{t:"# bilibili错题\r",p:"\r",l:"fighting/bilibili/bilibili.html",a:"bilibili错题"},"85.1":{t:"定时器\r",p:`宏任务的定时器谁先到时间谁先执行
setTimeout(function(){
    console.log(1);
},2000)
setTimeout(function(){
    conso ...`,l:"fighting/bilibili/bilibili.html#定时器",a:"定时器"},"85.2":{t:"哪个样式在现代浏览器默认样式下设置宽度不生效`display:table-row`\r",p:`参考
table标签（display:table） 类似于 &lt;table&gt;
1. table可设置宽高、margin、border、padding等属性。属性值的单位可以使用px，百分比值 ...`,l:"fighting/bilibili/bilibili.html#哪个样式在现代浏览器默认样式下设置宽度不生效-display-table-row",a:"哪个样式在现代浏览器默认样式下设置宽度不生效-display-table-row"},"85.3":{t:"Object.prototype.toString.call(undefined)\r",p:`[object Undefined],object小写，Undefined首字母大写
`,l:"fighting/bilibili/bilibili.html#object-prototype-tostring-call-undefined",a:"object-prototype-tostring-call-undefined"},"85.4":{t:"obj对象里的箭头函数的this指向的是obj的上下文\r",p:`别再错了指向的是obj的上下文，指不到里面的
const obj = {
    a:1,
    foo:()=&gt;{
        console.log(this.a)
    }
}
o ...`,l:"fighting/bilibili/bilibili.html#obj对象里的箭头函数的this指向的是obj的上下文",a:"obj对象里的箭头函数的this指向的是obj的上下文"},"85.5":{t:"input标签的输入类型\r",p:`输入类型
没有telphone类型只有tel类型
`,l:"fighting/bilibili/bilibili.html#input标签的输入类型",a:"input标签的输入类型"},"85.6":{t:"状态码\r",p:`405：请求中的方法不允许使用
302：（临时移动）服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。而不是拒绝处理该请求
`,l:"fighting/bilibili/bilibili.html#状态码",a:"状态码"},"85.7":{t:"影响原数组\r",p:`splice,push,pop,shift,unshift,reverse,sort会影响原数组
其他的不会
`,l:"fighting/bilibili/bilibili.html#影响原数组",a:"影响原数组"},"85.8":{t:"clip-path\r",p:`clip-path 属性使用裁剪方式创建元素的可显示区域。区域内的部分显示，区域外的隐藏。可以指定一些特定形状。
`,l:"fighting/bilibili/bilibili.html#clip-path",a:"clip-path"},"85.9":{t:"promise的catch\r",p:`promise的catch只会执行第一个，和then不同不会传递到最后
Promise.rehect(0).catch((e)=&gt;e).catch(console.log(e))

只会执行第一 ...`,l:"fighting/bilibili/bilibili.html#promise的catch",a:"promise的catch"},"85.10":{t:"对象键值\r",p:`var a={},b='123',c=123
a[b]='b'
a[c]='c'
console.log(a[b]) //c
var a={},b=Symbol('123'),c=Symbol('12 ...`,l:"fighting/bilibili/bilibili.html#对象键值",a:"对象键值"},"85.11":{t:"分析\r",p:`情况一转为字符串后相当于重复赋值，情况二Symbol是唯一的b和c不一样，情况三{key:'123'}和{key:'456'}转为字符串都是[object,Object]，所以和情况一一样重复赋值
`,l:"fighting/bilibili/bilibili.html#分析",a:"分析"},"85.12":{t:"总结\r",p:`
Object对象转换为字符串和判断数据类型都是直接调用 toStirng() 方法，得到的结果都是 [object Object]。
除了Obeject之外的其他类型，直接调用 toStirng() ...`,l:"fighting/bilibili/bilibili.html#总结",a:"总结"},"85.13":{t:"let var\r",p:`let块级作用域输出0-1-2
for(let i = 0; i &lt; 3; i++) {
    setTimeout(function(){
        console.log(i)},0 ...`,l:"fighting/bilibili/bilibili.html#let-var",a:"let-var"},"85.14":{t:"过渡效果transition\r",p:`若过渡起始值或过渡开始值为auto，则浏览器不会自己计算成具体数字值，而是不发生过渡效果。所以要过渡某些属性，首先需要将其重置成具体数字值
.box{
    transition: hight 1s ...`,l:"fighting/bilibili/bilibili.html#过渡效果transition",a:"过渡效果transition"},"85.15":{t:'`<input type="text" />`change事件和inpute事件\r',p:`用户键入内容改变时，触发inpute事件，且当标签失焦后触发change事件
`,l:"fighting/bilibili/bilibili.html#input-type-text-change事件和inpute事件",a:"input-type-text-change事件和inpute事件"},"85.16":{t:"定位的top属性\r",p:`top属性规定内部元素的顶部边缘，定义了一个定位元素的上外边距与其包含块的上内边距
`,l:"fighting/bilibili/bilibili.html#定位的top属性",a:"定位的top属性"},"85.17":{t:"取余\r",p:`1 % 6 = 1,2 % 6 = 2,3 % 6 = 3,4 % 6 = 4,-7 % 3 = -1
`,l:"fighting/bilibili/bilibili.html#取余",a:"取余"},"85.18":{t:"三栏布局\r",p:`flex方法时，display:flex应该设置在父元素上
使用浮动时先写left再写right再写中间的，顺序不能乱
`,l:"fighting/bilibili/bilibili.html#三栏布局",a:"三栏布局"},"85.19":{t:"leecode 279",p:"",l:"fighting/bilibili/bilibili.html#leecode-279",a:"leecode-279"},"86.0":{t:"# 日常错题\r",p:"\r",l:"fighting/date/date.html",a:"日常错题"},"86.1":{t:"箭头函数\r",p:`
箭头函数后面有{ }就需要return来返回里面的数据，不写return会undefined
箭头函数后面没有{ }，不需要return，直接返回

sum(1, 2)
    .then(res  ...`,l:"fighting/date/date.html#箭头函数",a:"箭头函数"},"86.2":{t:"构造函数\r",p:`构造函数里的箭头函数方法挂载在对象自身里，普通函数放在原型上
class Mypromise {
    constructor(executor) {
        executor(this.# ...`,l:"fighting/date/date.html#构造函数",a:"构造函数"},"87.0":{t:"# 错题集\r",p:`你可上点心吧
`,l:"fighting/introductor.html",a:"错题集"},"88.0":{t:"leecode\r",p:"\r",l:"fighting/leecode/错题整理.html",a:"leecode"},"88.1":{t:"202. 快乐数\r",p:`var isHappy = function (n, count = 0) {
    let t = 0
    let num = n + ''
    let l = num.length
   ...`,l:"fighting/leecode/错题整理.html#_202-快乐数",a:"_202-快乐数"},"90.0":{t:"# 介绍\r",p:`通过vitepress和github pages在这里记录我的学习blog
这里有什么

面试题
代码手撕
封装好的组件库
错题集
...待更新

鹏之徙于南冥也,水击三千里,抟扶摇而上者九万里 —— ...`,l:"introduce/introduce.html",a:"介绍"},"91.0":{t:"快速开始\r",p:`从这里开始你的 面试题 之旅

等不及了从这里开始你的 代码手撕 之旅

等不及了从这里开始你的 组件库 之旅

温故而知新  错题集 长点心！
`,l:"introduce/quickstart.html",a:"快速开始"}},n={previewLength:100,buttonLabel:"搜索",placeholder:"情输入关键词",allow:[],ignore:[]},a={INDEX_DATA:t,PREVIEW_LOOKUP:e,Options:n};export{a as default};
