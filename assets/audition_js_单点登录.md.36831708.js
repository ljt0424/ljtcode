import{_ as o,o as e,c as p,U as a}from"./chunks/framework.afdf1834.js";const h=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"audition/js/单点登录.md","filePath":"audition/js/单点登录.md","lastUpdated":null}'),i={name:"audition/js/单点登录.md"},d=a('<h2 id="同域名下的单点登录" tabindex="-1">同域名下的单点登录 <a class="header-anchor" href="#同域名下的单点登录" aria-label="Permalink to &quot;同域名下的单点登录&quot;">​</a></h2><ol><li>将Cookie的domain属性设置为父域的域名（主域名），同时将 Cookie的path属性设置为根路径，将 Session ID（或 Token）保存到父域中。这样所有的子域应用就都可以访问到这个Cookie</li></ol><h2 id="不同域名下的单点登录-一" tabindex="-1">不同域名下的单点登录(一) <a class="header-anchor" href="#不同域名下的单点登录-一" aria-label="Permalink to &quot;不同域名下的单点登录(一)&quot;">​</a></h2><ol><li><p>用户访问app系统，app系统是需要登录的，但用户现在没有登录。</p></li><li><p>跳转到SSO登录系统， SSO系统也没有登录，弹出用户登录页。</p></li><li><p>用户填写用户名、密码，SSO系统进行认证后，<code>将登录状态写入SSO的session</code>，浏览器中写入<code>SSO域下的Cookie</code>。</p></li><li><p>SSO系统登录完成后会生成一个<code>Token</code>，然后跳转到app系统，同时将<code>Token</code>作为参数传递给app系统。</p></li><li><p>app系统拿到<code>Token</code>后，从后台向SSO发送请求，验证<code>Token</code>是否有效。</p></li><li><p>验证通过后，app系统将登录状态写入<code>app系统的session</code>并设置<code>app域下的Cookie</code>。 至此，跨域单点登录就完成了。以后我们再访问app系统时，app就是登录的。接下来，我们再看看访问app2系统时的流程。</p></li><li><p>用户访问app2系统，app2系统没有登录，跳转到SSO。</p></li><li><p>由于SSO已经登录了，不需要重新登录认证。</p></li><li><p>SSO生成<code>Token</code>，浏览器跳转到app2系统，并将<code>Token</code>作为参数传递给app2。</p></li><li><p>app2拿到<code>Token</code>，后台访问SSO，验证<code>Token</code>是否有效。</p></li><li><p>验证成功后，app2将登录状态写入<code>app2系统的session</code>，并在<code>app2域下写入Cookie</code>。 这样，app2系统不需要走登录流程，就已经是登录了。SSO，app和app2在不同的域，它们之间的session不共享也是没问题的</p></li></ol><p>访问子系统1没有登录-&gt;跳转sso系统登录-&gt;登录状态写入<code>SSO的session</code>，浏览器中写入<code>SSO域下的Cookie</code>-&gt;生成token给子系统1-&gt;验证token-&gt;登录状态写入<code>app系统的session</code>并设置<code>app域下的Cookie</code>-&gt;其他域不断重复-&gt;生成token，验证token，写session，cookie-&gt;登录</p>',5),c=[d];function t(s,n,l,S,_,r){return e(),p("div",null,c)}const O=o(i,[["render",t]]);export{h as __pageData,O as default};
